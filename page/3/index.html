<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-数据库理论" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/" class="article-date">
  <time class="dt-published" datetime="2023-06-15T12:12:02.325Z" itemprop="datePublished">2023-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="理论基础知识"><a href="#理论基础知识" class="headerlink" title="理论基础知识"></a>理论基础知识</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="数据库，数据库管理系统，数据库系统，数据库管理员"><a href="#数据库，数据库管理系统，数据库系统，数据库管理员" class="headerlink" title="数据库，数据库管理系统，数据库系统，数据库管理员"></a>数据库，数据库管理系统，数据库系统，数据库管理员</h3><ul>
<li>数据库：DB，数据（信息）的集合</li>
<li>数据库管理系统：DBMS，操纵和管理数据库的大型软件，用于建立，使用，维护数据库</li>
<li>数据库系统：DBS，由数据库，软件，数据库管理员组成</li>
<li>数据库管理员：DBA，负责全面管理和控制数据库系统</li>
</ul>
<h2 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h2><p>范式一共有三种：</p>
<ul>
<li>1NF(第一范式)：属性（列）不可再分</li>
<li>2NF(第二范式)：1NF的基础上，消除了非主属性对于码的<strong>部分函数依赖</strong></li>
<li>3NF(第三范式)：在2NF的基础上，消除了非主属性对码的<strong>传递依赖</strong></li>
</ul>
<h3 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式(1NF)"></a>第一范式(1NF)</h3><p>属性（字段）不能再分，字段只能是一个值，不能再分多个其他字段</p>
<p>1NF是所有关系型数据库最基本要求，即关系型数据库创建的表一定满足第一范式</p>
<h3 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式(2NF)"></a>第二范式(2NF)</h3><p>消除非主属性对码的部分函数依赖：</p>
<p>在第一范式基础上增加一个列，称为主键，非主属性都依赖主键</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/csdn/bd1d31be3779342427fc9e462bf7f05c.png" alt="第二范式"></p>
<p><strong>重要概念</strong></p>
<ul>
<li><p>函数依赖：属性（或者属性组）值X确定下，必定可以确定属性Y的值</p>
</li>
<li><p>部分函数依赖：属性Y依赖属性X，属性X有一个真子集X0可以确定所有的Y。</p>
<p>比如学号和身份证可以一起确定学生姓名，而且子集学号或者自己身份证也可以确定学生姓名，就称为部分函数依赖</p>
<p>理解：有一条属性可以通过多个其他属性来确定，这些多个其他属性也不是全部都需要的</p>
</li>
<li><p>传递函数依赖：属性X决定属性Y，属性Y决定属性Z就称属性Z传递依赖X。比如学号，姓名，系名，系主任中，学号可以决定系名，系名可以决定系主任，即存在非主属性系主任对于学号的传递依赖</p>
</li>
</ul>
<h3 id="第三范式-3NF"><a href="#第三范式-3NF" class="headerlink" title="第三范式(3NF)"></a>第三范式(3NF)</h3><p>在2NF基础上消除非主属性对于码的传递依赖</p>
<h2 id="为何不推荐外键和级联"><a href="#为何不推荐外键和级联" class="headerlink" title="为何不推荐外键和级联"></a>为何不推荐外键和级联</h2><p>阿里巴巴开发手册：</p>
<p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</p>
<p>说明: 以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群; 级联更新是强阻塞，存在数据库<strong>更新风暴</strong>的风险; 外键影响数据库的插入速度</p>
<p>不推荐外键的原因：</p>
<ol>
<li>增加复杂度，每次的Delete和Update都要考虑外键约束</li>
<li>增加额外工作，需要增加维护外键的工作</li>
<li>对分库分表不友好，分库分表下外键无法生效</li>
</ol>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>可以看成一些SQL语句的集合，加上一些逻辑控制语句，存在数据库中，一次编译永久有效。业务比较复杂的时候，完成一个操作需要写一大堆SQL，可以写一个存储过程来替代，方便下一次调用。存储过程比SQL语句执行更快</p>
<p>阿里开发手册禁止使用存储过程，因为存储过程难以调试和扩展，更没有移植性</p>
<h2 id="drop，delete，truncate"><a href="#drop，delete，truncate" class="headerlink" title="drop，delete，truncate"></a>drop，delete，truncate</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul>
<li><code>drop</code>：丢弃数据，drop table 表名，直接将表删除</li>
<li><code>truncate</code>：清空数据，truncate table 表名，只删除表数据，再次插入自增长id依旧从1开始</li>
<li><code>delete</code>：删除数据，delete from 表名 where 列名&#x3D;值，删除某一行数据，如果不加where语句和truncate 表名作用一致</li>
</ul>
<h3 id="数据库语言不同"><a href="#数据库语言不同" class="headerlink" title="数据库语言不同"></a>数据库语言不同</h3><p>truncate和drop属于DDL（数据定义）,操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。</p>
<p>delete属于DML（数据库操作语言）,这个操作会放到 rollback segment 中，事务提交之后才生效。</p>
<h3 id="执行速度"><a href="#执行速度" class="headerlink" title="执行速度"></a>执行速度</h3><p>drop&gt;truncate&gt;delete</p>
<ul>
<li><code>delete</code>命令执行的时候会产生数据库的<code>binlog</code>日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。</li>
<li><code>truncate</code>命令执行的时候不会产生数据库日志，因此比<code>delete</code>要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。</li>
<li><code>drop</code>命令会把表占用的空间全部释放掉。</li>
</ul>
<h2 id="数据库设计步骤"><a href="#数据库设计步骤" class="headerlink" title="数据库设计步骤"></a>数据库设计步骤</h2><ol>
<li>需求分析：分析用户的需求，包括数据，功能和性能需求</li>
<li>概念结构设计：采用E-R模型设计，包括画E-R图</li>
<li>逻辑结构设计：将E-R图转换成表，实现E-R模型到关系模型的转换</li>
<li>物理结构设计：为数据库选择合适的存储结构和存取路径</li>
<li>数据库实施：包括编程，测试和试运行</li>
<li>数据库运行和维护：系统的运行与数据库的日常维护</li>
</ol>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="通用基础"><a href="#通用基础" class="headerlink" title="通用基础"></a>通用基础</h2><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p><strong>MyISAM</strong></p>
<p>MySQL5.5之前的默认存储引擎，性能和特性都不错</p>
<p>缺点：不支持<strong>事务</strong>和<strong>行级锁</strong>，最重要的是<strong>崩溃后无法安全恢复</strong></p>
<p><strong>InnoDB</strong></p>
<p>MySQL5.5之后的默认存储引擎</p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>总结为：</p>
<ul>
<li>InnoDB 支持行级别的<strong>锁粒度</strong>，MyISAM 不支持，只支持表级别的锁粒度。</li>
<li>MyISAM 不提供<strong>事务支持</strong>。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。</li>
<li>MyISAM 不支持<strong>外键</strong>，而 InnoDB 支持。</li>
<li>MyISAM 不支持 <strong>MVCC</strong>，而 InnoDB 支持。</li>
<li>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 <strong>B+Tree</strong> 作为索引结构，但是两者的实现方式不太一样。</li>
<li>MyISAM 不支持数据库异常<strong>崩溃后的安全恢复</strong>，而 InnoDB 支持。</li>
<li>InnoDB 的<strong>性能</strong>比 MyISAM 更强大。</li>
</ul>
<h3 id="执行SQL语句的流程"><a href="#执行SQL语句的流程" class="headerlink" title="执行SQL语句的流程"></a>执行SQL语句的流程</h3><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程"></p>
<p>MySQL中架构分为Server层和存储引擎层</p>
<ul>
<li>Server层负责建立连接，分析和执行SQL，大多核心功能模块都在这里实现。主要功能包括连接器，查询缓存，解析器，预处理器，优化器，执行器等。所有的内置函数（日期，时间，数学和加密函数等）和所有跨存储引擎的功能（存储过程，触发器，视图等）都在Server层实现</li>
<li>存储引擎层负责数据的存储和提取。支持InnoDB，MyISAM，Memory等多个存储引擎，不同存储引擎共用同一个Server层。索引数据结构就是通过存储引擎层实现，不同存储引擎支持的索引类型也都不相同，比如InnoDB默认支持B+树</li>
</ul>
<p>执行SQL查询语句发生的流程：</p>
<h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><ol>
<li>使用MySQL首先要连接MySQL服务，连接需要先经过TCP三次握手（MySQL通过TCP协议传输）</li>
<li>TCP连接建立后连接器验证用户名和密码</li>
<li>用户名密码通过后连接器获取用户权限并保存，后续所有的操作都会基于这个权限逻辑的判断</li>
</ol>
<p>可以通过</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> processlist;</span><br></pre></td></tr></table></figure>

<p>以上命令查看当前服务被多少客户端连接</p>
<p>MySQL对于连接后再没有执行命令的连接设置了空闲连接最大空闲时长，超过这个时间连接器会自动断开</p>
<p>连接数有限制</p>
<p><strong>支持长连接短链接</strong></p>
<p>长连接问题：占用内存增多，如果长连接累积过多，MySQL服务占用内存太大，会被系统强制杀掉，就是MySQL服务重启现象</p>
<p><strong>解决方法</strong>:</p>
<ul>
<li>定期断开长连接</li>
<li>客户端主动重置连接</li>
</ul>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><ol>
<li>服务已经建立，客户端向MySQL服务发送SQL语句，服务端收到后解析第一个字段看是什么类型语句</li>
<li>如果是select语句，先去查询缓存中查找数据是否曾经执行过这一命令，查询缓存以key-value保存，key是SQL查询语句，value是查询结果</li>
<li>如果命中则返回，没命中继续执行同时将结果存入查询缓存</li>
</ol>
<p>MySQL8.0之后不再使用查询缓存，因为查询缓存很鸡肋，对于更新频繁的表，查询缓存会被经常清空</p>
<h4 id="解析SQL"><a href="#解析SQL" class="headerlink" title="解析SQL"></a>解析SQL</h4><p>解析器解析SQL</p>
<ul>
<li><p>词法分析</p>
<p>将字符串的关键词识别，构建SQL语法树，方便后续模块获取SQL类型，表名，字段名，where条件等信息</p>
</li>
<li><p>语法分析</p>
<p>根据词法分析结果，根据语法规则判断输入SQL语句是否满足MySQL语法</p>
</li>
</ul>
<p>表或者字段存不存在不由解析器负责，解析器仅仅负责构建语法树和检查语法</p>
<h4 id="执行SQL"><a href="#执行SQL" class="headerlink" title="执行SQL"></a>执行SQL</h4><p>select的流程分为三个阶段：</p>
<ul>
<li><p>prepare阶段，预处理阶段：</p>
<ul>
<li>检查SQL查询语句的表或者字段是否存在</li>
<li>将*等拓展成表上的列</li>
</ul>
</li>
<li><p>optimize阶段，优化阶段：</p>
<p>优化器负责将SQL查询语句的执行方案确定，比如索引的使用</p>
</li>
<li><p>execute阶段，执行阶段：</p>
<p>执行器完成执行语句的工作，会跟存储引擎交互</p>
<p>三种方式执行的过程：</p>
<ul>
<li>主键索引查询</li>
<li>全表扫描</li>
<li>索引下推</li>
</ul>
</li>
</ul>
<h3 id="MySQL记录的存储"><a href="#MySQL记录的存储" class="headerlink" title="MySQL记录的存储"></a>MySQL记录的存储</h3><p>MySQL存储在磁盘，每创建一个database（数据库）都会在&#x2F;var&#x2F;lib&#x2F;mysql目录下创建一个以database为名的目录然后保存表结构和表数据文件</p>
<p>比如这个my_test的database作为例子</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/database.png" alt="img"></p>
<p>&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;my_test目录下文件：</p>
<ul>
<li>db_opt：用来存储当前数据库默认字符集和字符校验规则</li>
<li>t_order.frm：t_order的<strong>表结构</strong>会保存在这个文件。在MySQL中建立一张表都会生成一个.frm文件，用来保存每个表的元数据信息，包含表结构的定义</li>
<li>t_order.ibd：t_order的<strong>表数据</strong>会保存在这个文件。表数据既可以存在公共表空间文件（文件ibdata1），也可以这样以表名命名独占表空间文件。由参数innodb_file_per_table控制，默认单独存储</li>
</ul>
<h4 id="表空间文件的结构"><a href="#表空间文件的结构" class="headerlink" title="表空间文件的结构"></a>表空间文件的结构</h4><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.drawio.png" alt="img"></p>
<ul>
<li><p>行：每一条记录</p>
</li>
<li><p>页：为了读写效率，每次按照页为单位读取，页的大小默认16KB</p>
</li>
<li><p>区：因为InnoDB使用B+树组织数据，为了查询的效率，最好将B+树双向链表相邻的页在物理上也相邻。因此使用区来分配空间，默认大小1MB，即64个页分为1个区</p>
</li>
<li><p>段：</p>
<ul>
<li><p>索引段：存放B+树的非叶子节点的区的集合</p>
</li>
<li><p>数据段：存放B+树叶子节点的区的集合</p>
</li>
<li><p>回滚段：存放回滚数据的区的集合</p>
</li>
</ul>
</li>
</ul>
<h4 id="行格式"><a href="#行格式" class="headerlink" title="行格式"></a>行格式</h4><p>存储一条记录的结构有四种</p>
<ul>
<li><p>Redundant：</p>
<p>MySQL5.0之前使用，已废弃</p>
</li>
<li><p>Compact：</p>
<p>MySQL5.0之后引入的紧凑行记录存储格式，初衷是让一个数据页存放更多的行记录。MySQL5.1之后默认使用</p>
</li>
<li><p>Dynamic，Compressed：</p>
<p>都是紧凑的行格式，和Compact类似，都是基于Compact改进了一些地点。MySQL5，7之后默认使用Dynamic</p>
</li>
</ul>
<h4 id="Compact行格式"><a href="#Compact行格式" class="headerlink" title="Compact行格式"></a>Compact行格式</h4><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png" alt="img"></p>
<p>记录的额外信息：</p>
<ul>
<li><p>变长字段长度列表</p>
<p>比如varchar这样的字段的长度不固定，需要提前记录这个字段的长度</p>
</li>
<li><p>NULL值列表</p>
<p>表中某些列可能存储NULL值，用一个二进制位表示允许存在NULL值列是否为NULL，每一个列一个二进制位，组合成了NULL值列表</p>
</li>
<li><p>记录头信息</p>
<ul>
<li>delete_mask：标识这条数据是否被删除（所以执行delete不会真正删除记录而使将这个值标记为1）</li>
<li>next_record：下一条记录的位置，记录的是下一条记录的记录头和真实数据之间的位置</li>
<li>record_type：表示当前记录类型，0是普通记录，1是B+树非叶子节点记录，2是最小记录，3是最大记录</li>
</ul>
</li>
</ul>
<p>记录的真实数据</p>
<ul>
<li>row_id：如果指定主键或者唯一约束列，就没有row_id隐藏字段，如果没有唯一约束，InnoDB就会给记录添加row_id隐藏字段，这个是非必须的</li>
<li>trx_id：事务id，表示数据由哪个事务生成，trx_id必须，占用6字节</li>
<li>roll_pointer：记录上一个版本指针，必须，占用7字节</li>
</ul>
<h4 id="行溢出"><a href="#行溢出" class="headerlink" title="行溢出"></a>行溢出</h4><p>因为一个页大小16KB，而varchar字段最多可以存储65535字节，大的text数据等对于一个页满足不了大小，多出的数据会存储到另外溢出页中。真实数据处用20字节存储指向溢出页的地址，从而找到剩余数据所在的页</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>索引是帮助存储引擎快速获取数据的一种数据结构，可以理解为数据的目录</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>按数据结构分类：B+tree索引，Hash索引，Full-text索引</li>
<li>按物理存储分类：聚簇索引（主键索引），二级索引（辅助索引）</li>
<li>按字段特性分类：主键索引，唯一索引，普通索引，前缀索引</li>
<li>按字段个数分类：单列索引，联合索引</li>
</ul>
<h4 id="数据结构分类"><a href="#数据结构分类" class="headerlink" title="数据结构分类"></a>数据结构分类</h4><p>主要是B+tree索引，Hash索引和Full-text索引</p>
<p>不同的存储引擎支持的索引不同，对于MySQL常见的InnoDB，MyISAM和Memory：</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230604103231294.png" alt="image-20230604103231294"></p>
<h5 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h5><p>B+Tree索引类型是MySQL存储引擎采用最多的索引类型</p>
<p>创建表时InnoDB存储引擎会根据不同情况选择不同列作为索引：</p>
<ul>
<li>如果有主键，默认会使用主键作为聚簇索引的索引键</li>
<li>如果没有主键，选择第一个不包含NULL值的唯一列作为聚簇索引的索引键</li>
<li>如果上面两个情况都不满足，InnoDB自动生成一个隐式自增id列作为聚簇索引的索引键</li>
</ul>
<p>其他的索引都属于辅助索引，主键索引和二级索引默认使用的是B+Tree索引</p>
<p>B+Tree主键索引：</p>
<p>叶子节点实际上是双向列表这里有误</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230604103702998.png" alt="image-20230604103702998"></p>
<p>千万级别的数据只需要3-4层高度，只需要进行3-4次磁盘I&#x2F;O，查询效率很高</p>
<p>二级索引就不存所有的数据，在B+Tree中存储主键值</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230604104145455.png" alt="image-20230604104145455"></p>
<p>二级索引会查询到主键然后到主键索引中查询数据，这个过程称为回表，即查找两个B+Tree</p>
<p><strong>为什么选择B+树？</strong></p>
<ul>
<li>与B树相比：B树在非叶子节点也要存储数据，所以相比起来B+树单个节点数据量更小，在相同的磁盘I&#x2F;O下能查询到更多节点。B+Tree叶子节点采用双向链表，符合MySQL中常见的基于范围的顺序查找，B树无法完成</li>
<li>和二叉树相比：二叉树的层级更高，意味着I&#x2F;O读取更多</li>
<li>和Hash相比：Hash在做等值查询时效率快，搜索复杂度O(1)，但是Hash表不适合范围查询</li>
</ul>
<h4 id="物理存储分类"><a href="#物理存储分类" class="headerlink" title="物理存储分类"></a>物理存储分类</h4><p>如数据结构分类中B+树的主键索引和二级索引所提到，二级索引叶子节点存主键，主键的叶子节点存详细数据</p>
<h4 id="字段特性分类"><a href="#字段特性分类" class="headerlink" title="字段特性分类"></a>字段特性分类</h4><p>主要分为主键索引，唯一索引，普通索引，前缀索引</p>
<ul>
<li><strong>主键索引</strong></li>
</ul>
<p>创建表时创建<strong>主键索引</strong>的方式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name(</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">primary</span> key (index_column_1) <span class="keyword">using</span> btree</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>唯一索引</strong></li>
</ul>
<p>创建在UNIQUE字段上</p>
<p>建表时创建方式</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name(</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">unique</span> key(index_column_1,index_column_2,...)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>建表后：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index index_name</span><br><span class="line"><span class="keyword">on</span> table_name(index_column_1,index_column_2,...);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>普通索引</strong></li>
</ul>
<p>在普通字段上的所有，既不要求为主键也不要求字段为unique</p>
<p>创建方式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name(</span><br><span class="line">	...</span><br><span class="line">    index(index_column_1,index_column_2,...)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index index_name</span><br><span class="line"><span class="keyword">on</span> table_name(index_column_1,index_column_2,...);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>前缀索引</strong></li>
</ul>
<p>对字符类型字段前几个字符建立索引，可以建立在char，varchar，binary，varbinary列</p>
<p>目的是为了减少索引占用的存储空间，提升查询效率</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name(</span><br><span class="line">	column_list,</span><br><span class="line">    index(column_name(length))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index index_name</span><br><span class="line"><span class="keyword">on</span> table_name(column_name(length));</span><br></pre></td></tr></table></figure>

<h4 id="字段个数分类"><a href="#字段个数分类" class="headerlink" title="字段个数分类"></a>字段个数分类</h4><p>在单列上的索引为单列索引，多列上为联合索引</p>
<p>如果用多个字段一起建立联合索引</p>
<p>对于创建联合索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_product_no_name <span class="keyword">ON</span> product(product_no, name);</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230604111407341.png" alt="image-20230604111407341"></p>
<p>字段会按照顺序比较，所以联合索引最左匹配原则，按照最左边字段先匹配</p>
<p>如果查询时最左边字段不存在，那联合索引会失败</p>
<p>如果按照abc的顺序建立了联合索引</p>
<p>对于</p>
<ul>
<li>where a&#x3D;1；</li>
<li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li>
<li>where a&#x3D;1 and b&#x3D;2；</li>
</ul>
<p>即使a的位置不一样，优化器也会重新排序，没影响都可以使用联合索引</p>
<p>但是对于</p>
<ul>
<li>where b&#x3D;2；</li>
<li>where c&#x3D;3；</li>
<li>where b&#x3D;2 and c&#x3D;3；</li>
</ul>
<p>这就无法使用联合索引，因为a是全局有序的，bc是在a的顺序下局部有序的</p>
<p><strong>联合索引的最左匹配原则</strong></p>
<p><strong>在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配，可以去看一下例子</strong></p>
<p><strong>索引区分度</strong></p>
<p>因为联合索引的字段顺序对索引效率有很大影响，越靠前字段被用于索引过滤的概率越高，实际开发中建立联合索引要把<strong>区分度大的字段</strong>排在前面，越有可能被SQL使用到</p>
<p>区分度表示某个字段不同值的个数除以表的总行数</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230604160257567.png" alt="image-20230604160257567"></p>
<p>索引提升了查询速度，但是</p>
<ul>
<li>占用物理空间，数量越大，占用空间越大</li>
<li>创建索引和维护索引需要耗费时间，随着数据量增大增大</li>
<li>会降低表的增删改效率，每次增删改B+树需要进行动态维护</li>
</ul>
<p>什么时候使用索引</p>
<ul>
<li>字段有唯一性限制</li>
<li>经常用于where查询条件</li>
<li>经常用于group by和order by，可以防止查询时再做排序</li>
</ul>
<p>什么时候不需要创建索引</p>
<ul>
<li>where条件，group by，order by用不到的字段</li>
<li>字段中有大量重复数据</li>
<li>表数据太少</li>
<li>经常更新的字段</li>
</ul>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="前缀索引优化"><a href="#前缀索引优化" class="headerlink" title="前缀索引优化"></a>前缀索引优化</h4><p>在大字符串作为索引时，前缀索引可以帮助减小索引项的大小</p>
<p>局限：</p>
<ul>
<li>order by无法使用前缀索引</li>
<li>无法把前缀索引用作覆盖索引</li>
</ul>
<h4 id="覆盖索引优化"><a href="#覆盖索引优化" class="headerlink" title="覆盖索引优化"></a>覆盖索引优化</h4><p>在B+树上可以找到所有索引的记录，不需要回表操作</p>
<p>比如需要查询商品ID，名称，价格，在索引中存在这些数据，下次查询就不需要再到主键索引上回表</p>
<h4 id="主键搜索最好自增"><a href="#主键搜索最好自增" class="headerlink" title="主键搜索最好自增"></a>主键搜索最好自增</h4><p>每次插入新数据，就会按照顺序添加到当前索引节点位置，不需要移动已有数据，每次都是追加操作，不需要重新移动数据。</p>
<h4 id="索引最好设置not-null"><a href="#索引最好设置not-null" class="headerlink" title="索引最好设置not null"></a>索引最好设置not null</h4><ul>
<li>原因1：索引列在null就会导致优化器索引选择更复杂更难优化</li>
<li>原因2：null是个无意义值但是会占用物理空间</li>
</ul>
<h4 id="防止索引失败"><a href="#防止索引失败" class="headerlink" title="防止索引失败"></a>防止索引失败</h4><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务特性ACID"><a href="#事务特性ACID" class="headerlink" title="事务特性ACID"></a>事务特性ACID</h3><ul>
<li>原子性：通过undo log（回滚日志）来保证</li>
<li>一致性：一致性是其他三者的目的，通过持久性+原子性+隔离性来保证</li>
<li>隔离性：通过MVCC（多版本并发控制）或者锁机制来保证</li>
<li>持久性：通过redo log（重做日志）来保证</li>
</ul>
<h3 id="并行事务引发的问题"><a href="#并行事务引发的问题" class="headerlink" title="并行事务引发的问题"></a>并行事务引发的问题</h3><p>脏读：读到了其他事务没提交的数据</p>
<p>不可重复读：前后两次数据读到不一样的情况</p>
<p>幻读：查询到的记录数量不一样</p>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul>
<li>读未提交：read uncommitted</li>
<li>读提交：read committed，生成Read View数据快照</li>
<li>可重复读：repeatable read，默认隔离级别，生成Read View数据快照，区别于读提交在于创建时机不同</li>
<li>串行化：serializable，通过加锁的方式避免并行访问</li>
</ul>
<p>MySQL在可重复读隔离级别上可以很大程度避免幻读，不会使用串行化，影响性能</p>
<p>缓减幻读情况出现：</p>
<ul>
<li>针对快照读（普通select），通过MVCC方式解决幻读</li>
<li>针对当前读（select … for update等），通过next-key lock（记录锁+间隙锁）解决幻读</li>
</ul>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>MVCC，即<strong>Multi-Version Concurrency Control （多版本并发控制）</strong>。它是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p>
<p>InnoDB的实现</p>
<h4 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h4><p>包括四个字段</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230614103042948.png" alt="image-20230614103042948"></p>
<ul>
<li>m_ids：创建Read View时当前数据库中<strong>活跃事务</strong>（启动了还没提交的事务）的id列表</li>
<li>min_trx_id：创建Read View时当前数据库<strong>活跃事务</strong>中事务id最小的事务（m_id最小值）</li>
<li>max_trx_id：创建Read View时数据库应该给下一个事务的id值，即全局事务id最大的事务id+1</li>
<li>creator_trx_id：创建该Read View的事务id</li>
</ul>
<h4 id="聚簇索引中的两个隐藏列"><a href="#聚簇索引中的两个隐藏列" class="headerlink" title="聚簇索引中的两个隐藏列"></a>聚簇索引中的两个隐藏列</h4><p><img src="https://cdn.xiaolincoding.com//mysql/other/f595d13450878acd04affa82731f76c5.png" alt="图片"></p>
<p>在InnoDB中的数据库表，聚簇索引记录都包含以下两个隐藏列</p>
<ul>
<li>trx_id：当一个事务对某条聚簇索引的记录改动时就会把该事务的id记录在trx_id</li>
<li>roll_pointer：当某条聚簇索引记录改动时，会把旧纪录写入undo日志，这里是个回滚指针可以找到修改前记录</li>
</ul>
<p>因此通过上面的几个字段可以区分不同事务</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230614104051383.png" alt="image-20230614104051383"></p>
<p>这种通过版本链来控制并发事务访问同一个记录的行为就叫做MVCC多版本并发控制</p>
<h4 id="可重复读如何实现"><a href="#可重复读如何实现" class="headerlink" title="可重复读如何实现"></a>可重复读如何实现</h4><p>启动事务时生成一个Read View，整个事务期间都在用这个Read View。</p>
<p>如果启动两个连续事务AB如下</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230614105926035.png" alt="image-20230614105926035"></p>
<p>m_id表示活跃事务的列表，min_trx_id表示最小的活跃事务（最早创建），max_trx_id表示下一个事务id</p>
<p>如果接下来的操作如下</p>
<ul>
<li>事务 B 读取小林的账户余额记录，读到余额是 100 万；</li>
<li>事务 A 将小林的账户余额记录修改成 200 万，并没有提交事务；</li>
<li>事务 B 读取小林的账户余额记录，读到余额还是 100 万；</li>
<li>事务 A 提交事务；</li>
<li>事务 B 读取小林的账户余额记录，读到余额依然还是 100 万；</li>
</ul>
<p>事务B读取数据时发现数据trx_id比最小的活跃事务小，说明事务已经提交了，这个记录是可见的，可以获取到这条记录</p>
<p>事务A读取修改记录，此时未提交，会记录响应undo log，以链表形式串联形成版本链</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230614111532978.png" alt="image-20230614111532978"></p>
<p>B再次读取记录，发现trx_id编程51了，这里在B记录的活跃事务中因此不会读取这条记录，会沿着版本链去读取已提交事务的记录，也就是trx_id为50的记录</p>
<p>A提交事务后B再次读取，因为隔离级别是可重复读，事务B会根据启动事务时创建的Read View来判断，所以依旧读取trx_id为50的记录</p>
<p><strong>可重复读隔离级别下，事务读取记录都是事务启动前的记录</strong></p>
<h4 id="读提交如何实现"><a href="#读提交如何实现" class="headerlink" title="读提交如何实现"></a>读提交如何实现</h4><p>每次读取数据时都会生成一个新的Read View，根据trx_id判断读的记录是不是在活跃事务中（即还未提交），沿着版本链读取已经提交的记录</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>锁住后数据库就处于只读状态，主要用作全库逻辑备份。这样在备份期间数据不会变化不会导致备份和预期不一致。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>全局锁会让整个数据库为只读，如果数据库数据多，备份耗时且不能更新数据，会造成业务停滞。</p>
<h4 id="如何避免备份数据库开启全局锁影响业务"><a href="#如何避免备份数据库开启全局锁影响业务" class="headerlink" title="如何避免备份数据库开启全局锁影响业务"></a>如何避免备份数据库开启全局锁影响业务</h4><p>在备份数据库前开启事务，隔离级别为可重复读，会创建Read View，整个事务执行期间都在用这个Read View。备份期间业务依旧可以对数据库更新</p>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>包括</p>
<ul>
<li>表锁：限制其他线程以及本线程的读写，尽量避免使用，锁粒度太大</li>
<li>元数据锁(MDL)：对数据库表操作会自动给表加上MDL，一个线程select时其他线程要改变表结构就会被阻塞。当线程对表结构变更时，其他线程执行CRUD会被阻塞。在事务提交之后释放</li>
<li>意向锁：在加共享锁前需要加上一个意向共享锁，加独占锁（插入，更新，删除）前加意向独占锁。意向锁的目的是为了快速判断表里是否有记录被加锁</li>
<li>AUTO-INC锁：主键自增的实现，会阻塞其他的插入语句，保证自增字段连续递增</li>
</ul>
<h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>InnoDB支持，MyISAM不支持</p>
<ul>
<li>Record Lock记录锁：锁一条记录</li>
<li>Gap Lock间隙锁：锁一个范围，但是不包含记录本身</li>
<li>Next-Key Lock：锁一个范围且锁定记录本身</li>
</ul>
<h4 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h4><p>锁一条记录，分为S锁和X锁</p>
<p>S锁可以与S锁兼容（可以继续加S锁），X锁无法再加任何锁（包括S和X）</p>
<h4 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h4><p>只存在可重复读隔离级别，目的是为了解决可重复读隔离级别下的幻读现象</p>
<p>比如锁住了范围（3，5），就无法插入4的数据</p>
<h4 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h4><p>针对Gap Lock的例子，既无法插入4的数据也无法修改3和5</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><ul>
<li>undo log（回滚日志）：存储引擎层实现的日志，实现事务的原子性，用于事务回滚和MVCC</li>
<li>redo log（重做日志）：存储引擎层的日志，实现事务持久性，主要用于断电等故障恢复</li>
<li>binlog（归档日志）：Server层的日志，用于数据备份和主从复制</li>
</ul>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/" data-id="clix3qjvu000mqwued1lhevt3" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-设计模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2023-06-15T12:12:02.322Z" itemprop="datePublished">2023-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-设计模式"><a href="#1-设计模式" class="headerlink" title="1.设计模式"></a>1.设计模式</h1><ul>
<li><p>创建型模式</p>
<p>用于描述如何创建对象，特点是将对象的创建和使用分离：</p>
<p>单例，原型，工厂方法，抽象工厂，建造者</p>
</li>
<li><p>结构型模式</p>
<p>描述如何将类或者对象按照某种布局组成更大的结构</p>
<p>代理，适配器，桥接，装饰，外观，享元，组合</p>
</li>
<li><p>行为型模式</p>
<p>描述类或者对象之间怎样相互写作共同完成单个对象无法单独完成的任务，以及怎样分配职责。</p>
<p>模板方法，策略，命令，职责链，状态，观察者，中介者，迭代器，访问者，备忘录，解释器</p>
</li>
</ul>
<h2 id="1-1创建型模式"><a href="#1-1创建型模式" class="headerlink" title="1.1创建型模式"></a>1.1创建型模式</h2><h3 id="1-1-1单例设计模式-重要"><a href="#1-1-1单例设计模式-重要" class="headerlink" title="1.1.1单例设计模式(重要)"></a>1.1.1单例设计模式(重要)</h3><h4 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h4><p>只能创建自己的单个对象，保证一个类只有一个实例并且提供一个全局访问点</p>
<p><img src="https://img-blog.csdnimg.cn/02a7b17b00b14278a69aa8518cda4733.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiJ5Zub5pyI5LqL5YWr5Lmd5pyI5p6c,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>重量级对象，不需要多个实例，如线程池，数据库连接池</p>
<h4 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h4><p>补充：私有构造方法为了不让创建实例</p>
<p><strong>定义</strong>：加载不会导致单实例对象被创建，只有在真正使用的时候才会开始实例化</p>
<p><strong>特点</strong>：</p>
<p>方式一：synchronized保证线程安全方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//本类中定义本类对象,没有赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">//提供一个全局访问方式获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断instance是否已经创建</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">         	instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式：思考线程安全问题，判断与创建不能满足原子性，需要使用synchronized关键字。问题在于synchronized导致性能差。</p>
<p>方式二：双重检查锁（推荐）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//本类中定义本类对象,没有赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">//提供一个全局访问方式获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//一次判断</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="comment">//二次判断</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时考虑了单例，安全，性能。</p>
<p>问题：在多线程情况下可能会出现空指针问题，原因是JVM在实例化对象会优化和指令重排，解决方式是使用<code>volatile</code>关键字保证可见性和有序性。</p>
<p>方式三：静态内部类（推荐）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//由内部类创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供一个全局访问方式获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM在<strong>加载外部类过程中，不会加载静态内部类</strong>，只有内部类的属性&#x2F;方法被调用时才会被加载</p>
<p>没有加任何锁的情况下保证了多线程的安全，同时没有任何性能影响和资源浪费</p>
<h4 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h4><p><strong>定义</strong>：<strong>类加载</strong>就会导致该单实例对象被创建</p>
<p><strong>特点</strong>：类加载就创建可能导致内存浪费</p>
<p>方式一：静态成员变量方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//本类中创建本类对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="comment">//提供一个全局访问方式获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式二：静态代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//声明该类变量，不赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">//使用静态代码块进行赋值</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">     	instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供获取该对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式三：枚举方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外部使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//同一个</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance1</span> <span class="operator">=</span> Singleton.INTANCE;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.INTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是极力推荐的单例实现模式，线程安全且只会创建一次。是所有单例实现中唯一一种不会被破坏的单例实现模式</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p><strong>破坏单例模式</strong></p>
<p>让定义的单例类（上面定义的除枚举方式以外的所有类，但是要在定义类的时候加上<code>implements Serializable</code>）可以创建多个对象，两种方式：序列化和反射</p>
<p>序列化：</p>
<p>序列化读取到的对象是原来对象的拷贝</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//不同</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance1</span> <span class="operator">=</span> readObject2File();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> readObject2File();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向文件读取数据（对象）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">readObject2File</span><span class="params">()</span> <span class="keyword">throw</span> Exception&#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;path&quot;</span>));</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> (Singleton) ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//向文件写数据（对象）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeObject2File</span><span class="params">()</span> <span class="keyword">throw</span> Exception&#123;</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;path&quot;</span>));</span><br><span class="line">        oos.wirteObject(instance);</span><br><span class="line">        oos.close;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//获取字节码对象</span></span><br><span class="line">        Class clazz= Singleton.class;</span><br><span class="line">        <span class="comment">//获取无参构造方法对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">//取消访问检查</span></span><br><span class="line">        cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//获取的对象不同</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance1</span> <span class="operator">=</span> (Singleton) cons.newInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> (Singleton) cons.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方法</strong></p>
<p><strong>序列化反序列化的解决</strong></p>
<p>在Singleton类中添加<code>readResolve()</code>方法，在序列化和反序列化时被反射调用，如果定义了这个方法就返回方法值，没有定义就返回new的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//由内部类创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供一个全局访问方式获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反序列时会自动调用，直接返回该方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">readResolve</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反序列化过程：</p>
<ol>
<li>获取序列化类</li>
<li>判断对象能否被实例化，可以则进行实例化，此时进行第一次实例化对象暂称为obj</li>
<li>通过反射寻找该类的<code>readResolve()</code>方法，没有则直接返回obj（反序列化破坏单例模式的根本原因）</li>
<li>如果有<code>readResolve()</code>，通过<code>invokeReadResolve(Object obj)</code>调用<code>readResolve()</code>获取对象实例赋值给第二个实例化对象称为rep，此时如果单例对象被实例化过就指向之前被实例化的单例对象，没有则指向null</li>
<li>第二个实例化对象rep与obj比较，因为obj是反射创建，不相等，则将rep的实例赋值给obj，返回obj</li>
</ol>
<p>总结：当我们通过反序列化<code>readObject()</code>方法获取对象时会去寻找<code>readResolve()</code>方法，如果该方法不存在则直接返回新对象，如果该方法存在则按该方法的内容返回对象，以确保<strong>如果我们之前实例化了单例对象，就返回该对象</strong>。<strong>如果我们之前没有实例化单例对象，则会返回null</strong>。</p>
<p><strong>反射方式的解决</strong></p>
<p>思路是在构造方法中统计实例化次数，超过一次就抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//反射化破解单例需要添加的解决方案</span></span><br><span class="line">        <span class="comment">//构造方法中判断是否第一次创建，不是第一次就抛异常</span></span><br><span class="line">        <span class="comment">//这里新加了属性flag判断，其他的可以判断instance是否为null</span></span><br><span class="line">        <span class="comment">//多线程考虑线程安全</span></span><br><span class="line">        <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由内部类创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供一个全局访问方式获取实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JDK中的源码案例"><a href="#JDK中的源码案例" class="headerlink" title="JDK中的源码案例"></a>JDK中的源码案例</h4><p>Runtime类(饿汉模式)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.reflect.CallerSensitive;</span><br><span class="line"><span class="keyword">import</span> sun.reflect.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Runtime类，里面可以获得应用运行时的一些状态（主要包括使用的内存和cpu个数）和在应用运行时执行一些操作（程序退出、执行gc、设置退出时的钩子函数）。</span></span><br><span class="line"><span class="comment"> * 用到了单例模式：确保一个类最多只有一个实例，并提供一个全局访问点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Runtime</span> <span class="variable">currentRuntime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runtime</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用了设计模式中的单例模式饿汉式(线程安全)</span></span><br><span class="line"><span class="comment">     * 返回与当前应用程序相关的java运行时对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title function_">getRuntime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造函数，单例模式的条件，返回与当前应用程序相关的java运行时对象,不支持new的Runtime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Runtime</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//后面还有很多功能的方法，暂时可以忽略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-1-2简单工厂模式"><a href="#1-1-2简单工厂模式" class="headerlink" title="1.1.2简单工厂模式"></a>1.1.2简单工厂模式</h3><p>不是经典设计模式之一，比较像一种编程习惯。</p>
<p><img src="https://img-blog.csdnimg.cn/b409264fc2f5434bb00749fb7c0f47be.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiJ5Zub5pyI5LqL5YWr5Lmd5pyI5p6c,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul>
<li>抽象产品：定义产品规范，主要特性和功能</li>
<li>具体产品：实现或者继承抽象产品的子类</li>
<li>具体工厂：提供创建产品的方法，调用者通过该方法来获取产品</li>
</ul>
<p>想要获取产品，通过创建工厂使用方法获取产品</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>封装创建对象的过程，可以通过参数直接获取对象，把对象创建的业务逻辑层分开，避免了修改客户代码</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>工厂和具体产品之间存在耦合，增加新产品需要修改工厂类代码，违背了开闭原则</p>
<h4 id="扩展-静态工厂"><a href="#扩展-静态工厂" class="headerlink" title="扩展-静态工厂"></a>扩展-静态工厂</h4><p>将工厂类中创建对象的功能定义为静态，也不属于23种设计模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCoffeeFactory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Coffee <span class="title function_">createCoffee</span><span class="params">(String type)</span>&#123;</span><br><span class="line">     	<span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;americano&quot;</span>.equals(type))&#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">AmericanoCoffee</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;latte&quot;</span>.equals(type))&#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-3工厂方法模式（重要）"><a href="#1-1-3工厂方法模式（重要）" class="headerlink" title="1.1.3工厂方法模式（重要）"></a>1.1.3工厂方法模式（重要）</h3><p>改进简单工厂方法，完全遵守开闭原则</p>
<p><img src="https://img-blog.csdnimg.cn/0d14d3d928684d53b428fe67bb3d228a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiJ5Zub5pyI5LqL5YWr5Lmd5pyI5p6c,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类</p>
<h4 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h4><ul>
<li>抽象工厂：提供创建产品的接口，调用者通过它访问具体工厂的方法来创建产品</li>
<li>具体工厂：主要实现抽象工厂的抽象方法，完成具体产品的创建</li>
<li>抽象产品：定义了产品的规范，描述了产品的主要特性和功能</li>
<li>具体产品：实现了抽象产品角色所定义的接口，由具体工厂来创建，与具体工厂之间<strong>一一对应</strong></li>
</ul>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>用户只需要知道具体工厂就可以得到需要的产品，不需要知道产品的创建过程</li>
<li>增加新产品只需要添加具体的产品类和对应的具体工厂类，无需对原工厂进行任何修改</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>每增加一个产品就需要增加一个具体产品类和一个对应的具体工厂类，增加了系统的复杂度</li>
</ul>
<h3 id="1-1-4抽象工厂模式"><a href="#1-1-4抽象工厂模式" class="headerlink" title="1.1.4抽象工厂模式"></a>1.1.4抽象工厂模式</h3><p>为访问类提供一个创建一组相关或者相互依赖对象的接口，且访问类无需指定所要的产品的具体类九能得到同族的不同等级的产品模式结构。是工厂方法模式的升级版，抽象工厂模式可以生产多类产品。</p>
<p><img src="https://img-blog.csdnimg.cn/ce80edf346a045e3963d5dc0c1ad584a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiJ5Zub5pyI5LqL5YWr5Lmd5pyI5p6c,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h4><ul>
<li>抽象工厂：提供创建产品的接口，包含多个创建产品的方法，可以创建多个不同类的产品</li>
<li>具体工厂：实现抽象工厂的多个抽象方法，完成具体产品的创建</li>
<li>抽象产品：定义了产品规范，描述产品主要特性和功能，抽象工厂有多个抽象产品</li>
<li>具体产品：实现抽象产品角色定义的接口，和具体工厂之间是多对一的关系（多个具体产品对应一个具体工厂</li>
</ul>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>多类产品对象被设计成一起工作，还能保证客户端始终只使用同一个对象</p>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>产品族需要增加一个新类产品，所有工厂类都需要修改</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>需要创建的对象是一系列相互关联或者相互依赖的产品</li>
<li>系统中有多个产品族，但是每次只使用某一个产品族（同一族含多个不同类产品）</li>
<li>系统提供了产品的类库，所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构</li>
</ul>
<p>（类似于某一些不同类产品要用就用同一品牌的）</p>
<h4 id="工厂模式扩展"><a href="#工厂模式扩展" class="headerlink" title="工厂模式扩展"></a>工厂模式扩展</h4><p>简单工厂+配置文件解除耦合：</p>
<p>在工厂类中加载配置文件中的全类名，并创建对象进行存储，如果客户端需要对象，直接获取即可。参考之前静态工厂方法，里面直接根据名字获取具体产品即可。具体产品可以在配置文件直接写全类名，后续更新也直接在配置文件更新即可。</p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p><code>Collection.iterator()</code></p>
<p><img src="https://img-blog.csdnimg.cn/44861fcc633946ab9026e3cc4499304d.png" alt="img"></p>
<h3 id="1-1-5原型模式"><a href="#1-1-5原型模式" class="headerlink" title="1.1.5原型模式"></a>1.1.5原型模式</h3><p>用一个已经创建的实例作为原型，通过复制原型对象创建一个和原型对象相同的新对象</p>
<p><img src="https://img-blog.csdnimg.cn/4c26d809ed124b2da3e00b2409a10d9c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiJ5Zub5pyI5LqL5YWr5Lmd5pyI5p6c,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h4><ul>
<li>抽象原型类：规定了具体原型对象必须实现的<code>clone()</code>方法</li>
<li>具体原型类：实现抽象原型类的<code>clone()</code>方法，是可以被复制的对象</li>
<li>访问类：使用具体原型类中的<code>clone()</code>方法来复制新对象</li>
</ul>
<p>访问过程：新建一个具体实现类的实例，然后使用clone创建一个新对象</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul>
<li><p>浅克隆：clone创建的新对象，属性和原来对象完全相同，非基本类型属性仍指向原对象的内存地址</p>
</li>
<li><p>深克隆：新对象引用的对象也会被克隆，不指向原有对象的地址(可以使用对象流实现，序列化反序列化可以实现深拷贝)</p>
</li>
</ul>
<p>Java中Object类提供了<code>clone()</code>方法实现浅克隆Cloneable接口为抽象原型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体原型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Realizetype</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span></span><br><span class="line">&#123;</span><br><span class="line">    Realizetype()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体原型创建成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Realizetype <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体原型复制成功！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (Realizetype) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原型模式的测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrototypeTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line">    &#123;</span><br><span class="line">        Realizetype obj1=<span class="keyword">new</span> <span class="title class_">Realizetype</span>();</span><br><span class="line">        Realizetype obj2=(Realizetype)obj1.clone();</span><br><span class="line">        System.out.println(<span class="string">&quot;obj1==obj2?&quot;</span>+(obj1==obj2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-6建造者模式"><a href="#1-1-6建造者模式" class="headerlink" title="1.1.6建造者模式"></a>1.1.6建造者模式</h3><p>将一个复杂对象（比如主机）构建（零件）与表示（主机）分离，使同样的构建过程（装配）可以创建不同表示</p>
<p><img src="https://img-blog.csdnimg.cn/f246f125985a4af8a67e9e26bb79fb4b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiJ5Zub5pyI5LqL5YWr5Lmd5pyI5p6c,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h4><ul>
<li>抽象建造者类：接口规定要实现复杂对象的哪些部分的创建，不涉及具体对象部件的创建</li>
<li>具体建造者类：实现抽象建造者类接口，完成复杂产品的各个部件的具体创建方法，构建完成后提供产品实例</li>
<li>产品类：要创建的复杂对象</li>
<li>指挥者类：调用具体建造者来创建复杂对象各个部分，在指导者中不涉及具体产品信息，只负责保证对象各部分完整创建或者按照某种顺序创建</li>
</ul>
<h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ul>
<li>封装性好，建造者模式场景中一般产品类和建造者类都是稳定的，将主要业务逻辑封装在指挥者类对整体可以取得比较好的稳定性</li>
<li>客户端不必知道产品内部组成细节，将产品本身和创建过程解耦，相同的创建过程因此可以创建不同的对象</li>
<li>可以更精细控制产品创建，将步骤分解在不同方法，使创建过程更清晰，更方便程序员控制</li>
<li>容易扩展，新的需求实现新的建造者类就可以完成，基本上不用修改之前测试通过的代码，符合开闭原则</li>
</ul>
<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><p>创建的产品一般有较多共同点，组成部分相似，如果产品之间差异很大则不适合使用</p>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>创建的复杂对象各个部分经常面临变化，但是组合的算法相对稳定</p>
<ul>
<li>创建的对象复杂，有多个部分，部件面临复杂变化，但是构件间的建造顺序稳定</li>
<li>创建复杂对象的算法独立于对象的组成部分和他们的装配方式，即产品的构建过程和最终表示是独立的</li>
</ul>
<h4 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h4><p>当一个类构造器需要传入很多参数，创建这个类的实例，代码可读性会非常差且容易引入错误，此时可以用建造者模式进行重构</p>
<p>创建静态内部类Builder，提供每个部件的传入方法。创建实例构造方法只需要传入Builder。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重构前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String screen;</span><br><span class="line">    <span class="keyword">private</span> String memory;</span><br><span class="line">    <span class="keyword">private</span> String mainboard;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Phone</span><span class="params">(String cpu, String screen, String memory, String mainboard)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">        <span class="built_in">this</span>.screen = screen;</span><br><span class="line">        <span class="built_in">this</span>.memory = memory;</span><br><span class="line">        <span class="built_in">this</span>.mainboard = mainboard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCpu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCpu</span><span class="params">(String cpu)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getScreen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> screen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScreen</span><span class="params">(String screen)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.screen = screen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMemory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> memory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(String memory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.memory = memory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMainboard</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mainboard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMainboard</span><span class="params">(String mainboard)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mainboard = mainboard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Phone&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, screen=&#x27;&quot;</span> + screen + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, memory=&#x27;&quot;</span> + memory + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, mainboard=&#x27;&quot;</span> + mainboard + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//构建Phone对象需要传递很多参数，可读性差</span></span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>(<span class="string">&quot;intel&quot;</span>,<span class="string">&quot;三星屏幕&quot;</span>,<span class="string">&quot;金士顿&quot;</span>,<span class="string">&quot;华硕&quot;</span>);</span><br><span class="line">        System.out.println(phone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建造者模式链式重构后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String screen;</span><br><span class="line">    <span class="keyword">private</span> String memory;</span><br><span class="line">    <span class="keyword">private</span> String mainboard;</span><br><span class="line">	<span class="comment">//构造方法私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Phone</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        cpu = builder.cpu;</span><br><span class="line">        screen = builder.screen;</span><br><span class="line">        memory = builder.memory;</span><br><span class="line">        mainboard = builder.mainboard;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">        <span class="comment">//跟要创建的对象类的属性一致</span></span><br><span class="line">        <span class="keyword">private</span> String cpu;</span><br><span class="line">        <span class="keyword">private</span> String screen;</span><br><span class="line">        <span class="keyword">private</span> String memory;</span><br><span class="line">        <span class="keyword">private</span> String mainboard;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">		<span class="comment">//返回一个当前的Builder对象</span></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">cpu</span><span class="params">(String val)</span> &#123;</span><br><span class="line">            cpu = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">screen</span><span class="params">(String val)</span> &#123;</span><br><span class="line">            screen = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">memory</span><span class="params">(String val)</span> &#123;</span><br><span class="line">            memory = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">mainboard</span><span class="params">(String val)</span> &#123;</span><br><span class="line">            mainboard = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Phone <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Phone</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Phone&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, screen=&#x27;&quot;</span> + screen + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, memory=&#x27;&quot;</span> + memory + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, mainboard=&#x27;&quot;</span> + mainboard + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>.Builder()</span><br><span class="line">                .cpu(<span class="string">&quot;intel&quot;</span>)</span><br><span class="line">                .mainboard(<span class="string">&quot;华硕&quot;</span>)</span><br><span class="line">                .memory(<span class="string">&quot;金士顿&quot;</span>)</span><br><span class="line">                .screen(<span class="string">&quot;三星&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        System.out.println(phone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-2结构型模式"><a href="#1-2结构型模式" class="headerlink" title="1.2结构型模式"></a>1.2结构型模式</h2><p>描述如何将类或者对象按照某种布局组成更大的<strong>结构</strong>。分为类结构型模式和对象结构型模式，前者采用继承机制组织接口和类，后者采用组合或聚合来组合对象。因为组合或者聚合关系耦合度更低，满足合成复用原则，所以对象结构型模式更灵活。</p>
<h3 id="1-2-1代理模式（重要）"><a href="#1-2-1代理模式（重要）" class="headerlink" title="1.2.1代理模式（重要）"></a>1.2.1代理模式（重要）</h3><p>某些原因需要给某对象提供一个代理以控制该对象的访问。此时访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<p>根据代理类生成时机可以分为<strong>静态代理</strong>（代理类在编译期就生成）和<strong>动态代理</strong>（在Java运行时动态生成），动态代理又可以分为JDK代理和CGLib代理。</p>
<p><img src="https://img-blog.csdnimg.cn/3c33214ec2c24f5fa0c9d6bc7f9f5bbd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiJ5Zub5pyI5LqL5YWr5Lmd5pyI5p6c,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="结构-5"><a href="#结构-5" class="headerlink" title="结构"></a>结构</h4><p>三种角色：</p>
<ul>
<li>抽象主题（Subject）类：通过接口或者抽象类声明的真实主题和代理对象实现的业务方法</li>
<li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象</li>
<li>代理（Proxy）类：提供了与真实主题相同的接口，内部含有对真实主题的引用，可以访问，控制或者扩展真实主题的功能</li>
</ul>
<p>代理可以代理多种真实主题，真实主题要符合抽象主题的规范</p>
<h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>类似火车站和代售点，火车站是目标对象，代售点是代理对象</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230409204145550.png" alt="image-20230409204145550"></p>
<p>代售点相当于对火车站类的一个增强，在里面可以调用火车站类的方法同时还能进行业务的扩展。</p>
<p>（只是注入火车站的依赖，而且这里如果两个类不实现同一接口，照样能增强另一个类的方法，只是设计模式讲究降低耦合，我们在一个类中，想调用其它类的方法，拿到其对象就能”对象.方法”了，我们在声明个方法套一下这个调用，就是对这个方法做了增强，它们实现同一个接口，一个目的是将类型向上抽象，再一个目的是由接口的规范统一两者的动作（方法）。）</p>
<h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>Java中提供了一个动态代理类Proxy，与上述静态代理不同，而是<strong>提供了一个创建代理对象的静态方法</strong>(<code>newProxyInstance()</code>)来获取代理对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用JDK的动态代理类的静态方法创建代理对象</span></span><br><span class="line"><span class="comment">//返回使用抽象主题类(SellTickets)接收，强转</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span>&#123;</span><br><span class="line">    <span class="comment">//引入真实主题类(需要被代理的目标对象)</span></span><br><span class="line"> 	<span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> SellTickets <span class="title function_">getProxyObject</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Proxy.newProxyInstance()的参数</span></span><br><span class="line"><span class="comment">            ClassLoader Loader : 类加载器，用于加载代理类。可以通过目标对象获取类加载器</span></span><br><span class="line"><span class="comment">            Class&lt;?&gt;[] interface : 代理类实现的接口的字节码对象,这里可以通过目标对象往上找实现的接口</span></span><br><span class="line"><span class="comment">            InvocationHandler h : 代理对象的调用处理程序,根本上调用代理对象是通过其invoke方法调用的</span></span><br><span class="line"><span class="comment">		*/</span>			</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxyObject</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(</span><br><span class="line">            station.getClass().getClassLoader(),</span><br><span class="line">            station.getClass().getInterfaces(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>()&#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                	参数中</span></span><br><span class="line"><span class="comment">                	proxy：代理类的实例，代理对象，和proxyObject是同一个，invoke中基本不用</span></span><br><span class="line"><span class="comment">                	method：对接口中的方法进行封装的method对象</span></span><br><span class="line"><span class="comment">                	args：方法的参数</span></span><br><span class="line"><span class="comment">                	返回值：方法的返回值</span></span><br><span class="line"><span class="comment">                	本质是反射</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> method.invoke(sation, args);</span><br><span class="line">					<span class="keyword">return</span> obj;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里的<code>ProxyFactory</code>并非我们的代理类，代理类($Proxy0)是在程序运行过程中在内存动态生成的类(继承Proxy，实现抽象主题类的接口（SellTickets）)</p>
<p>代理类将我们提供的匿名内部类对象(<code>InvocationHandler()</code>)传递给了父类</p>
<p><strong>执行流程</strong></p>
<ol>
<li>在测试类中通过代理对象调用sell()方法</li>
<li>根据多态特性，执行的是代理类的sell()方法</li>
<li>代理类的sell()又调用了InvocationHandler接口的子实现类对象的invoke方法</li>
<li>invoke方法通过反射执行了真实对象所属类中的sell()方法</li>
</ol>
<h4 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h4><p>如果没有定义抽象主题接口，只定义了代理对象类，显然无法使用JDK代理了，因为JDK代理要求必须定义接口对接口进行代理</p>
<p>CGLib是第三方提供的包，需要提前导入jar包的坐标</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">getProxyObject</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//创建Enhancer对象，类似于JDK代理中的Proxy类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//设置父类的字节码对象</span></span><br><span class="line">        enhancer.setSuperclass(TrainStation.class);</span><br><span class="line">        <span class="comment">//设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">proxyObject</span> <span class="operator">=</span> (TrainStation) enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> proxyObject;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        <span class="comment">//要调用目标对象的方法</span></span><br><span class="line">        method.invoke(station, objects)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代理的比较"><a href="#代理的比较" class="headerlink" title="代理的比较"></a>代理的比较</h4><ul>
<li><p>JDK动态代理与CGLib动态代理</p>
<p>CGLib底层采用ASM字节码生成框架，不能对声明为final的类或者方法进行代理。在JDK1.8之后JDK动态代理效率高于CGLib代理。因此选择上看有没有接口，代理对象有实现接口就用JDK动态代理，没有就用CGLib代理</p>
</li>
<li><p>动态代理和静态代理</p>
<p>动态代理最大的好处是接口中声明的所有方法都被转移到调用处理器的一个集中方法中处理，接口方法数量多时候更灵活不需要像静态代理一样进行一个个中转。</p>
<p>如果接口增加一个方法，静态代理模式所有实现类需要实现，代理类也需要实现，增加了代码复杂度。</p>
</li>
</ul>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p>
<ul>
<li>代理模式在客户端和目标对象之间起中介和保护对象的作用</li>
<li>代理对象可以扩展目标对象功能</li>
<li>代理模式可以将客户端和目标对象分离，降低耦合度</li>
</ul>
<p>缺点：</p>
<ul>
<li>增加了系统复杂度</li>
</ul>
<h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li><p>远程代理</p>
<p>本地服务通过网络请求远程服务。实现网络通信，我们可以将网络通信部分隐藏，给本地服务一个接口，通过接口访问远程服务提供的功能，不必关心通信部分</p>
</li>
<li><p>防火墙代理</p>
<p>浏览器配置代理功能，防火墙会将请求转给互联网，互联网响应时代理服务器再转给浏览器</p>
</li>
<li><p>保护代理</p>
<p>控制对一个对象的访问，如果需要可以给不同用户提供不同级别权限</p>
</li>
</ul>
<h3 id="1-2-2适配器模式"><a href="#1-2-2适配器模式" class="headerlink" title="1.2.2适配器模式"></a>1.2.2适配器模式</h3><p>将一个类的接口转换成客户希望的另一个接口，使原本由于接口不兼容不能一起工作的类可以一起工作</p>
<p>分为类适配器模式（继承实现）和对象适配器模式（聚合组合实现），前者类之间耦合度比后者高且要求程序员了解现有组件库中相关组件的内部结构，应用相对较少。</p>
<p>还有一种接口适配器模式，当不希望实现一个接口所有方法时，创建一个抽象类Adapter，实现所有方法，而我们此时只需要继承抽象类。</p>
<h4 id="结构-6"><a href="#结构-6" class="headerlink" title="结构"></a>结构</h4><ul>
<li>目标接口：当前业务期待的接口，也可以是抽象类或接口</li>
<li>适配者类：被 访问和适配的现存组件库中的组件接口</li>
<li>适配器类：转换器，通过继承或者引用适配者对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者</li>
</ul>
<h4 id="类适配器模式实现"><a href="#类适配器模式实现" class="headerlink" title="类适配器模式实现"></a>类适配器模式实现</h4><p>定义一个适配器类实现当前业务接口，同时又继承现有组件库中已经存在的组件</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230410191438214.png" alt="image-20230410191438214"></p>
<p>类适配器模式违背了合成复用原则，只有客户类有接口规范的情况下可用</p>
<h4 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h4><p>对象适配器模式可以采用将现有组件库中已经实现的组件引入适配器类，同时实现当前系统的业务接口</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230410192936256.png" alt="image-20230410192936256"></p>
<p>把接口作为成员适配者类，使用构造方法组合在适配器类中，同时继承目标接口。使用成员方法实现业务方法。</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>以前开发的系统存在满足新系统功能需求的类，但是新系统接口不一致</li>
<li>使用第三方提供的组件，但是组件接口定义和自己要求的接口定义不同</li>
</ul>
<h4 id="JDK源码案例"><a href="#JDK源码案例" class="headerlink" title="JDK源码案例"></a>JDK源码案例</h4><p>Reader（字符流）， InputStream（字节流）的适配使用的就是InputStreamReader（封装了适配器StreamDecoder）。继承Reader对抽象未实现方法给出实现</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230410193815964.png" alt="image-20230410193815964"></p>
<h3 id="1-2-3装饰者模式（重要）"><a href="#1-2-3装饰者模式（重要）" class="headerlink" title="1.2.3装饰者模式（重要）"></a>1.2.3装饰者模式（重要）</h3><p>快餐店例子：</p>
<p>在新加配料或者快餐品类需要定义很多子类，出现类爆炸</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230410194257822.png" alt="image-20230410194257822"></p>
<p>在不改变现有对象结构的情况下动态给对象增加一些职责的模式</p>
<h4 id="结构-7"><a href="#结构-7" class="headerlink" title="结构"></a>结构</h4><ul>
<li>抽象构件角色：定义一个抽象接口来规范准备接收附加责任的对象</li>
<li>具体构件角色：实现抽象构件，通过装饰角色为其添加一些职责</li>
<li>抽象装饰角色：继承或实现抽象构件，并<strong>聚合包含具体构件</strong>的案例，可以通过其子类扩展具体构件功能</li>
<li>具体装饰角色：实现抽象装饰的相关方法，并给具体构件对象添加附加责任</li>
</ul>
<p>装饰者模式改进后：</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230410194710559.png" alt="image-20230410194710559"></p>
<h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><ul>
<li>比继承更灵活的扩展功能，使用更方便，可以组合不同装饰者对象获取具有不同行为状态的多样化结果，完美遵循开闭原则。继承是静态附加责任，装饰者是动态附加</li>
<li>装饰类和被装饰类可以独立发展，不会相互耦合，是继承的一个替代模式，可以动态实现一个实现类的功能</li>
</ul>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li><p>不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时</p>
<p>不能使用继承的情况主要有：</p>
<ul>
<li>系统存在大量独立扩展，为支持每一种组合将产生大量子类</li>
<li>类不能被继承（比如final类）</li>
</ul>
</li>
<li><p>在不影响其他对象情况下，动态透明的方式给单个对象添加职责</p>
</li>
<li><p>对象的功能要求可以动态添加也可以再撤销</p>
</li>
</ul>
<h4 id="源码案例"><a href="#源码案例" class="headerlink" title="源码案例"></a>源码案例</h4><p>IO流中的包装类都使用了装饰者模式。BufferedInputStream，BufferedOutputStream，BufferedReader，BufferedWriter</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230410200201981.png" alt="image-20230410200201981"></p>
<h4 id="静态代理和装饰者的区别"><a href="#静态代理和装饰者的区别" class="headerlink" title="静态代理和装饰者的区别"></a>静态代理和装饰者的区别</h4><ul>
<li><p>相同</p>
<ul>
<li>都实现与目标类相同的业务接口</li>
<li>在两个类中都要声明目标对象</li>
<li>都可以在不改变目标类的前提下增强目标方法</li>
</ul>
</li>
<li><p>不同</p>
<ul>
<li><p>目的不同</p>
<p>装饰者为了增强目标对象</p>
<p>静态代理为了保护和隐藏目标对象</p>
</li>
<li><p>获取目标对象构建的地方不同</p>
<p>装饰者由外界传递，可以使用构造方法传递</p>
<p>静态代理由代理类内部创建以此来隐藏目标对象</p>
</li>
</ul>
</li>
</ul>
<h3 id="1-2-4桥接模式"><a href="#1-2-4桥接模式" class="headerlink" title="1.2.4桥接模式"></a>1.2.4桥接模式</h3><p>场景：不同几何形状分别有多种不同颜色，使用继承会出现类爆炸</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230411191150873.png" alt="image-20230411191150873"></p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>将抽象与实现分离，使它们可以独立变化，是用组合关系替代继承关系来实现的，降低两个可变维度（比如形状和颜色）的耦合度</p>
<h4 id="结构-8"><a href="#结构-8" class="headerlink" title="结构"></a>结构</h4><ul>
<li>抽象化角色：定义抽象类，包含一个对实现化对象的引用</li>
<li>扩展抽象化角色：抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法</li>
<li>实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用</li>
<li>具体实现化角色：给出实现化角色接口的具体实现</li>
</ul>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230411192011870.png" alt="image-20230411192011870"></p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li><p>桥接模式提高了系统的可扩容性，在两个变化维度中任意扩展一个维度，都不需要修改原有的系统</p>
<p>新的操作系统，或者新的视频文件格式，只需要去再定义一个类实现接口即可</p>
</li>
<li><p>实现细节对客户透明</p>
</li>
</ul>
<h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>当一个类存在两个独立变化的维度，都可能需要进行拓展</li>
<li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数剧增时</li>
<li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使他们在抽象层建立一个关联关系</li>
</ul>
<h3 id="1-2-5外观模式"><a href="#1-2-5外观模式" class="headerlink" title="1.2.5外观模式"></a>1.2.5外观模式</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>又名门面模式，通过为多个复杂的子系统提供一个一致的接口，而使子系统更加容易被访问。模式对外有一个统一的接口，外部应用程序不用关心内部子系统具体细节，会大大降低应用程序的复杂度，提高程序可维护性</p>
<p>是“迪米特法则”的经典应用</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230411194005997.png" alt="image-20230411194005997"></p>
<h4 id="结构-9"><a href="#结构-9" class="headerlink" title="结构"></a>结构</h4><ul>
<li>外观角色：为多个子系统对外提供一个共同的接口</li>
<li>子系统角色：实现系统的部分功能，客户可以通过外观角色访问它</li>
</ul>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230411194132833.png" alt="image-20230411194132833"></p>
<h4 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h4><ul>
<li>降低子系统与客户端之间的耦合度，使子系统的变化不会影响调用它的客户类</li>
<li>对客户端屏蔽了子系统组件，减少了客户处理的对象数目，使子系统使用起来更加容易</li>
</ul>
<h4 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>不符合开闭原则，修改很麻烦</li>
</ul>
<h4 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>当分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系</li>
<li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问</li>
<li>当客户端与多个子系统之间存在很大联系时，引入外观模式可以将它们分离，从而提高子系统的独立性和可移植性</li>
</ul>
<h4 id="源码案例-1"><a href="#源码案例-1" class="headerlink" title="源码案例"></a>源码案例</h4><p>Tomcat作为web容器，接收浏览器发送的请求，tomcat会将请求封装成ServletRequest对象，是一个接口，其下还有子接口及其子实现类</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230411200733169.png" alt="image-20230411200733169"></p>
<h3 id="1-2-6组合模式"><a href="#1-2-6组合模式" class="headerlink" title="1.2.6组合模式"></a>1.2.6组合模式</h3><p>类似文件夹，菜单等的结构。又名部分整体结构，用于把一组相似的对象作为单一对象。依据树型结构组合对象，用来表示部分和整体层次，创建了对象组的树型结构。</p>
<h4 id="结构-10"><a href="#结构-10" class="headerlink" title="结构"></a>结构</h4><ul>
<li>抽象根节点：定义系统各个层次对象的共有方法和属性，可以预先定义一些默认的行为和属性</li>
<li>树枝节点：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树型结构</li>
<li>叶子节点：叶子节点对象，其下再无分支，是系统层次遍历的最小单位</li>
</ul>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>根据抽象构建类的定义形式可以分为</p>
<ul>
<li><p>透明组合模式</p>
<p>抽象根节点声明了所有用于成员管理的方法，比如add，remove，getchild等，可以确保构件类都有相同的接口，是组合模式的标准形式。</p>
<p>但是不够安全，因为叶子节点的区别，无法添加删除子节点，编译阶段不会出错但是运行阶段如果被调用就会出错（如果不提供错误处理）</p>
</li>
<li><p>安全组合模式</p>
<p>抽象构件角色中没声明任何用于管理成员对象的方法，而是在树枝节点类中声明并实现，缺点是不够透明，叶子构件和容器构件具有不同方法，容器构件那些用于管理成员对象的方法没有在抽象类定义。客户端不能完全针对抽象编程，必须了解并有区别对待叶子和容器。</p>
</li>
</ul>
<h4 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h4><ul>
<li>可以清晰定义分层次复杂对象，表示对象的全部或者部分层次，让客户端忽略层次差异，方便对整个层次结构进行控制</li>
<li>客户端可以一致调用组合结构或者单个对象，不必关心处理的是单个对象还是组合结构，简化代码</li>
<li>在组合模式中新增树枝节点和叶子节点都很方便，无需对现有类库进行修改，符合“开闭原则”</li>
<li>给树型结构的面向对象实现提供一种灵活解决方案，可以形成复杂树型结构但是控制却很简单</li>
</ul>
<h4 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h4><p>出现树形结构的地方，比如文件目录显示，多级目录等</p>
<h3 id="1-2-7享元模式"><a href="#1-2-7享元模式" class="headerlink" title="1.2.7享元模式"></a>1.2.7享元模式</h3><p>使用共享技术来有效支持大量细粒度对象的复用，通过共享已经存在的对象大幅减少需要创建对象的数量，避免大量相似对象的开销，提高系统资源利用率。</p>
<p>常用在池技术，String常量池，线程池，数据库连接池，缓冲池</p>
<h4 id="结构-11"><a href="#结构-11" class="headerlink" title="结构"></a>结构</h4><p>享元（Flyweight）模式存在两种状态</p>
<ol>
<li>内部状态，不会随着环境改变的可共享部分</li>
<li>外部状态，随着环境改变而改变的不可共享部分。享元模式实现就是要区分应用的这两种状态，并将外部状态外部化</li>
</ol>
<p>主要角色：</p>
<ul>
<li>抽象享元角色：通常是接口或者抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）</li>
<li>具体享元角色：实现抽象享元类，称为享元对象。在具体享元类中为内部状态提供存储空间。通常可以结合单例模式来设计享元类，为每一个具体享元类提供唯一的享元对象</li>
<li>非享元角色：并不是所有抽象享元的子类都需要被共享，不能被共享的子类可以设计为非共享具体享元类。当需要一个非共享具体享元类的对象时可以直接通过实例化创建</li>
<li>享元工厂角色：负责创建和管理享元角色，当客户对象请求一个享元对象时，享元工厂检查系统中是否存在符合要求的享元对象，存在则提供给客户，不存在则创建一个新享元</li>
</ul>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230412202647866.png" alt="image-20230412202647866"></p>
<p>可以将形状视为内部状态，颜色等属性视为外部状态。可以使用享元模式来实现</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230412202746406.png" alt="image-20230412202746406"></p>
<h4 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h4><ul>
<li>极大减少内存中相似或者相同对象数量，节约系统资源，提高系统性能</li>
<li>享元模式的外部状态相对独立，且不影响内部状态</li>
</ul>
<h4 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>为了使对象可以共享，需要将享元对象部分状态外部化，分离内部状态和外部状态使程序逻辑复杂</li>
</ul>
<h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>一个系统有大量相同或者相似对象，造成内存大量耗费</li>
<li>对象大部分状态都可以外部化，可以将这些外部状态传入对象</li>
<li>使用享元模式时需要维护一个存储享元对象的享元池，需要耗费一定系统资源，因此在需要多次重复使用享元对象时才值得使用</li>
</ul>
<h4 id="JKD源码案例"><a href="#JKD源码案例" class="headerlink" title="JKD源码案例"></a>JKD源码案例</h4><p>Integer类（默认缓存-128-127以内的值，不会新建实例）</p>
<h2 id="1-3行为型模式"><a href="#1-3行为型模式" class="headerlink" title="1.3行为型模式"></a>1.3行为型模式</h2><p>用于描述程序运行时复杂的流程控制，描述多个类或者对象之间如何写作完成任务，设计算法和对象间职责的分配。</p>
<p>可以进一步分为</p>
<ul>
<li><p>类行为模式，采用继承机制在类间分派行为，以下仅模板方法和解释器模式</p>
</li>
<li><p>对象行为模式：使用组合或者聚合在对象间分配行为，因为组合耦合度更低，符合合成复用原则，这一种具有更大的灵活性</p>
</li>
</ul>
<h3 id="1-3-1模板方式模式（类行为）"><a href="#1-3-1模板方式模式（类行为）" class="headerlink" title="1.3.1模板方式模式（类行为）"></a>1.3.1模板方式模式（类行为）</h3><p>设计一个系统知道了算法的关键步骤以及顺序，但是某些具体的实现步骤未知，可能需要当时环境来决定。</p>
<p>例如银行流程，取号，排队，办理业务，对服务评价的流程每个客户都是一样，但是办理业务因人而异，可以延迟到子类中实现</p>
<h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>定义一个操作中的算法股价，将算法的一些步骤延迟到子类中，使子类可以不改变算法结构的情况下重新定义该算法的某些特定步骤。</p>
<h4 id="结构-12"><a href="#结构-12" class="headerlink" title="结构"></a>结构</h4><ul>
<li>抽象类：给一个算法轮廓和骨架，由一个模板方法和若干个基本方法构成<ul>
<li>模板方法（final声明不能更改）：定义了算法骨架，按某种顺序调用其包含的基本方法</li>
<li>基本方法：实现算法各个步骤的方法，是组成部分<ul>
<li>抽象方法（类似于办理业务）：由抽象类声明，具体子类实现</li>
<li>具体方法（类似固定的其他三个方法）：抽象类或具体类声明并实现，子类可以进行覆盖或者直接继承</li>
<li>钩子方法：抽象类中已实现，包括用于判断的逻辑方法和需要子类重写的空方法</li>
</ul>
</li>
</ul>
</li>
<li>具体子类：实现抽象类定义的抽象方法和钩子方法，是一个顶级逻辑的组成部分</li>
</ul>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230413204145811.png" alt="image-20230413204145811"></p>
<h4 id="优点-8"><a href="#优点-8" class="headerlink" title="优点"></a>优点</h4><ul>
<li>提高代码复用性，相同的代码放在父类抽象中</li>
<li>实现反向控制，通过父类调用子类操作，通过子类的具体实现拓展不同的行为，并符合开闭原则</li>
</ul>
<h4 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>对每个不同的实现都需要定义一个子类，导致类个数增加，系统庞大，设计抽象</li>
<li>父类的抽象方法由子类实现，子类的执行结果也会影响父类结果，反向控制结构提高代码的阅读难度</li>
</ul>
<h4 id="适用场景-4"><a href="#适用场景-4" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>算法步骤很固定，个别部分易变，可以将易变部分抽象出来供子类实现</li>
<li>需要通过子类来决定父类算法某个步骤是否执行，实现子类对父类的反转控制</li>
</ul>
<h4 id="JDK源码案例-1"><a href="#JDK源码案例-1" class="headerlink" title="JDK源码案例"></a>JDK源码案例</h4><p>InputStream类实现就是模板方式，在InputStream类中定义了多个read方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InputStream</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span> &#123;</span><br><span class="line">    <span class="comment">//抽象方法，要求子类必须重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> read(b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || len &gt; b.length - off) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> read(); <span class="comment">//调用了无参的read方法，该方法是每次读取一个字节数据</span></span><br><span class="line">        <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        b[off] = (<span class="type">byte</span>)c;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; len ; i++) &#123;</span><br><span class="line">                c = read();</span><br><span class="line">                <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                b[off + i] = (<span class="type">byte</span>)c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ee) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-2策略模式"><a href="#1-3-2策略模式" class="headerlink" title="1.3.2策略模式"></a>1.3.2策略模式</h3><p>情景：去一个目的地可以选择任意交通工具</p>
<p>定义了一系列算法，并把每个算法封装起来，使可以相互替换，且算法的变化不会影响使用算法的客户。属于对象行为模式，通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p>
<h4 id="结构-13"><a href="#结构-13" class="headerlink" title="结构"></a>结构</h4><ul>
<li>抽象策略类：通常由接口或者抽象类实现，给所有具体策略类所需的接口</li>
<li>具体策略类：实现抽象策略定义，提供具体的算法实现或行为</li>
<li>环境类：持有一个策略类的引用，最终给客户端调用</li>
</ul>
<h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230417194026979.png" alt="image-20230417194026979"></p>
<h4 id="优点-9"><a href="#优点-9" class="headerlink" title="优点"></a>优点</h4><ul>
<li>策略类之间可以自由切换</li>
<li>易于拓展，新增不需要修改原本代码</li>
<li>避免使用多重选择语句(if else)</li>
</ul>
<h4 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>客户端必须知道所有策略类，并自己决定使用</li>
<li>策略模式将造成产生很多策略类，可以使用享元模式一定程度上减少对象数量</li>
</ul>
<h4 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>一个系统需要动态在几种算法中选择一种时</li>
<li>一个类定义了多种行为，且这些行为以多个条件语句的形式出现，可以将每个条件分支移入各自的策略类</li>
<li>系统各算法彼此独立，且对客户隐藏具体算法实现细节</li>
<li>系统要求使用算法的客户不应该知道其具体操作的数据</li>
</ul>
<h4 id="JDK源码例子"><a href="#JDK源码例子" class="headerlink" title="JDK源码例子"></a>JDK源码例子</h4><p><code>Comparator</code>，在Arrays类中有一个<code>sort()</code>方法、</p>
<p>其中Arrays就是一个环境角色类，sort方法可以传一个新策略让Arrays根据这个策略排序</p>
<h3 id="1-3-3命令模式"><a href="#1-3-3命令模式" class="headerlink" title="1.3.3命令模式"></a>1.3.3命令模式</h3><p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储，传递，调用，增加与管理</p>
<h4 id="结构-14"><a href="#结构-14" class="headerlink" title="结构"></a>结构</h4><ul>
<li>抽象命令类角色：定义命令的接口，声明执行的方法</li>
<li>具体命令角色：具体的命令，实现命令接口，通常会持有接收者，并调用接收者的功能来完成命令的操作。</li>
<li>实现者&#x2F;接收者角色：真正执行命令的对象，任何类都有可能称为一个接收者，只要它能够实现命令要求实现的相应功能</li>
<li>调用者&#x2F;请求者角色：要求命令对象执行请求，通常会持有命令对象，可以持有很多命令对象，是客户端真正触发命令并要求命令执行相应操作的地方，相当于使用命令对象的入口</li>
</ul>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230417200706233.png" alt="image-20230417200706233"></p>
<h4 id="优点-10"><a href="#优点-10" class="headerlink" title="优点"></a>优点</h4><ul>
<li>降低系统耦合度，命令模式能够将调用操作对象与实现该操作的对象解耦</li>
<li>增加或者删除命令非常方便，采用命令模式增加与删除命令不会影响其他类，满足开闭原则</li>
<li>可以实现宏命令，命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令</li>
<li>方便实现Undo和Redo操作，命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销和恢复</li>
</ul>
<h4 id="缺点-8"><a href="#缺点-8" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>使用命令模式可能会导致某些系统有过多的具体命令类</li>
<li>系统结构更复杂</li>
</ul>
<h4 id="使用场景-5"><a href="#使用场景-5" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>系统需要将请求调用者和请求接受者解耦，使调用者和接收者不直接交互</li>
<li>系统需要在不同时间指定请求，将请求排队和执行请求</li>
<li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作</li>
</ul>
<h4 id="JDK源码案例-2"><a href="#JDK源码案例-2" class="headerlink" title="JDK源码案例"></a>JDK源码案例</h4><p><code>Runable</code>接口，命令的角色，Thread是调用者，start方法就是其执行方法</p>
<h3 id="1-3-4责任链模式"><a href="#1-3-4责任链模式" class="headerlink" title="1.3.4责任链模式"></a>1.3.4责任链模式</h3><p>案例：请假需要审批，不同的领导有不同的权限，请求者要根据需求找不同领导，需要提前记住所有的领导与其权限，难度很高。</p>
<p>为了避免请求发送者与多个请求处理者耦合在一起，将所有的请求处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可以请求沿着这条链处理下去，直到有对象处理它</p>
<h4 id="结构-15"><a href="#结构-15" class="headerlink" title="结构"></a>结构</h4><ul>
<li>抽象处理者角色：定义一个处理请求的接口。包括处理方法和一个后续连接</li>
<li>具体处理者角色：实现抽象处理者的处理方法，判断能否处理本次请求，可以则处理，否则请求传递给后继</li>
<li>客户类角色：创建处理链，并向链头的具体处理者对象提交请求，不关心处理细节和请求的传递过程</li>
</ul>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230418195037867.png" alt="image-20230418195037867"></p>
<h4 id="优点-11"><a href="#优点-11" class="headerlink" title="优点"></a>优点</h4><ul>
<li>降低了对象之间的耦合度</li>
<li>增加了系统的可扩展性</li>
<li>增强了给对象指派职责的灵活性</li>
<li>责任链简化了对象之间的连接</li>
<li>责任分担</li>
</ul>
<h4 id="缺点-9"><a href="#缺点-9" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>不能保证请求一定被处理</li>
<li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能受到影响</li>
<li>职责链建立的合理性要靠客户端保证，增加了客户端的复杂性，职责链错误设置可能造成循环调用</li>
</ul>
<h4 id="源码案例-2"><a href="#源码案例-2" class="headerlink" title="源码案例"></a>源码案例</h4><p>javaweb中，FilterChain(过滤器)是责任链模式典型应用</p>
<h3 id="1-3-5状态模式"><a href="#1-3-5状态模式" class="headerlink" title="1.3.5状态模式"></a>1.3.5状态模式</h3><p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230418195956041.png" alt="image-20230418195956041"></p>
<p>对有状态的对象，把复杂的判断逻辑提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为</p>
<h4 id="结构-16"><a href="#结构-16" class="headerlink" title="结构"></a>结构</h4><ul>
<li>环境角色：也称为上下文，定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理</li>
<li>抽象状态角色：定义一个接口，用来封装环境对象中特定状态所对应的行为</li>
<li>具体状态角色：实现抽象状态对应的行为</li>
</ul>
<p>上述电梯案例可以改进为：</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230418200531876.png" alt="image-20230418200531876"></p>
<h4 id="优点-12"><a href="#优点-12" class="headerlink" title="优点"></a>优点</h4><ul>
<li><p>将所有与某个状态有关的行为放到一个类中，可以方便地增加新的状态，只需要改变对象状态即可改变对象行为</p>
</li>
<li><p>允许状态转换逻辑与状态对象合成一体，而不是某个巨大的条件语句块</p>
</li>
</ul>
<h4 id="缺点-10"><a href="#缺点-10" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>状态模式的使用必然会增加系统类和对象的个数</li>
<li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱</li>
<li>状态模式对开闭原则的支持不好</li>
</ul>
<h4 id="使用场景-6"><a href="#使用场景-6" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li><p>当一个对象的行为取决于它的状态，并且必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式</p>
</li>
<li><p>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态</p>
</li>
</ul>
<h3 id="1-3-6观察者模式（重要）"><a href="#1-3-6观察者模式（重要）" class="headerlink" title="1.3.6观察者模式（重要）"></a>1.3.6观察者模式（重要）</h3><p>又称发布-订阅模式，定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己</p>
<h4 id="结构-17"><a href="#结构-17" class="headerlink" title="结构"></a>结构</h4><ul>
<li>抽象主题：抽象的被观察者，把所有观察者对象保存在一个集合，可以有任意数量观察者，提供一个接口增删观察者对象</li>
<li>具体主题：具体被观察者，将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知</li>
<li>抽象观察者：是观察者的抽象类，定义了一个更新接口，得到主题更改时更新自己</li>
<li>具体观察者：实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身状态</li>
</ul>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230418201638118.png" alt="image-20230418201638118"></p>
<h4 id="优点-13"><a href="#优点-13" class="headerlink" title="优点"></a>优点</h4><ul>
<li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系</li>
<li>被观察者发送通知，所有注册的观察者会受到信息</li>
</ul>
<h4 id="缺点-11"><a href="#缺点-11" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p>如果观察者非常多，那么所有的观察者受到被观察者发送的通知会耗时</p>
</li>
<li><p>如果被观察者有循环依赖，那么被观察者发送通知会使观察者循环调用导致系统崩溃</p>
</li>
</ul>
<h4 id="使用场景-7"><a href="#使用场景-7" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li><p>当对象间存在一对多关系，并且一个对象发生改变会影响其他对象</p>
</li>
<li><p>一个抽象模型有两方面，其中一个方面依赖于另一方面</p>
</li>
</ul>
<h4 id="JDK源码案例-3"><a href="#JDK源码案例-3" class="headerlink" title="JDK源码案例"></a>JDK源码案例</h4><p>java.util.Observable类和java.util.Observer接口定义了观察者模式，只要实现他们的子类就可以编写观察者模式</p>
<ul>
<li><p>java.util.Observable类</p>
<p>抽象被观察者，有一个Vector集合成员变量，用于保存要通知的观察者对象，主要的三个方法</p>
<ul>
<li>void addObserver(Observer o)</li>
<li>void  notifyObservers(Object arg)：调用集合中所有观者者对象的update方法，通知他们数据发生改变，通常越晚加入集合的观察者越先得到通知</li>
<li>void setChange()：用来设置一个boolean类型的内部标志，注明对象发生改变，当为true时，notifyObeservers才会通知观察者</li>
</ul>
</li>
<li><p>java.util.Observer接口</p>
<p>抽象观察者，监视目标变化，当改变时得到通知并调用update方法完成相应工作</p>
</li>
</ul>
<h3 id="1-3-7中介者模式"><a href="#1-3-7中介者模式" class="headerlink" title="1.3.7中介者模式"></a>1.3.7中介者模式</h3><p>多对多的关系中，不同对象之间耦合度很高</p>
<p>又称调停模式，定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立改变他们之间的交互</p>
<h4 id="结构-18"><a href="#结构-18" class="headerlink" title="结构"></a>结构</h4><ul>
<li>抽象中介者角色：中介者接口，提供了同事对象注册与转发同事对象信息的抽象方法</li>
<li>具体中介者角色：实现中介者接口，定义一个List管理同事对象，协调各个同事角色之间的交互关系，依赖于同事角色</li>
<li>抽象同事类角色：定义同事类接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响同事类的公共功能</li>
<li>具体同事类角色：实现抽象同事类，当需要与其他同事对象交互时，由中介者对象负责后续的交互</li>
</ul>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230419163902211.png" alt="image-20230419163902211"></p>
<h4 id="优点-14"><a href="#优点-14" class="headerlink" title="优点"></a>优点</h4><ul>
<li><p>松散耦合</p>
<p>通过把多个同事对象之间的交互封装到中介者对象里面，使得同时对象之间松散耦合，基本上可以互补依赖。这样同事对象就可以独立的变化和复用</p>
</li>
<li><p>集中控制交互</p>
<p>多个同事对象的交互，被封装在中介者对象里面集中管理，是的交互行为发生变化时候，只需要修改或者扩展中介者对象就可以</p>
</li>
<li><p>一对多关联转变为一对一的关联</p>
<p>没有中介者模式，同事对象之间的关系是一对多的，引入中介者对象以后中介者和同事的关系变成双向的一对一</p>
</li>
</ul>
<h4 id="缺点-12"><a href="#缺点-12" class="headerlink" title="缺点"></a>缺点</h4><p>当同事类太多时，中介者的职责很大，变得复杂而庞大，以至于系统很难维护</p>
<h4 id="使用场景-8"><a href="#使用场景-8" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li><p>系统对象之间存在复杂的引用关系，系统结构混乱且难以理解</p>
</li>
<li><p>像创建一个运行于多个类之间的对象，又不想生成新的子类时</p>
</li>
</ul>
<h3 id="1-3-8迭代器模式"><a href="#1-3-8迭代器模式" class="headerlink" title="1.3.8迭代器模式"></a>1.3.8迭代器模式</h3><p>提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示</p>
<h4 id="结构-19"><a href="#结构-19" class="headerlink" title="结构"></a>结构</h4><ul>
<li><p>抽象聚合角色</p>
<p>定义存储，添加，删除元素以及创建迭代器对象的接口</p>
</li>
<li><p>具体聚合角色</p>
<p>实现抽象聚合类，返回一个具体迭代器实例</p>
</li>
<li><p>抽象迭代器角色</p>
<p>定义访问和遍历聚合元素的接口，通常包含hasNext(),next()等方法</p>
</li>
<li><p>具体迭代器角色</p>
<p>实现抽象迭代器接口所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置</p>
</li>
</ul>
<p>![1681903928764](C:\Users\Bubble\Documents\WeChat Files\wxid_gml3vksg039r22\FileStorage\Temp\1681903928764.png)</p>
<h4 id="优点-15"><a href="#优点-15" class="headerlink" title="优点"></a>优点</h4><ul>
<li>支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不通的迭代器来替换原有迭代器即可改变遍历算法，也可以自己定义迭代器的子类以支持新的遍历方式</li>
<li>简化了聚合类，由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计</li>
<li>在迭代器模式中，由于引入了抽象层，增加了新的聚合类和迭代器类都很方便，无需修改原有代码，符合开闭原则</li>
</ul>
<h4 id="缺点-13"><a href="#缺点-13" class="headerlink" title="缺点"></a>缺点</h4><p>增加了类的个数，在一定程度上增加了系统的复杂性</p>
<h4 id="使用场景-9"><a href="#使用场景-9" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>当需要为聚合对象提供多种遍历方式时</li>
<li>当需要为遍历不同的聚合结构提供一个统一的接口时</li>
<li>当访问一个聚合对象的内容无需暴露其内部细节表示的时候</li>
</ul>
<h4 id="JDK源码案例-4"><a href="#JDK源码案例-4" class="headerlink" title="JDK源码案例"></a>JDK源码案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    System.out.printLn(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单例集合中都使用到了迭代器，以ArrayList举例</p>
<ul>
<li>List：抽象聚合类</li>
<li>ArrayList：具体的聚合类</li>
<li>Iterator：抽象迭代器</li>
<li>list.iterator()：返回实现了<code>Iterator</code>接口的具体迭代器对象</li>
</ul>
<p>Java开发要使用迭代器模式，只需要在自己定义的容器类实现<code>java.util.Iterable</code>并实现其中iterator()方法使其返回一个<code>java.util.Iterator</code>的实现类就可以了</p>
<h3 id="1-3-9访问者模式"><a href="#1-3-9访问者模式" class="headerlink" title="1.3.9访问者模式"></a>1.3.9访问者模式</h3><p>封装了一些作用于某种数据结构中的各元素操作（将数据结构和元素的操作分离），可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作</p>
<h4 id="结构-20"><a href="#结构-20" class="headerlink" title="结构"></a>结构</h4><ul>
<li>抽象访问者角色：定义对每一个元素(Element)访问的行为，参数是可以访问的元素，方法个数理论上来说与元素个数是一样的，所以元素个数不能改变</li>
<li>具体访问者角色：给出对每一个元素类访问时所产生的具体行为</li>
<li>抽象元素角色：定义接受访问者的方法(accept)，意义是每一个元素都可以被访问者访问</li>
<li>具体元素角色：提供接收访问方法的具体实现，通常情况下是使用访问者提供的访问该元素类的方法</li>
<li>对象结构角色：定义当中提到的对象结构，是一个抽象表述，可以理解为具有容器性质或者复合对象特性的类，含有一组元素，且可以迭代这些元素，供访问者访问</li>
</ul>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230419200931292.png" alt="image-20230419200931292"></p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230419200946324.png" alt="image-20230419200946324"></p>
<h4 id="优点-16"><a href="#优点-16" class="headerlink" title="优点"></a>优点</h4><ul>
<li>扩展性好：不改变对象结构的元素的情况下，可以给对象结构中的元素添加新的功能</li>
<li>复用性好：通过访问者来定义整个对象结构通用的功能，从而提高复用程度</li>
<li>分离无关行为：通过访问者来分离无关的行为，把相关的行为封装在一起构成一个访问者，这样每一位访问者的功能都比较单一</li>
</ul>
<h4 id="缺点-14"><a href="#缺点-14" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p>对象结构变化很困难</p>
<p>每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，违背了开闭原则</p>
</li>
<li><p>违反了依赖倒置原则</p>
<p>访问者模式依赖具体类，且没有依赖抽象类</p>
</li>
</ul>
<h4 id="使用场景-10"><a href="#使用场景-10" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>对象结构相对稳定，但其操作算法经常变化的程序</li>
<li>对象结构中的对象需要提供多种不同且不相关的操作，且要避免这些操作的变化影响对象的结构</li>
</ul>
<h4 id="模式扩展-双分派"><a href="#模式扩展-双分派" class="headerlink" title="模式扩展-双分派"></a>模式扩展-双分派</h4><p>分派：变量被声明时的类型叫做变量的静态类型，又把静态类型角坐明显类型，变量引用的对象的真实类型又称为变量的实际类型</p>
<p>比如<code>Map map = new HashMap()</code>，map变量静态类型是Map，实际类型是HashMap。</p>
<p>根据对象类型对方法进行选择就是分派，分为静态分派和动态分派</p>
<ul>
<li>静态分派：发生在编译时期，根据静态类型信息发生。方法重载就是静态分派</li>
<li>动态分派：发生在运行时期，动态地置换某个方法，Java通过方法重写支持动态分派</li>
</ul>
<p>双分派：在选择一个方法时，不仅仅根据消息接收者和运行时区分，还要根据参数地运行时区别</p>
<h3 id="1-3-10备忘录模式"><a href="#1-3-10备忘录模式" class="headerlink" title="1.3.10备忘录模式"></a>1.3.10备忘录模式</h3><p>提供了一种状态恢复的实现机制</p>
<p>又称快照模式，在不破坏封装性的前提下，捕获一个对象内部状态，在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态</p>
<h4 id="结构-21"><a href="#结构-21" class="headerlink" title="结构"></a>结构</h4><ul>
<li>发起人角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息</li>
<li>备忘录角色：负责存储发起人的内部状态，在有需要的时候提供这些内部状态给发起人</li>
<li>管理者角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问和修改</li>
</ul>
<p>两个等效的接口：</p>
<ul>
<li>窄接口：管理者对象看到的是备忘录的窄接口，只允许把备忘录对象传给其他的对象（无法修改或看到备忘录中具体信息）</li>
<li>宽接口：与管理者的窄接口相反，发起人可以看到宽接口，允许读取所有数据，以便根据这些数据恢复发起人对象的内部状态</li>
</ul>
<h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h4><p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230420194851288.png" alt="image-20230420194851288"></p>
<h4 id="”白箱“备忘录模式"><a href="#”白箱“备忘录模式" class="headerlink" title="”白箱“备忘录模式"></a>”白箱“备忘录模式</h4><p>备忘录角色对任何对象都提供一个款接口，备忘录角色内部所存储的状态全部公开</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230420195059707.png" alt="image-20230420195059707"></p>
<h4 id="“黑箱”备忘录模式"><a href="#“黑箱”备忘录模式" class="headerlink" title="“黑箱”备忘录模式"></a>“黑箱”备忘录模式</h4><p>对发起人对象提供一个款接口，为其他对象提供一个窄接口。Java中使用双重接口的方法将备忘录类设计成发起人类的内部成员类</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230420195636902.png" alt="image-20230420195636902"></p>
<h4 id="优点-17"><a href="#优点-17" class="headerlink" title="优点"></a>优点</h4><ul>
<li>提供了一种可以恢复状态的机制，当需要的时候可以比较方便将数据恢复到某个历史状态</li>
<li>实现了内部状态的封装，除了创建的发起人之外，其他对象都不能够访问这些状态信息</li>
<li>简化了发起人类，发起人类不需要管理和保存内部状态的各个备份，所有的状态信息都保存在备忘录中，并由管理者进行管理，符合单一职责原则</li>
</ul>
<h4 id="缺点-15"><a href="#缺点-15" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>资源消耗大，如果需要保存内部状态信息过多或者非常频繁，会占用比较大的内存资源</li>
</ul>
<h4 id="使用场景-11"><a href="#使用场景-11" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>需要保存与恢复数据的场景，如玩游戏时中间结果的存档功能</li>
<li>需要提供一个可回滚操作的场景，如Ctrl+z操作，数据库事务操作</li>
</ul>
<h3 id="1-3-11解释器模式（类行为）"><a href="#1-3-11解释器模式（类行为）" class="headerlink" title="1.3.11解释器模式（类行为）"></a>1.3.11解释器模式（类行为）</h3><p>给定一个语言，定义它的文法表示，并定义一个解释器，使用该标识来解释语言中的句子</p>
<h4 id="结构-22"><a href="#结构-22" class="headerlink" title="结构"></a>结构</h4><ul>
<li>抽象表达式角色：定义解释器接口，约定解释器的解释操作，主要包含解释方法interpret()</li>
<li>终结符表达式角色：抽象表达式的子类，用来实现与终结符相关的操作，文法中的每一个终结符都有一个具体的终结表达式与之对应</li>
<li>非终结符表达式：也是抽象表达式的子类，实现文法中与非终结符相关的操作，每条规则都对应一个非终结符表达式</li>
<li>环境角色：包含各个解释器需要的数据或者是公共的功能，一般用来传递所有解释器共享的数据，后面的解释器可以从这里获取</li>
<li>客户端：将需要分析的句子或者表达式转换成通用的解释器对象描述的抽象语法树，调用解释器的解释方法，也可以通过环境角色间接访问解释器的解释方法</li>
</ul>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230420203610672.png" alt="image-20230420203610672"></p>
<h4 id="优点-18"><a href="#优点-18" class="headerlink" title="优点"></a>优点</h4><ul>
<li>易于改变和扩展文法</li>
<li>实现文法比较容易</li>
<li>增加新的解释表达式较为方便</li>
</ul>
<h4 id="缺点-16"><a href="#缺点-16" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>对于复杂的文法难以维护</li>
<li>执行效率低</li>
</ul>
<h4 id="使用场景-12"><a href="#使用场景-12" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>当语言文法较为简单，执行效率不是关键问题时</li>
<li>问题重复出现，可以用一种简单的语言来进行表达时</li>
<li>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候</li>
</ul>
<h1 id="2设计原则"><a href="#2设计原则" class="headerlink" title="2设计原则"></a>2设计原则</h1><h2 id="2-1单一职责原则"><a href="#2-1单一职责原则" class="headerlink" title="2.1单一职责原则"></a>2.1单一职责原则</h2><p>每个类只负责自己的事情，不是变成万能的</p>
<h2 id="2-2开闭原则"><a href="#2-2开闭原则" class="headerlink" title="2.2开闭原则"></a>2.2开闭原则</h2><p>对扩展开放，对修改关闭：</p>
<p>程序需要拓展不能修改原有代码——&gt;使用抽象类和接口</p>
<h2 id="2-3里氏代换原则"><a href="#2-3里氏代换原则" class="headerlink" title="2.3里氏代换原则"></a>2.3里氏代换原则</h2><p>任何基类可以出现的地方，子类一定可以出现：</p>
<p>子类可以拓展父类功能，但不能改变父类原有功能。即子类继承父类，除了添加新功能，尽量不要重写父类方法。</p>
<p>举例（正方形是矩形）</p>
<h2 id="2-4依赖倒转原则"><a href="#2-4依赖倒转原则" class="headerlink" title="2.4依赖倒转原则"></a>2.4依赖倒转原则</h2><p>高层模块不应该依赖低层模块，都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象：</p>
<p>A类中某个成员是B类，即A类依赖B类，此时A类就是高层模块，B类是低层模块。A类应该依赖抽象类，不应该依赖实体类。</p>
<p>（可以视作开闭原则的具体实现）</p>
<h2 id="2-5接口隔离原则"><a href="#2-5接口隔离原则" class="headerlink" title="2.5接口隔离原则"></a>2.5接口隔离原则</h2><p>客户端不应该被迫依赖它不使用的方法：一个类对另一个类的依赖应该建立在最小的接口上。（接口定义的内容应该尽可能隔离</p>
<h2 id="2-6迪米特法则"><a href="#2-6迪米特法则" class="headerlink" title="2.6迪米特法则"></a>2.6迪米特法则</h2><p>最少知识原则：只和你的直接朋友交流，不和陌生人说话：</p>
<p>两个实体之间无须直接通信情况下不应该发生直接相互调用，可以通过第三方转发调用</p>
<p>这里的直接朋友指：当前对象本身，成员对象，创建的对象，对象的方法，方法参数</p>
<h2 id="2-7合成复用原则"><a href="#2-7合成复用原则" class="headerlink" title="2.7合成复用原则"></a>2.7合成复用原则</h2><p>尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系</p>
<p>直接使用继承缺点：</p>
<ol>
<li>破坏了类的封装性。因为继承时父类的细节是暴露给子类的</li>
<li>子类和父类耦合度高。父类改变会导致子类改变，不利于类的扩展和维护</li>
<li>限制了复用的灵活性，从父类继承的实现是静态的，编译时已定义，运行时不可能变化</li>
</ol>
<p>使用合成复用的优点：</p>
<p>上面相反就是</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="clix3qjvx000rqwueh8pea9e1" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算机网络" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="article-date">
  <time class="dt-published" datetime="2023-06-15T12:12:02.315Z" itemprop="datePublished">2023-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="通用基础"><a href="#通用基础" class="headerlink" title="通用基础"></a>通用基础</h1><h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><h3 id="TCP-x2F-IP四层网络模型"><a href="#TCP-x2F-IP四层网络模型" class="headerlink" title="TCP&#x2F;IP四层网络模型"></a>TCP&#x2F;IP四层网络模型</h3><ul>
<li>应用层：应用层为用户提供应用功能，包括HTTP，FTP，Telnet，DNS，SMTP协议</li>
<li>传输层：为应用层提供网络支持，包括TCP和UDP协议，提供端口到端口的通信</li>
<li>网络层：负责将数据从一个设备传输到另一个设备，ip来标识设备。ip协议（1.路由转发，2.IP寻址）</li>
<li>网络接口层：通过MAC地址（物理地址）标识网络设备为网络层提供链路级的传输服务，负责在以太网，WIFI这样的底层网络发送原始数据包</li>
</ul>
<h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><ul>
<li>应用层</li>
<li>表示层</li>
<li>会话层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/OSI%E4%B8%8ETCP.png" alt="img"></p>
<h2 id="常见问题：输入网址到网页显示发生了什么"><a href="#常见问题：输入网址到网页显示发生了什么" class="headerlink" title="常见问题：输入网址到网页显示发生了什么"></a>常见问题：输入网址到网页显示发生了什么</h2><ol>
<li><p>解析URL：</p>
<p>HTTP协议根据URL中对应的请求资源，确定了Web服务器和文件名产生HTTP请求</p>
</li>
<li><p>查询真实地址</p>
<p>DNS协议查询服务器域名对应的IP地址</p>
<ul>
<li>客户端先查询本地域名服务器，如果找到对应IP就返回，没有本地域名服务器去访问其对应的根域名服务器</li>
<li>根域名服务器收到本地域名服务器的请求，根据目标URL后缀告诉本地域名服务器要去哪查询</li>
<li>经过不同的根域名服务器的指路，本地域名服务器找到对应的IP地址</li>
<li>本地域名服务器将结果返回客户端并将对应的IP加入缓存</li>
</ul>
</li>
<li><p>运输层协议</p>
<p>产生TCP报文（如果使用TCP协议</p>
</li>
<li><p>IP协议</p>
<p>IP协议将报文封装成网络包，根据IP地址发送转发</p>
</li>
<li><p>MAC</p>
<p>ARP协议根据IP地址获取MAC地址：</p>
<ul>
<li>查询ARP缓存有没有对应MAC地址</li>
<li>在局域网发送ARP广播轮询</li>
</ul>
<p>在IP的头部加上MAC头部，加上MAC地址</p>
</li>
<li><p>网卡</p>
<p>将数字信号转换为电信号在网线上传播</p>
</li>
<li><p>交换机</p>
<p>交换机将网络包原样转发到目的地</p>
</li>
<li><p>路由器</p>
<p>查表判断转发的目标</p>
</li>
</ol>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>超文本传输协议，Hyper Text Transfer Protocol</p>
<p>是传输图片文字音频视频等超文本数据的约定和规范</p>
<p>常见状态码：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.png" alt=" 五大类 HTTP 状态码 "></p>
<p>在发送请求的时候需要指定服务器域名，服务器返回数据要表示这次的回应的数据长度，使用Content-Length字段</p>
<h2 id="Get与Post"><a href="#Get与Post" class="headerlink" title="Get与Post"></a>Get与Post</h2><p>Get：从服务器获取指定资源</p>
<p>Post：根据请求负荷对指定资源做出处理（我要去改一些东西，比如发布留言等</p>
<h3 id="二者都是安全幂等的吗"><a href="#二者都是安全幂等的吗" class="headerlink" title="二者都是安全幂等的吗"></a>二者都是安全幂等的吗</h3><p>安全：请求方法不会破坏服务器上的资源</p>
<p>幂等：多次执行相同操作，结果都相同</p>
<ul>
<li><p>Get：安全且幂等，因为是只读操作，因此可以对Get请求的数据做缓存，这个缓存可以在流浪其上或者代理（nginx）上</p>
</li>
<li><p>Post：会修改服务器资源，所以不安全，多次提交就会创建多个资源，不是幂等的</p>
</li>
</ul>
<h2 id="HTTP缓存技术"><a href="#HTTP缓存技术" class="headerlink" title="HTTP缓存技术"></a>HTTP缓存技术</h2><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>只要浏览器判断缓存没过期就直接用浏览器本地缓存，决定要不要用缓存取决于浏览器</p>
<p>实现强制缓存：Response Header字段中设置Cache-Control（相对时间）或者Expires（绝对时间），推荐Cache-Control</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>通过服务端告知客户端是否可以使用缓存的方式，也就是和服务端协商来决定要不要用本地缓存（比如本地缓存过期了，和服务器协商发现结果资源是一致的就可以继续用）</p>
<p>一般和强制缓存配合使用</p>
<h2 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h2><p>二者的区别</p>
<ul>
<li>HTTP信息是明文传输，存在安全风险的问题。HTTPS解决HTTP不安全的缺陷，在TCP和HTTP网络层之间加入了SSL&#x2F;TLS安全协议，使报文能够加密传输</li>
<li>HTTP连接相对简单，TCP三次握手之后便可以进行HTTP报文传输，而HTTPS在TCP三次握手之后还需要进行SSL&#x2F;TLS的握手过程才可以进入加密报文传输</li>
<li>默认端口不同，HTTP默认80，HTTPS默认443</li>
<li>HTTPS需要向CA（证书权威机构）申请数字证书来保证服务器的身份可信</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/19-HTTPS%E4%B8%8EHTTP.png" alt="HTTP 与 HTTPS 网络层"></p>
<p>HTTP的明文传输安全存在三个风险：窃听，篡改，冒充</p>
<p>HTTPS根据这些问题加入了SSL&#x2F;TLS来解决，进行信息加密，校验机制，身份证书</p>
<ul>
<li>混合加密的方式实现信息的机密性，解决窃听风险</li>
<li>摘要算法的方式实现完整性，能够为数据生成独一无二的指纹，用于校验数据的完整性，解决被篡改风险</li>
<li>将服务器公钥放入数字证书中，解决了冒充的风险</li>
</ul>
<h3 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h3><ul>
<li>在通信建立前采用非对称加密的方式交换<strong>会话密钥</strong>，后续不再使用非对称加密</li>
<li>通信过程中全部使用对称加密的<strong>会话密钥</strong>的方式加密明文数据</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/20-%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86.png" alt="混合加密"></p>
<h3 id="摘要算法-数字签名"><a href="#摘要算法-数字签名" class="headerlink" title="摘要算法+数字签名"></a>摘要算法+数字签名</h3><p>使用摘要算法（哈希函数）计算内容的哈希值，这个哈希值唯一且无法通过哈希值推导内容，一起发送给对方</p>
<p>收到内容后根据内容也计算一个指纹，如果这两个指纹一致那内容就没有被篡改</p>
<p><strong>问题</strong>：保证内容不被篡改，但是不能保证内容+哈希值不被中间人替换</p>
<p>使用非对称加密算法来解决这个问题</p>
<ul>
<li>公钥公开给所有人</li>
<li>私钥不可泄露</li>
</ul>
<p>可以双向加解密，也就是一个拿来加密，一个拿来解密</p>
<ul>
<li>公钥加密，私钥解密：保证内容传输安全，只有有私钥的人才可以解密出实际内容</li>
<li>私钥加密，公钥解密：保证信息不被冒充，公钥解密出的内容可以确保来自私钥身份的发送者</li>
</ul>
<p>数字签名：私钥加密，公钥解密的方式。私钥加密的不是内容本身而使内容的哈希值（指纹）</p>
<h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>通过哈希算法的指纹可以保证信息完整，数字签名可以保证消息来自于持有私钥的一方</p>
<p><strong>问题</strong>：如果公钥被伪造呢？伪造者伪造了公钥，使得接收者可以通过伪造的公钥解密来确认了文件的完整性</p>
<p>数字证书验证身份：</p>
<p>要先将发送者的公钥注册到CA（数字证书认证机构），将发送者的信息+公钥+数字签名打包成数字证书。</p>
<p>接收者收到信息先去CA验证数字证书是否合法，CA确认合法就证明公钥来自发送者，就可以安心使用</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E8%AF%81%E4%B9%A6%E7%9A%84%E6%A0%A1%E9%AA%8C.png" alt="img"></p>
<p>CA签发整数过程：</p>
<ul>
<li>CA把持有者的公钥，用途，颁发者，有效时间等信息打成一个包，然后对这些信息进行Hash计算得到hash值</li>
<li>CA使用自己的私钥将这个Hash加密，生成CA对证书的签名</li>
<li>将签名添加在文件证书上形成数字证书</li>
</ul>
<p>客户端校验服务端的数字证书过程</p>
<ul>
<li>客户端使用同样的Hash算法获取证书Hash值</li>
<li>浏览器和操作系统中有CA的公钥信息，收到证书后使用CA的公钥解密，得到另一个Hash值</li>
<li>比较两个Hash值是否相同，相同则可以信任</li>
</ul>
<h4 id="证书信任链"><a href="#证书信任链" class="headerlink" title="证书信任链"></a>证书信任链</h4><p>跟CA申请的证书一般不是根证书签发，而是中间证书签发，比如百度的证书</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/baidu%E8%AF%81%E4%B9%A6.png" alt="img"></p>
<p>验证过程：</p>
<ul>
<li>客户端收到baidu的证书后发现不是根证书，无法根据本地根证书的密钥验证是否可信。于是根据baidu证书的签发者，找到该证书的颁发机构，然后向CA请求该中间证书</li>
<li>请求到中间证书发现他的上级是根证书，就可以利用根证书的公钥验证，如果通过就认为该中间证书可信</li>
<li>通过中间证书验证baidu，如果通过就可以信任baidu的证书</li>
</ul>
<p>信任链是为了保证根证书的绝对安全性，</p>
<h3 id="HTTPS建立连接"><a href="#HTTPS建立连接" class="headerlink" title="HTTPS建立连接"></a>HTTPS建立连接</h3><p>SSL&#x2F;TLS协议基本流程根据上面可以总结为：</p>
<ul>
<li>客户端向服务器索要并验证服务器公钥</li>
<li>双方协商产生会话密钥</li>
<li>双方采用会话密钥进行加密通信</li>
</ul>
<p>前两步是SSL&#x2F;TLS建立过程，也是TLS握手阶段</p>
<p>常用的密钥交换算法有两种：RSA和ECDHE（因为RSA有前向安全问题，现在大部分网站使用ECDHE）</p>
<p>TLS协议建立的详细流程：</p>
<ol>
<li><p>ClientHello</p>
<p>客户端向服务器发起加密通信请求，主要发送以下信息</p>
<ul>
<li>客户端支持的TLS协议版本</li>
<li>客户端生成的随机数，用于生成会话密钥的条件之一</li>
<li>客户端支持的密码套件列表，比如RSA</li>
</ul>
</li>
<li><p>ServerHello</p>
<p>服务器收到客户端请求后向客户端发出相应，内容主要如下</p>
<ul>
<li>确认TLS协议版本，如果浏览器不支持就关闭加密通信</li>
<li>服务器产生的随机数，也用于产生会话密钥</li>
<li>确认密码套件列表</li>
<li>服务器的数字证书</li>
</ul>
</li>
<li><p>客户端回应</p>
<p>客户端收到服务器回应后首先通过浏览器或者操作系统的CA公钥来确认服务器数字证书的真实性</p>
<p>如果证书没问题，客户端会从数字证书中取出服务器公钥然后使用它加密报文，向服务器发送信息：</p>
<ul>
<li>一个新的随机数，会被服务器公钥加密</li>
<li>加密通信算法改变通知，表示随后的信息将用会话密钥加密通信</li>
<li>客户端握手结束通知，表示客户端握手阶段结束，同时将之前的所有内容产生的数据做个摘要来提供服务端校验</li>
</ul>
</li>
<li><p>服务器的最后回应</p>
<p>服务器和客户端有了三个随机数，可以用双方协商的加密算法各自产生本次通信的会话密钥</p>
<p>然后向客户端发送最后信息</p>
<ul>
<li>加密通信算法改变通知，表示随后信息都用会话密钥加密</li>
<li>服务器握手结束通知，表示服务器的握手阶段已经结束，并且发送之前内容的摘要给客户端校验</li>
</ul>
</li>
</ol>
<h3 id="HTTPS应用数据如何保证完整性"><a href="#HTTPS应用数据如何保证完整性" class="headerlink" title="HTTPS应用数据如何保证完整性"></a>HTTPS应用数据如何保证完整性</h3><p>TLS实现分为握手协议和记录协议</p>
<ul>
<li>握手协议：上面的连接过程</li>
<li>记录协议：保护应用程序数据并验证完整性和来源</li>
</ul>
<p>记录协议主要负责消息（HTTP数据）的压缩，加密和数据认证</p>
<ul>
<li>消息被分割成多个较短的片段然后分别对每个片段进行压缩</li>
<li>经过压缩的片段会被加上消息认证码（MAC值，通过哈希算法生成），为了保证完整性，并进行数据认证。可以通过MAC值识别篡改，为了防止重放攻击，计算消息认证码同时还加上了片段的编码</li>
<li>经过压缩的片段加上消息认证码会一起通过对称密码进行加密</li>
<li>上述经过加密的数据再加上由数据类型，版本号，压缩后的长度组成的报头就是最终的报文数据</li>
</ul>
<p>之后就可以传导到传输层协议及逆行传输</p>
<h2 id="HTTP1-1，2，3的演变"><a href="#HTTP1-1，2，3的演变" class="headerlink" title="HTTP1.1，2，3的演变"></a>HTTP1.1，2，3的演变</h2><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/27-HTTP3.png" alt="HTTP/1 ~ HTTP/3"></p>
<h3 id="HTTP1-1对HTTP1-0的改进"><a href="#HTTP1-1对HTTP1-0的改进" class="headerlink" title="HTTP1.1对HTTP1.0的改进"></a>HTTP1.1对HTTP1.0的改进</h3><ul>
<li>使用<strong>长连接</strong>的方式改善HTTP1.0短链接造成的性能开销</li>
<li>支持<strong>管道</strong>网络传输，只要第一个请求发出去不必等待返回，就可以发出第二个请求，减少整体的响应时间</li>
</ul>
<h4 id="HTTP1-1的性能瓶颈"><a href="#HTTP1-1的性能瓶颈" class="headerlink" title="HTTP1.1的性能瓶颈"></a>HTTP1.1的性能瓶颈</h4><ul>
<li>只能压缩Body部分，不压缩Header头部</li>
<li>发送冗长的头部，互相发送相同的头部造成浪费</li>
<li>服务器按请求顺序响应，如果服务器响应慢，会导致客户端一直请求不到数据，即<strong>队头阻塞</strong></li>
<li>没有<strong>请求优先级控制</strong></li>
<li>请求只能从客户端开始，<strong>服务器被动响应</strong></li>
</ul>
<h3 id="HTTP2的优化"><a href="#HTTP2的优化" class="headerlink" title="HTTP2的优化"></a>HTTP2的优化</h3><p>基于HTTPS，保障安全性</p>
<p>相比于1.1的改进：</p>
<ul>
<li>头部压缩</li>
<li>二进制格式</li>
<li>并发传输</li>
<li>服务器主动推送资源</li>
</ul>
<h4 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h4><p>如果发送多个请求，头部相同或者相似，协议会帮助消除重复部分。即HPACK算法，客户端服务器同时维护一张头信息表，每个字段生成一个索引号，发送请求只要发送索引号</p>
<h4 id="二进制格式"><a href="#二进制格式" class="headerlink" title="二进制格式"></a>二进制格式</h4><p>将报文的信息，包括头部和body，都是用二进制数据，统称为帧：头信息帧和数据帧</p>
<h4 id="并发传输"><a href="#并发传输" class="headerlink" title="并发传输"></a>并发传输</h4><p>引出Stream概念，多个Stream复用在一条TCP连接</p>
<p>一个TCP包含多个Stream，一个Stream可以包含一个或者多个Message，Mesaage对应请求或者响应，由头和body组成，一个Message包含一个或者多个Frame（帧）</p>
<p>对于不同Stream用Stream ID 标记，接收端通过Stream ID有序组成HTTP消息，帧可以乱序，因此HTTP2可以并行交错发送请求和响应</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/http2%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.jpeg" alt="img"></p>
<h4 id="服务器主动推送"><a href="#服务器主动推送" class="headerlink" title="服务器主动推送"></a>服务器主动推送</h4><p>双方都可以建立Stream，Stream ID有区别</p>
<p>比如客户端获取了HTML文件，可能还需要依赖CSS来渲染页面，需要再次发起获取的请求。但是在HTTP2，服务器在客户端访问HTML时主动推送CSS文件</p>
<h4 id="HTTP2的缺陷"><a href="#HTTP2的缺陷" class="headerlink" title="HTTP2的缺陷"></a>HTTP2的缺陷</h4><p>依然还有队头阻塞问题，不过是在TCP层</p>
<p>TCP是字节流协议，必须保证收到的字节数据完整且连续，这样内核才会将缓冲区的数据返回给HTTP应用，当前一个字节数据没有到达，后收到的字节数据只能存放到内核缓冲区，等待字节到达才能从内核拿到数据</p>
<p>一旦中间的一个数据丢失，后续数据全部无法读取，需要等待丢失数据的重传</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/quic/http2%E9%98%BB%E5%A1%9E.jpeg" alt="img"></p>
<h3 id="HTTP3的优化"><a href="#HTTP3的优化" class="headerlink" title="HTTP3的优化"></a>HTTP3的优化</h3><p>将HTTP下层的TCP协议改成UDP，对于UDP的不可靠传输，使用基于UDP的QUIC协议来实现类似TCP的可靠传输</p>
<p>QUIC特点：</p>
<ul>
<li>无队头阻塞</li>
<li>更快连接建立</li>
<li>连接迁移</li>
</ul>
<h4 id="无对头阻塞"><a href="#无对头阻塞" class="headerlink" title="无对头阻塞"></a>无对头阻塞</h4><p>也有类似HTTP2的Stream和多路复用概念，但是QUIC中某个流丢包时只会阻塞这个流，其他流不受影响，因此可以解决队头阻塞</p>
<h4 id="更快连接建立"><a href="#更快连接建立" class="headerlink" title="更快连接建立"></a>更快连接建立</h4><p>HTTP1和2中TCP和TLS分层，很难合并，需要分别进行握手。QUIC内部包含了TLS，在自己的帧会携带TLS的记录</p>
<p>HTTP3虽然传输数据前需要QUIC协议握手，但是握手只需要1RTT，来确认双方连接ID</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/28-HTTP3%E4%BA%A4%E4%BA%92%E6%AC%A1%E6%95%B0.png" alt="TCP HTTPS（TLS/1.3） 和 QUIC HTTPS "></p>
<p>第二次连接时候应用数据包就可以和QUIC握手信息一起发送，达到0RTT的效果</p>
<h4 id="链接迁移"><a href="#链接迁移" class="headerlink" title="链接迁移"></a>链接迁移</h4><p>基于TCP的HTTP协议通过四元组确定TCP连接：源地址，源端口，目标地址，目标端口</p>
<p>HTTP1和2中当设备从4G切换到WIFI时IP地址变化就必须断开连接重新连接，因为需要TCP握手和TLS握手成本很高</p>
<p>QUIC协议通过连接ID来标记通信两个端点，客户端和服务器可以选择一组ID来标记自己，即使网络变化导致IP地址变化，只要仍保留上下文（ID，TLS密钥）就可以无缝复用连接</p>
<p>HTTP3的普及还很缓慢</p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="基本认识"><a href="#基本认识" class="headerlink" title="基本认识"></a>基本认识</h2><p>因为IP层不可靠，不能保证网络包都能接收，按序交付，数据完整，传输层的TCP来负责。TCP是工作在传输层的可靠数据传输服务，能够确保网络包无损坏，无间隔，非冗余和按序</p>
<p>TCP：面向连接的，可靠的，基于字节流的传输层通信协议</p>
<ul>
<li>面向连接：一定是一对一才能连接，无法向UDP一样一个主机同时可以向多个主机发送信息</li>
<li>可靠：无论网络链路出现了什么变化，TCP可以保证一个报文一定能够到达接收端</li>
<li>字节流：消息被操作系统分组成多个TCP报文，接收方需要知道消息边界组合出信息。TCP是有序的，前一个TCP报文没有收到，即使收到了后面的报文，也不能给应用层处理，重复的报文会丢弃</li>
</ul>
<p>UDP不提供复杂的控制机制，利用IP面向无连接的通信服务</p>
<h4 id="UDP与TCP的区别"><a href="#UDP与TCP的区别" class="headerlink" title="UDP与TCP的区别"></a>UDP与TCP的区别</h4><ol>
<li>连接：<ul>
<li>TCP面向连接的传输层协议，传输数据前要先建立连接</li>
<li>UDP不需要连接，即刻传输数据</li>
</ul>
</li>
<li>服务对象：<ul>
<li>TCP支持一对一的两点服务，一条连接只有两个端点</li>
<li>UDP支持一对一，一对多，多对多的交互通信</li>
</ul>
</li>
<li>可靠性：<ul>
<li>TCP可靠交付数据，数据可以无差错，不丢失，不重复，按序到达</li>
<li>UDP尽最大努力交付，不保证可靠交付，但是基于UDP可以实现可靠传输协议，比如QUIC协议</li>
</ul>
</li>
<li>拥塞控制，流量控制：<ul>
<li>TCP拥有拥塞控制和流量控制机制，保证数据传输的安全性</li>
<li>UDP没有，网络拥堵也不会影响发送速率</li>
</ul>
</li>
<li>首部开销<ul>
<li>TCP首部比较长，开销比较大</li>
<li>UDP首部只有8字节且固定不变，开销比较小</li>
</ul>
</li>
<li>传输方式：<ul>
<li>TCP流式传输没有边界，但是保证顺序和可靠</li>
<li>UDP一个包一个包发送，有边界，但是可能丢包或者乱序</li>
</ul>
</li>
<li>分片：<ul>
<li>TCP数据如果大于MSS会在传输层分片，接收端收到会在传输层组装TCP数据包，中途丢失分片只需要重传丢失分片</li>
<li>UDP如果大于MTU会在IP层分片，接收端收到在IP层组装然后给传输层</li>
</ul>
</li>
</ol>
<p>TCP与UDP的应用场景</p>
<ul>
<li>TCP：FTP文件传输，HTTP，HTTPS</li>
<li>包总量比较少的通信：DNS，SNMP等；视频，音频等多媒体；广播通信</li>
</ul>
<h4 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h4><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230534096.png" alt="TCP 头格式"></p>
<p><strong>序列号</strong>：建立连接时生成的随机数作为初始值，通过SYN包传给接收主机，没法送一次就累加数据字节数，用来解决网络包乱序</p>
<p><strong>确认应答号</strong>：下一次期望收到的序列号，发送端收到这个确认应答号就认为在这个序号以前的数据都已经被正常接收，用来解决丢包</p>
<p><strong>控制位</strong>：</p>
<ul>
<li>ACK：为1时，确认应答字段有效，除了最初建立连接的SYN包以外这个位都必须为1</li>
<li>RST：为1时，表示TCP连接中出现异常，必须强制断开连接</li>
<li>SYN：为1时，希望建立连接，并在其序列号字段进行序列号初始值设定</li>
<li>FIN：为1时，表示今后不再有数据发送，希望断开连接。结束通信时双方主机互相交换FIN为1的TCP段</li>
</ul>
<h2 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h2><p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230530102444029.png" alt="image-20230530102444029"></p>
<p>建立连接：三次握手</p>
<ol>
<li>服务端主动监听某个端口，处于LISTEN状态。</li>
<li>客户端随机初始化序列号(client_isn)，把这个序号放在TCP首部序号字段中，同时把SYN标志位设置1，表示SYN报文。然后把第一个SYN报文发送给服务器，表示向服务器发起连接，报文不包含应用层数据，之后客户端处于SYN-SENT状态</li>
<li>服务端收到客户端SYN报文，首先服务端随机初始化自己序号(server_isn)，将这个序号填入TCP首部序号字段，把TCP首部的确认应答号字段填入<code>client_isn+1</code>，接着把SYN和ACK标志都设置为1。接着把报文发送给客户端，也不包含应用层数据，服务端之后处于SYN-RCVD状态</li>
<li>客户端收到服务端报文，向服务端回应最后一个应答报文，应答报文TCP首部ACK标志位置为1，确认应答号填入server_isn+1，最后把报文发送给服务端，并且可以携带客户到服务端的数据，之后客户端就处于ESTABLISHED状态</li>
<li>服务端收到客户端应答报文后也进入ESTABLISHED状态</li>
</ol>
<h4 id="为什么建立连接初始化序列号都要求不同"><a href="#为什么建立连接初始化序列号都要求不同" class="headerlink" title="为什么建立连接初始化序列号都要求不同"></a>为什么建立连接初始化序列号都要求不同</h4><ul>
<li><p>防止历史报文被下一个相同四元组的连接接收</p>
<p>如果网络出现问题重新建立连接，发送的报文可能会被错误的当成之前的报文接收（因为之前的报文还在接收窗口中</p>
</li>
<li><p>为了安全性，防止黑客伪造相同的序列号TCP报文被对方接收</p>
</li>
</ul>
<h4 id="随机序列号ISN的随机产生"><a href="#随机序列号ISN的随机产生" class="headerlink" title="随机序列号ISN的随机产生"></a>随机序列号ISN的随机产生</h4><p>起始ISN基于时钟，根据初始化序列号ISN随机生成算法产生</p>
<h4 id="IP层会分片，为什么TCP还要根据MSS分片"><a href="#IP层会分片，为什么TCP还要根据MSS分片" class="headerlink" title="IP层会分片，为什么TCP还要根据MSS分片"></a>IP层会分片，为什么TCP还要根据MSS分片</h4><p>因为如果没有MSS分片，一个IP分片丢失，整个IP报文所有分片都要重传。IP层没有超时重传机制，要由TCP来负责超时重传，这时候就要重传一整个IP分片</p>
<h4 id="第一次握手丢失"><a href="#第一次握手丢失" class="headerlink" title="第一次握手丢失"></a>第一次握手丢失</h4><p>客户端发送请求连接的SYN报文，迟迟收不到服务端的SYN-ACK，就触发超时重传机制，重传SYN报文序列号相同</p>
<p>Linux客户端的SYN报文最大重传次数由内核参数控制，一般默认5，第一次重传在1s后，第二次2s，第三次4s，第四次8s，第五次16s。在第五次重传后会继续等待32s，依然没有回应ACK就不在发送SYN包，然后断开TCP连接。共1+2+4+8+16+32&#x3D;63s</p>
<h4 id="第二次握手丢失"><a href="#第二次握手丢失" class="headerlink" title="第二次握手丢失"></a>第二次握手丢失</h4><p>服务器收到了客户端建立连接请求（第一次握手），就会发送SYN-ACK，即第二次握手，进入SYN_RCVD状态</p>
<p>目的是</p>
<ul>
<li>ACK是对第一次握手确认</li>
<li>SYN是服务器发起建立连接</li>
</ul>
<p>如果这次丢失了产生的后果：</p>
<ul>
<li>客户端觉得自己第一次握手丢失，会触发超时重传</li>
<li>服务器收不到第三次握手，也会触发超时重传</li>
</ul>
<h4 id="第三次握手丢失"><a href="#第三次握手丢失" class="headerlink" title="第三次握手丢失"></a>第三次握手丢失</h4><p>客户端收到服务器的SYN-ACK报文，会返回一个ACK，也就是第三次握手，进入ESTABLISH</p>
<p>第三次握手报文作用：</p>
<ul>
<li>对第二次握手确认，所以服务器收不到确认以为第二次握手丢失，触发超时重传，长时间没能收到第三次握手，服务器就会断开连接</li>
<li>服务器一直处于SYN_RCVD状态，无法接收客户端的数据</li>
</ul>
<h4 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h4><p>攻击者短时间内伪造不同IP的SYN报文，服务端每收到一个SYN报文就进入SYN_RCVD，但是发出去的ACK+SYN无法收到未知主机的ACK应答。久而久之会占满服务端半连接队列，使服务器无法正常服务。</p>
<p>TCP三次握手时Linux维护的两个队列</p>
<ul>
<li>半连接队列：SYN队列</li>
<li>全连接队列：accept队列</li>
</ul>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230622886.png" alt="正常流程"></p>
<ol>
<li>当服务端收到SYN报文，会创建一个半连接对象，然后将其加入内核的SYN队列</li>
<li>发送SYN+ACK给客户端，等待客户端回应ACK报文</li>
<li>服务端收到ACK，从SYN队列取出一个半连接对象，然后创建一个新连接对象放入Accept队列</li>
<li>通过调用accept() scoket接口，从Accept队列取出连接对象</li>
</ol>
<p>SYN攻击直接表现就是把TCP半连接队列打满，之后收到TCP的SYN报文就会被丢弃，客户端无法和服务端建立连接</p>
<p><strong>避免方法</strong>：</p>
<ul>
<li><p>调大netdev_max_backlog</p>
<p>当网卡接收数据包速度大于内核处理速度，会保存这些数据包，控制队列最大值，默认1000，可以调大这个参数比如10000</p>
</li>
<li><p>增大TCP半连接队列</p>
<p>需要同时增大net.ipv4.tcp_max_syn_backlog，listen()中的backlog，net.core.somaxconn，这三个参数决定了TCP半连接队列大小</p>
</li>
<li><p>开启tcp_syncookies</p>
<p>新的建立连接方式,可以不使用SYN半连接队列,可以通过参数选择关闭,半连接放不下了使用,无条件使用</p>
<p>当SYN队列满之后,服务端受到SYN包不会丢弃,根据算法计算一个cookie值,放到第二次握手序列号回给客户端.服务端收到客户端应答报文会检查ACK包合法性,合法就会放入Accept队列</p>
</li>
<li><p>减少SYN+ACK重传次数</p>
<p>内核默认重传5次,可以设置到2次</p>
</li>
</ul>
<h2 id="连接断开"><a href="#连接断开" class="headerlink" title="连接断开"></a>连接断开</h2><p>四次挥手</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png" alt="客户端主动关闭连接 —— TCP 四次挥手"></p>
<ul>
<li>客户端想关闭连接,发送一个TCP首部FIN为1的报文,即FIN报文,客户端进入FIN_WAIT_1状态(表示我这边没东西发了,可以关闭连接</li>
<li>服务端收到FIN报文,发送ACK应答报文,进入CLOSE_WAIT状态(服务端可能还有数据没发完</li>
<li>客户端收到服务端的ACK,进入FIN_WAIT_2状态</li>
<li>服务端处理完数据,发送FIN报文,进入LAST_ACK状态(我这里东西也发完了</li>
<li>客户端收到服务端的FIN,回一个ACK,进入TIME_WAIT状态</li>
<li>服务端收到ACK报文,进入CLOSE状态,服务端完成连接关闭</li>
<li>客户端经过2MSL,自动进入CLOSE状态</li>
</ul>
<p>为什么要有TIME_WAIT等待2MSL(最大生存时间):防止历史数据(报文中间网络延迟没能到达)被后面的相同四元组接收,保证被动关闭方正确关闭</p>
<h3 id="关闭连接函数"><a href="#关闭连接函数" class="headerlink" title="关闭连接函数"></a>关闭连接函数</h3><ul>
<li>close,同时关闭发送方和读取方,如果socket有多个线程进程共享,一个close只会让引用计数-1,直到为0发出FIN报文</li>
<li>shutdown,指定socket只关闭发送方不关闭读取方,多个进程使用socket,shutdown不管引用计数直接使socket不可用,发出FIN报文</li>
</ul>
<p>客户端用close来关闭连接会比较粗暴,因为客户端没有发送接收能力,内核会发出RST报文,释放连接,不会经过TCP四次握手,如果服务端再发起读或者写,就会报错和异常</p>
<p>shutdown会经历四次握手</p>
<h3 id="四次挥手可以变为三次吗"><a href="#四次挥手可以变为三次吗" class="headerlink" title="四次挥手可以变为三次吗"></a>四次挥手可以变为三次吗</h3><p><img src="https://cdn.xiaolincoding.com//mysql/other/52f35dcbe24a4ca7abb23f292837c707.png" alt="在这里插入图片描述"></p>
<p>服务端在收到FIN后不马上回复ACK,而是等待自己CLOSE_WAIT状态结束数据发送完,一起发送FIN和ACK</p>
<p>什么情况出现三次挥手:</p>
<p><strong>在TCP挥手中,没有数据要发送并且开启了TCP延迟确认机制(默认开启)</strong></p>
<p>TCP延迟确认机制:</p>
<p>发送没有携带数据的ACK效率很低,所以最好把ACK和响应的数据一起发</p>
<ul>
<li>当有数据要发送时,ACK会随着响应数据一起发送给对方</li>
<li>当没有响应数据要发送,ACK会延迟一段时间,来等待有响应数据一起发送</li>
<li>如果等待的时候第二个数据报文又到达了,会立刻发送ACK</li>
</ul>
<h3 id="挥手丢失"><a href="#挥手丢失" class="headerlink" title="挥手丢失"></a>挥手丢失</h3><h4 id="第一次丢失"><a href="#第一次丢失" class="headerlink" title="第一次丢失"></a>第一次丢失</h4><p>因为不会收到ACK,会触发超时重传,一定次数后还没收到会直接进入close状态</p>
<h4 id="第二次丢失"><a href="#第二次丢失" class="headerlink" title="第二次丢失"></a>第二次丢失</h4><p>ACK不会重传,但是客户端一直收不到第一次挥手的ACK,会不断发送FIN报文,客户端会直接close</p>
<h4 id="第三次丢失"><a href="#第三次丢失" class="headerlink" title="第三次丢失"></a>第三次丢失</h4><p>服务端收不到FIN的ACK,会出发超时重传,长时间没有ACK也会直接close</p>
<p>客户端在等待一段时间还没收到FIN也会close</p>
<h4 id="第四次丢失"><a href="#第四次丢失" class="headerlink" title="第四次丢失"></a>第四次丢失</h4><p>第四次丢失,服务端收不到ACK也会超时重传</p>
<h3 id="服务器出现大量TIME-WAIT原因"><a href="#服务器出现大量TIME-WAIT原因" class="headerlink" title="服务器出现大量TIME_WAIT原因"></a>服务器出现大量TIME_WAIT原因</h3><p>TIME_WAIT是主动关闭连接方的状态,说明服务器主动断开了很多TCP连接</p>
<p>场景:</p>
<ul>
<li><p>HTTP没有使用长连接</p>
<p>排查客户端和服务器是不是都开启了HTTP Keep-Alive,有一方没有开启都会让服务器主动关闭连接</p>
</li>
<li><p>HTTP长连接超时</p>
<p>为了防止长连接一直占用,会提供长连接超时时间,大量客户端建立TCP后很长时间没发送数据导致超时,服务端主动关闭连接</p>
</li>
<li><p>HTTP长连接请求数量上限</p>
</li>
</ul>
<h3 id="服务器出现大量CLOSE-WAIT原因"><a href="#服务器出现大量CLOSE-WAIT原因" class="headerlink" title="服务器出现大量CLOSE_WAIT原因"></a>服务器出现大量CLOSE_WAIT原因</h3><p>说明服务端是被动关闭方,并且程序没有调用close函数关闭连接,无法发出FIN报文</p>
<p>一般是代码问题</p>
<h3 id="建立连接后客户端或者服务端崩溃故障"><a href="#建立连接后客户端或者服务端崩溃故障" class="headerlink" title="建立连接后客户端或者服务端崩溃故障"></a>建立连接后客户端或者服务端崩溃故障</h3><p>客户端故障</p>
<p>根据TCP保活机制,一段时间内没有任何连接相关活动,每隔一段时间发送一个探测报文,没有得到响应就认为TCP连接死亡,服务端主动断开连接</p>
<p>服务端崩溃</p>
<p>TCP连接是内核维护的,进程崩溃后,内核会顺利进行四次挥手断开连接</p>
<h2 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h2><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230545997.png" alt="基于 TCP 协议的客户端和服务端工作"></p>
<h2 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h2><p>发送的数据被接收会发出一个确认应答表示已经收到消息,如果丢失了就需要用到重传机制</p>
<h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p>发送数据时计时,一定时间内没有收到ACK就重新发送数据</p>
<p>重传的情况</p>
<ul>
<li>数据包丢失</li>
<li>确认应答丢失</li>
</ul>
<p>超时时间的设置:</p>
<p>根据平滑(平均)RTT和最新RTT</p>
<p>遇到一次超时重传会把下一次的时间间隔设为两倍,再次超时说明环境差,不适合频繁发送</p>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>超时重传的周期比较长</p>
<p>快速重传以数据驱动</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/10.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="快速重传机制"></p>
<p>连续收到三个相同的ACK(表示要的下一个数据),就会马上重传丢失的数据</p>
<p>问题是:</p>
<p>重传一个数据,还是重传之后的所有数据,都会有问题</p>
<h3 id="SACK"><a href="#SACK" class="headerlink" title="SACK"></a>SACK</h3><p>为了解决快重传不知道重传什么数据</p>
<p>SACK:选择性确认</p>
<p>在TCP首部选项字段中添加SACK,可以把已经收到的数据发送给发送方,发送方就可以直到哪些数据收到,哪些没收到,就可以只重传丢失的数据</p>
<h3 id="D-SACK"><a href="#D-SACK" class="headerlink" title="D-SACK"></a>D-SACK</h3><p>使用SACK告诉发送方哪些数据被重复接收</p>
<p>发送方可以通过D-SACK知道</p>
<ul>
<li>是发出去的包丢失还是回应的包丢失</li>
<li>是不是发送方的数据包被网络延迟了</li>
<li>可以知道是不是把发送的数据包复制了</li>
</ul>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>每次收到数据包然后确认再发送下一个数据包的方式效率很低，往返时间越长效率越低，所以TCP引入了窗口概念。</p>
<p>发送方主机在等待确认应答返回前必须在缓冲区保留已发送数据，按期收到应答就清除这个数据。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/15.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="用滑动窗口方式并行处理"></p>
<p>当发送方收到报文，其中ACK就表示这个序列号之前的数据都收到了，叫做累计确认。</p>
<h3 id="窗口大小的确定"><a href="#窗口大小的确定" class="headerlink" title="窗口大小的确定"></a>窗口大小的确定</h3><p>接收端告诉发送端有多少缓冲区接收数据，发送端可以根据这个接收端处理能力发送数据</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/16.jpg" alt="img"></p>
<p>当可用窗口用完，则全被发送窗口占据，即使没有收到ACK也不继续发送数据。当收到ACK，窗口右移，新进入的数据占据可用窗口等待发送</p>
<p>接收窗口</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/20.jpg" alt="接收窗口"></p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>如果发送方发送速度过快，接收方处理不过来，会触发重传机制，导致网络流量无意义浪费</p>
<p>所以TCP要提供一种机制，可以<strong>让发送方根据接收方的实际接受能力控制发送数据量</strong>，这就是流量控制</p>
<p>因为缓存的窗口属于操作系统的缓冲区，如果接收端过于繁忙，操作系统缓冲区会减小，此时应用又无法即使读取缓存数据，造成数据丢包</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/23.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="img"></p>
<p>为了防止这种情况，TCP规定不允许同时减少缓存又收缩窗口，而先收缩窗口，然后减少缓存，避免丢包出现</p>
<h3 id="窗口关闭"><a href="#窗口关闭" class="headerlink" title="窗口关闭"></a>窗口关闭</h3><p>因为接收方会指明希望发送方发送的数据大小（窗口大小）来进行流量控制，如果窗口大小为0，就阻止发送方发送数据，直到窗口变为非0，这就是窗口关闭。</p>
<h4 id="窗口关闭的潜在危险-死锁"><a href="#窗口关闭的潜在危险-死锁" class="headerlink" title="窗口关闭的潜在危险-死锁"></a>窗口关闭的潜在危险-死锁</h4><p>对于窗口大小改变的通知，是通过ACK报文通告</p>
<p>如果窗口关闭后再想要通知窗口非0，重新接收数据。这个报文如果在网络中丢失，发送方一直等待窗口非0的通知来重新发送数据，接收方因为已经通知了窗口非0，也等待接收数据，两边进入互相等待的死锁状态</p>
<p>解决方法</p>
<p>TCP为每个连接设置了一个持续定时器，只要TCP连接一方收到对方0窗口的通知就启动持续计时器，如果计时器超时，就会发送窗口探测报文，接收方返回当前窗口大小</p>
<ul>
<li>如果窗口仍然是0，收到报文的一方重新启动持续计时器</li>
<li>如果不是0，就可以打开死锁的局面</li>
</ul>
<p>总共探测三次，如果3次之后还是0，TCP可能会发出RST报文中断连接</p>
<h3 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h3><p>糊涂窗口综合征：接收方太忙了来不及取走窗口数据，导致发送方发送窗口越来越小。最后接收方只有很少的几个字节告诉发送方，发送方就会把这几个字节发送了。</p>
<p>但是TCP+IP首部开销40字节，如果只发了很少的数据，开销不值得</p>
<p>发生糊涂窗口综合症的原因：</p>
<ul>
<li>接收方会通知小窗口</li>
<li>发送方会发送小数据</li>
</ul>
<p>因此要解决就解决以上问题就可以</p>
<ul>
<li><p>让接收方不通知小窗口</p>
<p>当窗口小于min（MSS（最大报文长度），缓存空间&#x2F;2），小于MSS和1&#x2F;2缓存大小的最小值就会通知窗口为0，防止发送方发送数据。当&gt;&#x3D;MSS或者缓存空间&#x2F;2时，就可以打开窗口让发送方发送数据</p>
</li>
<li><p>让发送方避免发送小数据</p>
<p>Nagle算法：延迟处理，满足以下条件之一才可以发送数据</p>
<ul>
<li>等到窗口大小&gt;&#x3D;MSS且数据大小&gt;&#x3D;MSS</li>
<li>收到之前发送数据的ack回包</li>
</ul>
</li>
</ul>
<p>如果发送方开启了Nagle，接收方不满足不通知小数据也会出现糊涂窗口综合症，因为可能ACK回复比较快。要避免糊涂窗口综合症要满足：不通告小窗口给发送方+发送方开启Nagle算法</p>
<p>Nagle默认开启</p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>拥塞控制和流量控制的区别：</p>
<p>流量控制是为了避免发送方数据太快填满接收方的缓存，对于网络中的情况没有区别</p>
<p>为了解决网络中出现拥堵的情况，造成丢包或者时延导致TCP重传加重负担，因此拥塞控制很有必要</p>
<p>拥塞控制中，为了在发送方调节要发送数据的量，定义了一个拥塞窗口cwnd的概念，根据网络的拥塞程度动态变化</p>
<h3 id="cwnd，swnd，rwnd？"><a href="#cwnd，swnd，rwnd？" class="headerlink" title="cwnd，swnd，rwnd？"></a>cwnd，swnd，rwnd？</h3><p>swnd，rwnd是流量控制中的概念，表示发送窗口和接收窗口，约等于关系</p>
<p>cwnd是拥塞窗口，发送窗口swnd在加入cwnd后，swnd&#x3D;min（cwnd，rwnd）拥塞窗口和接收窗口的最小值</p>
<h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>TCP刚刚建立时，不知道网络环境，因此慢慢提高发送数据包的数值。</p>
<p>发送包每收到一个ACK，cwnd大小就+1</p>
<p>第一次发送1个报文，收到1个ACK后发送2个报文，就会收到2个ACK，发送的报文数量就变为4。因此cwnd在慢启动下是指数级增加</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/27.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="慢启动算法"></p>
<p>上限：慢启动门限（ssthresh）</p>
<p>当cwnd&gt;&#x3D;ssthresh时开启拥塞避免算法</p>
<h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>当拥塞窗口大小大于等于慢启动门限时就会进入拥塞避免算法</p>
<p>通常ssthresh是65535字节</p>
<p>拥塞避免中，每收到1个ACK，cwnd增加1&#x2F;cwnd。也就是当上次发送的数据包都收到ACK才会将cwnd+1</p>
<p>cwnd的增长变为线性了</p>
<p>当网络发生拥塞，出现丢包触发重传机制，进入拥塞发生算法</p>
<h3 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h3><p>出现拥塞，即数据包重传的情况，重传的机制主要有超时重传和快速重传</p>
<h4 id="超时重传-1"><a href="#超时重传-1" class="headerlink" title="超时重传"></a>超时重传</h4><p>超时重传会导致使用拥塞发生算法：</p>
<ul>
<li>ssthresh设为cwnd&#x2F;2</li>
<li>cwnd重置为初始值（假设为1</li>
</ul>
<p>Linux的cwnd初始化值一般为10</p>
<p>在cwnd重置为初始化值后重新开始慢启动。</p>
<p>缺点：</p>
<p>这种方式突然将cwnd剧烈减小会导致减少数据流出现网络卡顿。一旦出现超时重传就初始化cwnd太激进了</p>
<h4 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h4><p>当接收方发现丢失一个中间包（收到了后面的数据包），发送三次之前一个包的ACK，发送端就会快速重传，不必等待超时</p>
<p><strong>ssthresh和cwnd的变化</strong></p>
<ul>
<li>cwnd &#x3D; cwnd&#x2F;2，变为原来一半</li>
<li>ssthresh &#x3D; cwnd，变成减半后的cwnd</li>
<li>进入快恢复算法</li>
</ul>
<h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><p>一般和快重传一起使用，快恢复觉得能收到三个重复ACK，网络没有这么糟糕</p>
<p>快恢复导致cwnd和ssthresh的更新：</p>
<p>快恢复算法：</p>
<ul>
<li>拥塞窗口cwnd &#x3D; ssthresh + 3（因为快重传有三个ACK收到</li>
<li>重传丢失数据包</li>
<li>如果再收到重复ACK，cwnd+1</li>
<li>如果<strong>收到新的ACK</strong>，把cwnd设置第一步中的ssthresh，因为ACK确认新的数据说明恢复的过程结束可以恢复之前状态，再次进入拥塞避免</li>
</ul>
<h2 id="TCP协议缺陷"><a href="#TCP协议缺陷" class="headerlink" title="TCP协议缺陷"></a>TCP协议缺陷</h2><h3 id="升级TCP很困难"><a href="#升级TCP很困难" class="headerlink" title="升级TCP很困难"></a>升级TCP很困难</h3><p>TCP协议在内核中实现，应用程序不能修改，只能升级内核</p>
<p>即使升级内核，TCP协议需要客户端服务端同时支持</p>
<h3 id="TCP建立连接的延迟"><a href="#TCP建立连接的延迟" class="headerlink" title="TCP建立连接的延迟"></a>TCP建立连接的延迟</h3><p>建立连接需要三次握手，大多数网站使用HTTPS，还需要四次TLS握手，增加了数据传输延迟</p>
<p>三此握手可以通过TCP Fast Open解决，在第二次建立连接时减少TCP连接建立的时延</p>
<p>第一次建立连接，服务端在第二次握手产生一个Cookie（已加密），通过SYN，ACK包一起发送给客户端。</p>
<p>第二次连接时候，客户端在SYN包带上Cookie发给服务端，可以提前跳过三次握手过程，Cookie维护了一些信息</p>
<h3 id="TCP存在队头阻塞问题"><a href="#TCP存在队头阻塞问题" class="headerlink" title="TCP存在队头阻塞问题"></a>TCP存在队头阻塞问题</h3><p>TCP要保证数据的有序，如果序号在前的报文丢失，会导致后面大量数据在缓存中无法被内核读取，需要等待丢失报文重传</p>
<p>比如HTTP&#x2F;2中</p>
<h3 id="网络迁移需要重新建立TCP连接"><a href="#网络迁移需要重新建立TCP连接" class="headerlink" title="网络迁移需要重新建立TCP连接"></a>网络迁移需要重新建立TCP连接</h3><p>TCP连接通过四元组确定</p>
<ul>
<li>源地址</li>
<li>源端口</li>
<li>目标地址</li>
<li>目标端口</li>
</ul>
<p>如果从移动网络切换到WIFI，IP变化就必须重新建立连接</p>
<h2 id="如何基于UDP实现可靠传输（QUIC）"><a href="#如何基于UDP实现可靠传输（QUIC）" class="headerlink" title="如何基于UDP实现可靠传输（QUIC）"></a>如何基于UDP实现可靠传输（QUIC）</h2><p>QUIC是目前可基于UDP的可靠传输协议成熟方案</p>
<h3 id="首部信息"><a href="#首部信息" class="headerlink" title="首部信息"></a>首部信息</h3><p>在UDP首部和HTTP消息之间共三层Packet Header，QUIC Frame Header，HTTP3 Frame Header</p>
<h4 id="Packet-Header"><a href="#Packet-Header" class="headerlink" title="Packet Header"></a>Packet Header</h4><p>共有两种，分别用于首次建立连接和日常传输数据</p>
<ul>
<li><p>Long Packet Header</p>
<p>首次建立连接使用，主要内容包括</p>
<ul>
<li>Source Connection ID（源连接ID）</li>
<li>Destination Connection ID（目标链接ID）</li>
</ul>
</li>
<li><p>Short Packet Header</p>
<p>日常传输数据</p>
<ul>
<li>Destination Connection ID（目标链接ID）</li>
<li>Packet Number（编号）</li>
<li>负载数据</li>
</ul>
</li>
</ul>
<p>QUIC建立连接也需要三此握手，目的是协商连接ID，之后双方只需要固定连接ID就可以实现连接迁移。所以在Short Packet Header中不需要使用到源连接ID</p>
<p>Packet Number是报文独一无二的编号，严格递增，即使重传也不是原来相同的编号</p>
<p>带来的好处：</p>
<ul>
<li>可以更加精准计算RTT，避免TCP重传歧义问题</li>
<li>支持乱序确认，TCP必须顺序确认，丢包时导致窗口不滑动</li>
</ul>
<p>对应TCP的问题：重传歧义</p>
<p>重传报文客户端收到重传的报文，无法判断是重传前还是重传后的，从而导致RTT计算的不精准</p>
<p>Packet Number的单调递增设计，还可以让数据包不必像TCP一样必须有序确认，QUIC支持乱序确认，当数据包Packet N丢失，只要有新的数据包确认，滑动窗口可以继续右移</p>
<h4 id="QUIC-Frame-Header"><a href="#QUIC-Frame-Header" class="headerlink" title="QUIC Frame Header"></a>QUIC Frame Header</h4><p>一个Packet报文可以存放多个QUIC Frame</p>
<p>不同的Frame针对不同类型，功能，有不同格式</p>
<p>对于Stream类型的Frame格式包含：</p>
<ul>
<li>Stream ID：多个并发传输的HTTP消息，通过Stream ID区别</li>
<li>Offset：类似TCP的Seq序号，保证数据顺序和可靠</li>
<li>Length：指明Frame数据长度</li>
</ul>
<h3 id="队头阻塞问题"><a href="#队头阻塞问题" class="headerlink" title="队头阻塞问题"></a>队头阻塞问题</h3><p>发生在接收窗口，接收窗口明确的窗口大小，明确接下来收到的数据的序号</p>
<p>当收到有序数据，接收窗口往前滑动，被确认的有序数据被应用层读取。如果某一个数据没有收到，那么即使之后的数据都被收到也无法被应用层读取</p>
<p>QUIC给每个Stream一个独立滑动窗口，某个Stream丢失了一个数据，不会影响其他Stream</p>
<h3 id="流量控制-1"><a href="#流量控制-1" class="headerlink" title="流量控制"></a>流量控制</h3><p>QUIC的流量控制实现方式：</p>
<ul>
<li>通过window_update帧告诉对方自己可以接收的字节数</li>
<li>通过BlockFrame告诉对方由于流量控制被阻塞，无法发送数据</li>
</ul>
<p>可以有Stream级和Connection级</p>
<ul>
<li>Stream级：Stream分别独立，给每个Stream流量控制，防止单个Stream消耗连接全部缓冲</li>
<li>Connection级：限制连接中所有Stream相加的总字节数，防止发送方超过连接的缓冲容量</li>
</ul>
<h3 id="拥塞控制-1"><a href="#拥塞控制-1" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>默认使用TCP的Cubic拥塞控制算法（慢开始，拥塞避免，快重传，快恢复），还支持其他很多的拥塞控制算法</p>
<p>QUIC属于应用层，这里的实现不需要操作系统和内核，可以很快的迭代速度更新拥塞控制算法</p>
<h2 id="使用TCP一定不会丢失数据吗"><a href="#使用TCP一定不会丢失数据吗" class="headerlink" title="使用TCP一定不会丢失数据吗"></a>使用TCP一定不会丢失数据吗</h2><p>各种丢包都有可能导致数据丢失</p>
<h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><h2 id="基本认识-1"><a href="#基本认识-1" class="headerlink" title="基本认识"></a>基本认识</h2><p>网络层的作用：实现主机与主机之间的通信（点对点通信）</p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP v4使用32位正整数表示IP地址，根据网卡给每个设备分配IP地址，如果设备有多个网卡就有多个地址</p>
<h3 id="地址分类"><a href="#地址分类" class="headerlink" title="地址分类"></a>地址分类</h3><p>分为五类：</p>
<p>主机数记得减去全0表示本主机和全1表示所有主机的两个</p>
<ul>
<li><p>A类地址：0开头，第2-8位表示网络号，后24位表示主机号</p>
<ul>
<li>网络号范围：0.0.0.0-127.255.255.255</li>
<li>最大主机数：16777214</li>
</ul>
</li>
<li><p>B类地址：10开头，3-16位表示网络号，后16位表示主机号</p>
<ul>
<li>网络号范围：128.0.0.0–191.255.255.255</li>
<li>最大主机数：65535</li>
</ul>
</li>
<li><p>C类地址：110开头，4-24位表示网络号，后8位表示主机号</p>
<ul>
<li>网络号范围：192.0.0.0-223.255.255.255</li>
<li>最大主机数：254</li>
</ul>
</li>
<li><p>D类地址：1110开头，后28位为组播地址</p>
<p>无主机号，常用作IP多播，将包发送给特定组内所有主机</p>
</li>
<li><p>E类地址：</p>
<p>预留分类，暂未使用</p>
</li>
</ul>
<h3 id="分类缺点"><a href="#分类缺点" class="headerlink" title="分类缺点"></a>分类缺点</h3><ul>
<li>同一网络下没有地址层次，比如某公司分配到了B类地址，做不到对下面的环境划分地址层次，缺少地址灵活性</li>
<li>不能很好实现网络匹配。C类地址主机数太少而B类地址又可能太多了</li>
</ul>
<p>因此为了解决，提出了无分类地址方案</p>
<h3 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h3><p>无分类地址方案，不再有分类地址概念，32位IP地址被自由划分成网络号和主机号</p>
<p>表示形式：<code>a.b.c.d/x</code>，后面的&#x2F;x表示前面有几位是网络号</p>
<h4 id="子网掩码也是一种划分网络号和主机的形式"><a href="#子网掩码也是一种划分网络号和主机的形式" class="headerlink" title="子网掩码也是一种划分网络号和主机的形式"></a>子网掩码也是一种划分网络号和主机的形式</h4><p>用子网掩码遮掉主机号，剩下网络号。将子网掩码和IP地址按位与计算</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/16.jpg" alt="img"></p>
<h4 id="为什么分离主机号和网络号"><a href="#为什么分离主机号和网络号" class="headerlink" title="为什么分离主机号和网络号"></a>为什么分离主机号和网络号</h4><p>主机间通讯要先判断是否在一个广播域，也就是网络地址是否相同，如果网络地址相同就直接转发</p>
<h4 id="子网掩码的另一个作用：划分子网"><a href="#子网掩码的另一个作用：划分子网" class="headerlink" title="子网掩码的另一个作用：划分子网"></a>子网掩码的另一个作用：划分子网</h4><p>经过子网划分，可以将IP地址变成：网络号+子网号+主机号。来满足想要对主机的不同分类的需求</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/19.jpg" alt="img"></p>
<h3 id="IP地址和路由控制"><a href="#IP地址和路由控制" class="headerlink" title="IP地址和路由控制"></a>IP地址和路由控制</h3><p>网络地址部分用于路由控制，路由器的路由寻址就是寻找与该地址有相同网络地址的记录（没有就转发给默认路由</p>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>IPv4在2011年就已经分配完了。</p>
<p>IPv6共有128位，可分配数量更多，其他优点还有：</p>
<ul>
<li>IPv6可以自动配置，没有DHCP服务器也可以自动分配IP地址，即插即用</li>
<li>包头首部长度固定40字节，去掉了包头校验和，简化首部结构，减轻路由器负荷，提高传输性能</li>
<li>有应对伪造IP地址的网络安全功能和防止线路窃听的功能，提升了安全性</li>
<li>等等</li>
</ul>
<p>IPv6的128位，每16位一组用<code>:</code>分开，如果连续的0可以省略用<code>::</code>隔开</p>
<h2 id="IP协议相关"><a href="#IP协议相关" class="headerlink" title="IP协议相关"></a>IP协议相关</h2><h3 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h3><p>将域名转换为具体的IP地址，域名解析流程：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/33.jpg" alt="域名解析的工作流程"></p>
<h3 id="ARP和RARP"><a href="#ARP和RARP" class="headerlink" title="ARP和RARP"></a>ARP和RARP</h3><p>ARP协议：将IP地址解析成MAC地址</p>
<p>ARP解析流程：</p>
<ol>
<li>主机通过广播发送ARP请求，包含想知道的MAC地址的主机IP地址</li>
<li>同一链路所有设备收到ARP请求，会查看IP地址是否与自己一致，如果一致就将自己的MAC地址塞入ARP响应包返回给主机</li>
</ol>
<p>操作系统会将通过ARP获取的MAC地址缓存一定时间，方便下次直接读取</p>
<p>RARP：将MAC转为IP地址</p>
<p>比如将打印机服务器等小型嵌入式设备接入网络需要用到</p>
<p>过程：</p>
<ol>
<li>该设备发送一条包含自己MAC地址的报文请求自己的IP地址</li>
<li>RARP服务器收到后返回给它对应的IP地址</li>
<li>该设备根据这个应答信息设置自己IP地址</li>
</ol>
<h3 id="DHCP动态获取IP地址"><a href="#DHCP动态获取IP地址" class="headerlink" title="DHCP动态获取IP地址"></a>DHCP动态获取IP地址</h3><p>DHCP客户端进程监听68端口，服务端监听67端口</p>
<p>流程：</p>
<ol>
<li>客户端发起DHCP发现报文，由于客户端没有IP地址，也不知道DHCP服务器地址，所以使用UDP广播通信，链路层将帧广播到网络中所有设备</li>
<li>DHCP服务器收到DHCP发现报文，使用DHCP提供报文向客户端响应，携带提供可租约的IP地址，子网掩码，默认网关，DNS服务器和IP地址租用期</li>
<li>客户端收到一个或者多个服务器的DHCP提供报文后，从中选择一个服务器，并向选中的服务器发送DHCP请求报文进行响应，回显配置参数</li>
<li>服务端用DHCP报文对DHCP请求报文进行响应，应答要求的参数</li>
</ol>
<p>当租约的DHCP的IP地址快到期时，客户端会向服务器发送DHCP请求报文</p>
<ul>
<li>如果服务器同意继续租用，用DHCP ACK报文应答，客户端就会延长租期</li>
<li>如果服务器不同意，用DHCP NACK报文，客户端停止使用租约的IP</li>
</ul>
<p>DHCP全程使用UDP广播通信</p>
<p>因为不一定每个局域网都有DHCP服务器，所以出现了DHCP中继代理，对不同网段的IP地址分配也使用一个DHCP服务器统一管理</p>
<h3 id="NAT网络地址转换"><a href="#NAT网络地址转换" class="headerlink" title="NAT网络地址转换"></a>NAT网络地址转换</h3><p>网络地址转换NAT，可以进一步缓解IPv4地址耗尽的问题</p>
<p>可以通过NAT将内部的私有IP转换成公有IP</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/39.jpg" alt="NAPT"></p>
<p>不同内网私有主机IP的转成公网Ip的不同端口号</p>
<h3 id="ICMP互联网控制报文协议"><a href="#ICMP互联网控制报文协议" class="headerlink" title="ICMP互联网控制报文协议"></a>ICMP互联网控制报文协议</h3><p>主要功能：</p>
<ul>
<li>确认IP包是否成功送达目的地址</li>
<li>报告发送过程中IP包被废弃原因</li>
<li>改善网络设置</li>
</ul>
<h3 id="IGMP因特网组管理协议"><a href="#IGMP因特网组管理协议" class="headerlink" title="IGMP因特网组管理协议"></a>IGMP因特网组管理协议</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" data-id="clix3qjvw000pqwue7w0gb93k" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-管理平台笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/15/%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2023-06-15T12:12:02.290Z" itemprop="datePublished">2023-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="验证码生成"><a href="#验证码生成" class="headerlink" title="验证码生成"></a>验证码生成</h1><p>对于结果先生成一个AjaxResult对象，过程中添加要返回的内容</p>
<p>生成验证码的答案要存入Redis，前端提交之后后端在redis中取出比较。key要使用前缀+UUID存储，所以要先生成UUID并和图片一起返回，使用kaptcha生成验证码。先生成表达式，答案前用@隔开，用@前的表达式生成图片，@后的结果存入缓存，并设置缓存TTL。</p>
<p>图片要用二进制传输，定义一个FastByteArrayOutputStream，使用Javax包的ImageIO.write()输出，三个参数，图片，格式，IO流（FastByteArrayOutputStream)</p>
<h2 id="FastByteArrayOutputStream"><a href="#FastByteArrayOutputStream" class="headerlink" title="FastByteArrayOutputStream"></a>FastByteArrayOutputStream</h2><p>性能版的ByteArrayOutputStream，继承OutputStream</p>
<p>字节流，捕获缓冲区数据转换成字节数组</p>
<p>性能高：写入数据，不会扩充byte[]，而是向Deque增加byte[]，byte[]每次扩充一倍，所以最后会有一定性能浪费</p>
<h1 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h1><p>总共三步</p>
<ol>
<li><p>校验验证码</p>
<p>根据UUID去redis查询对比</p>
</li>
<li><p>用户验证</p>
<p>使用Spring security</p>
<p>将认证结果赋给Authentication对象</p>
<p>将用户名密码先传入UsernamePasswordAuthenticationToken对象，并将这个对象传入AuthenticationContextHolder，使用AuthenticationManager来验证用户信息返回给Authentication对象</p>
<p>后面用到的用户要从principal中取authentication.getPrincipal()</p>
</li>
<li><p>生成token</p>
<p>将用户信息打包使用tokenService.createToken(loginUser)生成token，用map记录字段名和token写到User中</p>
</li>
</ol>
<h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><p>架构：</p>
<h3 id="SecurityContextHolder"><a href="#SecurityContextHolder" class="headerlink" title="SecurityContextHolder"></a>SecurityContextHolder</h3><p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230531210946664.png" alt="image-20230531210946664"></p>
<p>Spring Security会把用户信息存放在SecurityContextHolder中，结构如上。</p>
<p>Authentication作用：</p>
<ul>
<li>作为后续验证的入参</li>
<li>获取当前验证通过的用户信息</li>
</ul>
<p>三个属性</p>
<ul>
<li>Principal：用户身份，如果是用户名&#x2F;密码的认证，这里就是UserDetails实例</li>
<li>Credentials：通常是密码，大多数情况下用户验证通过就会清除，防止泄露</li>
<li>Authorities：用户权限</li>
</ul>
<h3 id="AuthenticationManager"><a href="#AuthenticationManager" class="headerlink" title="AuthenticationManager"></a>AuthenticationManager</h3><p><img src="https://img-blog.csdnimg.cn/20200426143948937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaXdsMTk4OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>AuthenticationManager用于实现身份认证的API接口，入参Authentication，常用其子类ProviderManager</li>
<li>AuthenticationProvider是某种具体认证实现，DaoAuthenticationProvider用于实现用户名密码认证，JwtAuthenticationProvider用于JWT token认证</li>
<li>支持多种类型的AuthenticationProvider会注入到ProviderManager，根据Authentication类型调用相应的AuthenticationProvider</li>
</ul>
<h3 id="AbstractAuthenticationProcessingFilter"><a href="#AbstractAuthenticationProcessingFilter" class="headerlink" title="AbstractAuthenticationProcessingFilter"></a>AbstractAuthenticationProcessingFilter</h3><p><img src="https://img-blog.csdnimg.cn/20200426144055173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhaXdsMTk4OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>用于身份认证的过滤器，对于认证成功或者失败做出对应操作</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>使用异步日志写入数据库的方式</p>
<p>framwork里面写好了异步工厂recordLogininfor方法，在日志中记录访客信息，包括操作系统，浏览器，用户信息，日志内容</p>
<h2 id="getInfo"><a href="#getInfo" class="headerlink" title="getInfo"></a>getInfo</h2><p>用户登录的请求，前端还生成了两个请求，分别是getInfo和getRouters</p>
<p>getInfo中获取了用户信息和用户权限信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 角色集合</span></span><br><span class="line">Set&lt;String&gt; roles = permissionService.getRolePermission(user);</span><br><span class="line"><span class="comment">// 权限集合</span></span><br><span class="line">Set&lt;String&gt; permissions = permissionService.getMenuPermission(user);</span><br></pre></td></tr></table></figure>

<p>admin权限：<code>*:*:*</code></p>
<h2 id="getRouters"><a href="#getRouters" class="headerlink" title="getRouters"></a>getRouters</h2><p>根据当前用户权限获取动态路由，也就是菜单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SecurityUtils是写在common模块里面的安全服务工具类，封装了Spring Security的操作</span></span><br><span class="line"><span class="comment">//调用getAuthentication().getPrincipal()获取用户信息后再获取userId</span></span><br><span class="line"><span class="comment">//Authentication保存了用户的信息，密码，权限，获取principal来获取到用户信息</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> SecurityUtils.getUserId();</span><br><span class="line"><span class="comment">//这里注入了menuService，其中封装了业务层关于菜单的处理</span></span><br><span class="line"><span class="comment">//selectMenuTreeByUserId(userId)会根据用户ID来返回菜单树，先判断用户权限分为管理员或者其他的，因为返回的内容不同分别调用的SQL语句也不同，查询sys_menu中当前用户权限菜单的所有信息</span></span><br><span class="line"><span class="comment">//查询结果返回给getChildPerms来组装层级关系</span></span><br><span class="line">List&lt;SysMenu&gt; menus = menuService.selectMenuTreeByUserId(userId);</span><br><span class="line"><span class="comment">//build Menue，逐个读取Menue，给Routers根据这些内容来构建最后返回</span></span><br><span class="line"><span class="keyword">return</span> AjaxResult.success(menuService.buildMenus(menus));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据父节点的ID获取所有子节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list     分类表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parentId 传入的父节点ID</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//输入的t从0开始，表示从父节点为0的节点开始</span></span><br><span class="line"><span class="keyword">public</span> List&lt;SysMenu&gt; <span class="title function_">getChildPerms</span><span class="params">(List&lt;SysMenu&gt; list, <span class="type">int</span> parentId)</span> &#123;</span><br><span class="line">    List&lt;SysMenu&gt; returnList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;SysMenu&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;SysMenu&gt; iterator = list.iterator(); iterator.hasNext(); ) &#123;</span><br><span class="line">        <span class="type">SysMenu</span> <span class="variable">t</span> <span class="operator">=</span> (SysMenu) iterator.next();</span><br><span class="line">        <span class="comment">// 一、根据传入的某个父节点ID,遍历该父节点的所有子节点</span></span><br><span class="line">        <span class="keyword">if</span> (t.getParentId() == parentId) &#123;</span><br><span class="line">            recursionFn(list, t);</span><br><span class="line">            returnList.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnList;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">recursionFn</span><span class="params">(List&lt;SysMenu&gt; list, SysMenu t)</span> &#123;</span><br><span class="line">    <span class="comment">// 得到子节点列表</span></span><br><span class="line">    List&lt;SysMenu&gt; childList = getChildList(list, t);</span><br><span class="line">    t.setChildren(childList);</span><br><span class="line">    <span class="keyword">for</span> (SysMenu tChild : childList) &#123;</span><br><span class="line">        <span class="comment">//递归结束判断</span></span><br><span class="line">        <span class="keyword">if</span> (hasChild(list, tChild)) &#123;</span><br><span class="line">            recursionFn(list, tChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到子节点列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;SysMenu&gt; <span class="title function_">getChildList</span><span class="params">(List&lt;SysMenu&gt; list, SysMenu t)</span> &#123;</span><br><span class="line">    List&lt;SysMenu&gt; tlist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;SysMenu&gt;();</span><br><span class="line">    Iterator&lt;SysMenu&gt; it = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="type">SysMenu</span> <span class="variable">n</span> <span class="operator">=</span> (SysMenu) it.next();</span><br><span class="line">        <span class="keyword">if</span> (n.getParentId().longValue() == t.getMenuId().longValue()) &#123;</span><br><span class="line">            tlist.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tlist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面查询的菜单信息的数据库示例：</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230603203839500.png" alt="image-20230603203839500"></p>
<ul>
<li>其中parent_id表示父菜单ID，0表示没有父菜单</li>
<li>component表示点击页面的重定向的页面</li>
</ul>
<h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><p>打开页面调用三个请求</p>
<p>getList，getTreeselect，getConfigkey</p>
<h2 id="getList"><a href="#getList" class="headerlink" title="getList"></a>getList</h2><p>获取用户列表（分页），调用&#x2F;system&#x2F;user&#x2F;list的get请求</p>
<p>定位到controller</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取用户列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//spring security判断权限</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;@ss.hasPermi(&#x27;system:user:list&#x27;)&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> TableDataInfo <span class="title function_">list</span><span class="params">(SysUser user)</span> &#123;</span><br><span class="line">    <span class="comment">//分页，使用pagehelper+mybatis</span></span><br><span class="line">    startPage();</span><br><span class="line">    List&lt;SysUser&gt; list = userService.selectUserList(user);</span><br><span class="line">    <span class="keyword">return</span> getDataTable(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 响应请求分页数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span></span><br><span class="line"><span class="keyword">protected</span> TableDataInfo <span class="title function_">getDataTable</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line">    <span class="comment">//TableDataInfo是表格分页数据对象</span></span><br><span class="line">    <span class="type">TableDataInfo</span> <span class="variable">rspData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TableDataInfo</span>();</span><br><span class="line">    rspData.setCode(HttpStatus.SUCCESS);</span><br><span class="line">    rspData.setMsg(<span class="string">&quot;查询成功&quot;</span>);</span><br><span class="line">    rspData.setRows(list);</span><br><span class="line">    rspData.setTotal(<span class="keyword">new</span> <span class="title class_">PageInfo</span>(list).getTotal());</span><br><span class="line">    <span class="keyword">return</span> rspData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>权限判断通过ss(也是一个Bean)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;ss&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PermissionService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有权限标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ALL_PERMISSION</span> <span class="operator">=</span> <span class="string">&quot;*:*:*&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 管理员角色权限标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SUPER_ADMIN</span> <span class="operator">=</span> <span class="string">&quot;admin&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ROLE_DELIMETER</span> <span class="operator">=</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PERMISSION_DELIMETER</span> <span class="operator">=</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证用户是否具备某权限</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> permission 权限字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户是否具备某权限</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPermi</span><span class="params">(String permission)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(permission)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> SecurityUtils.getLoginUser();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNull(loginUser) || CollectionUtils.isEmpty(loginUser.getPermissions())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PermissionContextHolder.setContext(permission);</span><br><span class="line">        <span class="keyword">return</span> hasPermissions(loginUser.getPermissions(), permission);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分页通过startPage完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用</span></span><br><span class="line">PageUtils.startPage();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageUtils</span> <span class="keyword">extends</span> <span class="title class_">PageHelper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置请求分页数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startPage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">PageDomain</span> <span class="variable">pageDomain</span> <span class="operator">=</span> TableSupport.buildPageRequest();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">pageNum</span> <span class="operator">=</span> pageDomain.getPageNum();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">pageSize</span> <span class="operator">=</span> pageDomain.getPageSize();</span><br><span class="line">        <span class="type">String</span> <span class="variable">orderBy</span> <span class="operator">=</span> SqlUtil.escapeOrderBySql(pageDomain.getOrderBy());</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">reasonable</span> <span class="operator">=</span> pageDomain.getReasonable();</span><br><span class="line">        PageHelper.startPage(pageNum, pageSize, orderBy).setReasonable(reasonable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清理分页的线程变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clearPage</span><span class="params">()</span> &#123;</span><br><span class="line">        PageHelper.clearPage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TableSupport存了分页的设置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TableSupport</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前记录起始索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PAGE_NUM</span> <span class="operator">=</span> <span class="string">&quot;current&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每页显示记录数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PAGE_SIZE</span> <span class="operator">=</span> <span class="string">&quot;pageSize&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ORDER_BY_COLUMN</span> <span class="operator">=</span> <span class="string">&quot;orderByColumn&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序的方向 &quot;desc&quot; 或者 &quot;asc&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">IS_ASC</span> <span class="operator">=</span> <span class="string">&quot;isAsc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页参数合理化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REASONABLE</span> <span class="operator">=</span> <span class="string">&quot;reasonable&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PageDomain <span class="title function_">getPageDomain</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">PageDomain</span> <span class="variable">pageDomain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageDomain</span>();</span><br><span class="line">        pageDomain.setPageNum(Convert.toInt(ServletUtils.getParameter(PAGE_NUM), <span class="number">1</span>));</span><br><span class="line">        pageDomain.setPageSize(Convert.toInt(ServletUtils.getParameter(PAGE_SIZE), <span class="number">10</span>));</span><br><span class="line">        pageDomain.setOrderByColumn(ServletUtils.getParameter(ORDER_BY_COLUMN));</span><br><span class="line">        pageDomain.setIsAsc(ServletUtils.getParameter(IS_ASC));</span><br><span class="line">        pageDomain.setReasonable(ServletUtils.getParameterToBool(REASONABLE));</span><br><span class="line">        <span class="keyword">return</span> pageDomain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PageDomain <span class="title function_">buildPageRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPageDomain();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="getTreeselect"><a href="#getTreeselect" class="headerlink" title="getTreeselect"></a>getTreeselect</h2><p>获取公司树状结构信息</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/15/%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E7%AC%94%E8%AE%B0/" data-id="clix3qjvw000qqwue7l597cop" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-点评项目笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/15/%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2023-06-15T12:12:02.287Z" itemprop="datePublished">2023-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="点评项目笔记"><a href="#点评项目笔记" class="headerlink" title="点评项目笔记"></a>点评项目笔记</h1><h2 id="短信登陆"><a href="#短信登陆" class="headerlink" title="短信登陆"></a>短信登陆</h2><p>功能1：提交手机号生成验证码，保存并发送</p>
<p>功能2：提交手机号，验证码。校验验证码，查询手机号对应用户是否存在，不存在创建新用户</p>
<p>功能3：校验登陆状态，不存在拦截，存在保存用户到ThreadLocal（线程的局部变量）</p>
<p>拦截用户：</p>
<p>设置登录拦截器，对于需要用户登录才能访问的路径连接，配置拦截器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.判断是否需要拦截（ThreadLocal中是否有用户）</span></span><br><span class="line">        <span class="keyword">if</span> (UserHolder.getUser() == <span class="literal">null</span>) &#123;</span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UserHolder</code>类定义了<code>static final</code>的ThreadLocal对象存放用户信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(UserDTO user)</span>&#123;</span><br><span class="line">        tl.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDTO <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记得在MVC的配置类添加拦截器,order用于定义执行顺序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span>  StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//登录校验，排除不需要登录的路径</span></span><br><span class="line">        <span class="comment">//order设置拦截器先后顺序</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;upload/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">                ).order(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//刷新token的拦截器，拦截一切路径，详情看下面使用redis存储</span></span><br><span class="line">        registry.addInterceptor(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).addPathPatterns(<span class="string">&quot;/**&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Session共享用户信息"><a href="#Session共享用户信息" class="headerlink" title="Session共享用户信息"></a>Session共享用户信息</h3><p>session是服务器给每个浏览器创建一个session对象，称为会话控制。Session实现指将用户信息以及验证码等保存在session中。通过请求并携带session可以获取用户</p>
<p>存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.setAttribute(<span class="string">&quot;code&quot;</span>,code);</span><br></pre></td></tr></table></figure>

<p>取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">cacheCode</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>但是session在集群中有共享问题</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230327104226736.png" alt="image-20230327104226736"></p>
<h3 id="Redis保存用户信息"><a href="#Redis保存用户信息" class="headerlink" title="Redis保存用户信息"></a>Redis保存用户信息</h3><p>好处：Redis基于内存，读写快。多台服务器访问同一个Redis，数据共享。Redis集群数据内部一致性。</p>
<ol>
<li>手机号-验证码对应，设置ttl，过时删除</li>
<li>用户信息：脱敏性和唯一性因此使用Hash。key使用UUID生成随机token，Value存放用户的信息</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//7.保存用户信息到redis中</span></span><br><span class="line"><span class="comment">//7.1生成随机token</span></span><br><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"><span class="comment">//7.2User对象转为Hash存储</span></span><br><span class="line"><span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">        CopyOptions.create()</span><br><span class="line">                .setIgnoreNullValue(<span class="literal">true</span>).setFieldValueEditor((filedName, filedValue) -&gt; filedValue.toString()));</span><br><span class="line"><span class="comment">//7.3存储</span></span><br><span class="line"><span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">stringRedisTemplate.opsForHash().putAll(tokenKey,userMap);</span><br><span class="line">stringRedisTemplate.expire(tokenKey,LOGIN_USER_TTL,TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>

<p>拦截器问题：</p>
<p>每次访问都要刷新token有效期，防止token失效</p>
<p>思路：设置拦截一切路径的拦截器，获取token查询用户保存到ThreadLocal的UserHodler，刷新有效期</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.LOGIN_USER_KEY + token;</span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(key);</span><br><span class="line">        <span class="keyword">if</span> (userMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line">        stringRedisTemplate.expire(key, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//移除用户</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="商户缓存"><a href="#商户缓存" class="headerlink" title="商户缓存"></a>商户缓存</h2><p>使用缓存作为数据交换缓冲区，降低后端负载，提高读写效率。</p>
<h3 id="缓存更新策略："><a href="#缓存更新策略：" class="headerlink" title="缓存更新策略："></a>缓存更新策略：</h3><ul>
<li>内存淘汰：不自己维护，利用Redis内存淘汰机制，内存不足自动淘汰部分数据</li>
<li>超时剔除：给缓存添加TTL时间，到期自动删除，下次查询时更新TTL</li>
<li>主动更新：编写逻辑，修改数据库同时更新缓存（高一致性需求）</li>
</ul>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230328104147841.png" alt="image-20230328104147841"></p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230328104933028.png" alt="image-20230328104933028"></p>
<p>要考虑的问题：</p>
<ul>
<li>如何保证缓存和数据库操作同时成功失败</li>
<li>更新缓存还是删除缓存（更新缓存会有很大的线程安全问题）：当数据库数据多次发生变化，这期间没有请求访问数据库，那么更新缓存只有最后一次有效，这个时候应该删除缓存。当有请求访问的时候再重建缓存</li>
<li>对缓存和数据库操作先后顺序（线程安全问题）：先操作数据库后重建缓存。因为先删除缓存再操作数据库期间，有读取缓存请求未命中会去查询数据库重建缓存，而这时候可能数据库修改还没完成。当数据修改完后有新请求访问，缓存中有，读的就是缓存的脏数据了。</li>
<li>如何保证数据库和缓存操作原子性（事务机制）：使用事务</li>
</ul>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230328103928766.png" alt="image-20230328103928766"></p>
<p>右边情况，写缓存的时间比较短，发生的概率比较小。选择右边的先操作数据库再删除缓存</p>
<h3 id="缓存穿透，雪崩和击穿"><a href="#缓存穿透，雪崩和击穿" class="headerlink" title="缓存穿透，雪崩和击穿"></a>缓存穿透，雪崩和击穿</h3><p>见<a href="C:\Users\Bubble\Desktop\note\Redis缓存问题-穿透雪崩击穿.md">笔记</a></p>
<h2 id="优惠券秒杀（重点）"><a href="#优惠券秒杀（重点）" class="headerlink" title="优惠券秒杀（重点）"></a>优惠券秒杀（重点）</h2><h3 id="全局唯一id"><a href="#全局唯一id" class="headerlink" title="全局唯一id"></a>全局唯一id</h3><p>抢优惠券时一个订单对应一个ID，在高并发情况下需要保证ID的特点：</p>
<ul>
<li>唯一性</li>
<li>高可用：生成速度快</li>
<li>递增：有利于数据库建立索引</li>
</ul>
<p>本项目的方法生成ID：第一位符号位永远为0，后面31位时间戳，后32位使用Redis的incr自增函数生成。因此可以满足同一秒2^32位不同ID.</p>
<p>key：业务名：日期</p>
<h3 id="库存超卖问题"><a href="#库存超卖问题" class="headerlink" title="库存超卖问题"></a>库存超卖问题</h3><p>在高并发环境下，很多请求查询库存，得到有库存可以获取的判断，开始下单操作</p>
<p><strong>解决方案：</strong></p>
<ul>
<li>乐观锁：更新库存时候判断是否和查询一样，如果一样就说明没被修改，如果不一样则回滚</li>
<li>悲观锁：下单业务上使用sync关键字，使秒杀业务变成串行，严重影响性能</li>
</ul>
<p><strong>乐观锁带来的问题：</strong></p>
<p>如果同时有大量线程进行操作，此时一个线程成功会导致其他所有线程失败。比如100件商品同时只有1件卖出，在库存充足的情况下判断库存不足。</p>
<p>进一步我们在使用乐观锁时需要使用版本号（这里是库存）。判断库存是否一致时还要判断库存是否充足，不为空则可以顺利进行</p>
<h3 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h3><p>线程安全问题，如果两个线程的用户是同一个，在线程1判断是否具有购买资格还没下单时，线程2也得到时间片判断是否具有资格，此时还没下单就还有资格就执行下单操作，之后线程1也执行下单操作。</p>
<p><strong>解决方案：</strong></p>
<p>因为不是更新数据无法获取版本号，只能使用悲观锁。需要将锁加载判断用户资格和创建订单逻辑上。此时遇到<a href="C:\Users\Bubble\Desktop\note\Spring事务失效问题.md">Spring事务失效问题</a>。关于Synchronized关键字添加位置和效果可以查看<a href="C:\Users\Bubble\Desktop\note\Synchronized关键字的用法.md">这里</a></p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>以上的悲观锁解决方法在集群环境下不适用。原因是在集群环境下，每个服务器都是一个独立JVM，线程之间在同一个服务器可以被sync锁互斥，不在同一个服务器的不同JVM之间无法共享依旧并发进行。</p>
<p><strong>解决方法：</strong></p>
<p>使用Redis实现分布式锁：</p>
<ul>
<li><p>利用setnx命令获取锁</p>
<ul>
<li>只有不存在才创建，已存在不能获取，使用完删除</li>
<li>多线程只有一个执行返回true，满足互斥性</li>
<li>设置TTL，防止出现故障无法释放导致死锁问题</li>
<li>利用Redis集群提升可用性</li>
</ul>
</li>
<li><p>释放锁需要判断当前锁是否是自己的，只有当前锁是自己才删除</p>
<ul>
<li>设想情况：线程获取互斥锁，但是业务发生阻塞，导致锁超时自动释放，之后的其他线程获取到锁进行执行</li>
</ul>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230329095201338.png" alt="image-20230329095201338"></p>
</li>
<li><p>删除锁需要保证原子性（判断锁是否是自己的和删除操作）</p>
<p>因为在判断锁之后删除时也有概率发生阻塞导致线程安全问题</p>
<ul>
<li>使用lua脚本来实现多条指令原子性</li>
</ul>
</li>
</ul>
<p><strong>Value问题</strong></p>
<p>锁的Value中保存UUID和线程ID，UUID是为了在集群环境下出现同样线程ID用于区别。</p>
<p><strong>可重入锁</strong></p>
<p>上面的锁不具备可重入功能，同一个线程也不能再次获取到锁。可以通过Hash实现可重入锁，使用threadId作为value中的key，每次记录获取次数。释放锁时检查获取次数，如果-1后是0则释放。</p>
<p><strong>Redisson</strong></p>
<p>分布式锁：</p>
<ul>
<li>使用Hash结构实现重入</li>
<li>利用看门狗机制(自动更新获取锁时间)实现续期</li>
<li>使用信号量控制(订阅锁消息)锁重试</li>
</ul>
<p><strong>MutiLock</strong></p>
<p>问题：在集群下，只有主节点可以进行写。线程在主节点上获取了锁写入，此时redis主节点宕机，信息还没更新到从节点。哨兵机制会选择一个新的主机作为主节点，但是此时锁信息没有保存失效了，造成线程安全问题。</p>
<p>解决方法：</p>
<p>使用Redisson的MutiLock，将所有节点视为同一地位，获取锁要分别从3个Redis节点中获取，只有三个节点都写入成功才能获取到锁</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h2 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h2><p>要求：一个人给一个博客只能点一次赞，已点赞再次点机会取消点赞。前端还要显示最近点赞数名用户。</p>
<p>实现：使用ScortedSet按照博客ID存放点赞信息，score为点赞时间</p>
<h2 id="好友关注"><a href="#好友关注" class="headerlink" title="好友关注"></a>好友关注</h2><p>多对多的问题，需要中间表来保存映射关系，保存谁关注了谁。</p>
<p>共同关注：使用Set集合求交集运算</p>
<h2 id="关注消息推送"><a href="#关注消息推送" class="headerlink" title="关注消息推送"></a>关注消息推送</h2><h3 id="Feed流两种常见模式："><a href="#Feed流两种常见模式：" class="headerlink" title="Feed流两种常见模式："></a>Feed流两种常见模式：</h3><ul>
<li>Timeline：不做内容筛选，简单按照内容发布时间排序，常用于好友或者关注，比如朋友圈<ul>
<li>优点：信息全面，不会缺失，实现简单</li>
<li>信息噪音多，用户不一定感兴趣，内容获取效率低</li>
</ul>
</li>
<li>智能排序：利用智能算法屏蔽掉违规的，用户不感兴趣的内容，推送用户感兴趣信息吸引用户<ul>
<li>优点：投喂用户感兴趣信息，用户粘度高，容易沉迷</li>
<li>缺点：如果算法不精准可能起反作用</li>
</ul>
</li>
</ul>
<h3 id="Feed流实现："><a href="#Feed流实现：" class="headerlink" title="Feed流实现："></a>Feed流实现：</h3><ul>
<li><p>拉模式：也叫读扩散</p>
<p>发送者将消息存在发件箱中，接收者在需要读取消息的时候才去读取信息。优点是节省空间，缺点是读取时间久</p>
</li>
<li><p>推模式：写扩散</p>
<p>当用户要发消息会直接推送到所有关注者的收件箱。优点是延时低，缺点是内存占有高</p>
</li>
<li><p>推拉结合模式</p>
<p>针对关注者很多的大V等发布者，对于活跃粉丝采用推模式，普通粉丝采用拉模式</p>
</li>
</ul>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230327195700276.png" alt="image-20230327195700276"></p>
<p>推模式实现：</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230327200018235.png" alt="image-20230327200018235"></p>
<p>因为Feed流在不断更新，角标会变化，使用分页查询会出现数据重复情况：</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230327200230839.png" alt="image-20230327200230839"></p>
<p>选择使用滚动分页：<br>记录最后查到的元素<code>lastId</code></p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230327200341045.png" alt="image-20230327200341045"></p>
<p>list结构只能通过角标，首位查询，无法完成滚动分页。SortedSet可以支持值范围查找，每次只要记录最小时间戳往后查询即可。</p>
<p>实现逻辑：在保存笔记内容后推送送给所有粉丝（使用Redis，SortedSet作为收件箱）。粉丝在收件箱进行滚动分页ZRANGEBYSCORE查询</p>
<h2 id="附近商铺"><a href="#附近商铺" class="headerlink" title="附近商铺"></a>附近商铺</h2><h3 id="GEO数据结构"><a href="#GEO数据结构" class="headerlink" title="GEO数据结构"></a>GEO数据结构</h3><p>Redis中的GEO（Geolocation）数据结构，代表地理坐标，允许存储地理坐标信息，帮助根据经纬度来检索数据。</p>
<p>常用命令：</p>
<p>GEOADD：添加一个地理空间信息，包括经度，纬度，值</p>
<p>GEODIST：计算两点之间距离并返回</p>
<p>GEOHASH：将指定member的坐标转为hash字符串形式并返回</p>
<p>GEOPOS：返回指定member坐标</p>
<p>GEORADIUS：指定圆心，半径，找到圆内包含的所有member，按照与圆心之间距离排序返回，6.2之后已废弃</p>
<p>GEOSEARCH：指定范围内搜索member，并按照与指定点之间的距离排序后返回，范围可以是圆或者矩形。6.2新功能</p>
<p>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存到一个指定key。6.2新功能</p>
<h3 id="附近商户搜索"><a href="#附近商户搜索" class="headerlink" title="附近商户搜索"></a>附近商户搜索</h3><ul>
<li><p>数据库存储了店铺信息+坐标信息</p>
</li>
<li><p>存redis存坐标信息以及店铺ID，存的时候按照店铺类型进行分组</p>
<p>写一个<code>loadShopData</code>方法，读取后使用stream流按照店铺id分组写入Map，之后对每个分组读取写入</p>
</li>
</ul>
<h2 id="用户签到"><a href="#用户签到" class="headerlink" title="用户签到"></a>用户签到</h2><h3 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h3><p>签到记录为1，未签到记录为0，那一个用户在一个月的签到情况只需要使用31位的二进制来表示就够了。</p>
<p>类似于这种情况，使用二进制位来表示某个业务的映射关系，这种结构就是BitMap</p>
<p>Redis中利用String类型数据结构实现BitMap，最大上限512M，转换为Bit是2^32个Bit</p>
<p>常用命令：</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230328192345959.png" alt="image-20230328192345959"></p>
<h3 id="签到功能"><a href="#签到功能" class="headerlink" title="签到功能"></a>签到功能</h3><ol>
<li>获取用户信息</li>
<li>获取系统时间</li>
<li>使用Redis存入</li>
</ol>
<h3 id="签到统计"><a href="#签到统计" class="headerlink" title="签到统计"></a>签到统计</h3><p>使用BITFIELD key GET u(dayOfMonth) 0取出本月到今日为止所有数据，结果为十进制</p>
<p>与1做与运算，每次右移一位，就可以求到所有的BIT位</p>
<h2 id="UV统计"><a href="#UV统计" class="headerlink" title="UV统计"></a>UV统计</h2><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><ul>
<li><p>UV: Unique Visitor，独立访客量</p>
</li>
<li><p>PV: Page View ,页面访问量&#x2F;点击量，衡量网站流量</p>
</li>
</ul>
<p>HyperLogLog是LogLog算法派生的概率算法, Redis中HLL基于String实现，且单个HLL内存小于16KB。测量结果。概率性0.81误差</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>项目有哪些功能？</p>
<p>用户登录，商户信息，优惠券秒杀，点赞，签到，消息推送，好友关注</p>
<h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><ol>
<li><p>登陆方式</p>
<p>用户输入手机号，查询是否已经发送验证码，准备生成验证码发送给用户并写入缓存；用户收到验证码后输入，查询redis缓存中验证码是否正确。</p>
</li>
<li><p>为什么不用session共享而选择redis</p>
<p>session在多台不同的tomcat上不共享，在集群中无法共享数据</p>
</li>
<li><p>如何校验用户登陆状态</p>
<p>使用拦截器，对需要校验用户登录状态的路径进行校验，其中用户信息保存在Thread Local（线程的局部变量）中</p>
</li>
<li><p>登陆状态怎么刷新</p>
<p>再加一个全局的拦截器，不拦截任何请求，只是刷新用户登录状态</p>
</li>
<li><p>用户信息怎么脱敏</p>
<p>在缓存中使用一个hashmap，对每个用户使用UUID等信息生成token保存。token是key，用户信息是value</p>
</li>
</ol>
<h3 id="商户信息"><a href="#商户信息" class="headerlink" title="商户信息"></a>商户信息</h3><p><strong>缓存更新策略</strong></p>
<p>​        通常有三种方式：内存淘汰（不做任何动作，利用Redis内存淘汰机制，内存不足自动淘汰部分数据），超时剔除（给数据设置TTL，超时自动删除，每次查询更新时间），主动更新（自己设置策略，在查询数据库同时更新缓存）</p>
<p>​		在更新数据库同时更新缓存。</p>
<p>​		读：在查询商户时，首先查询缓存中是否存在，不存在则去查询数据库并做缓存重建，设置TTL作为缓存兜底策略</p>
<p>​		写：写入商户或者更新商户时，先写入数据库然后删除缓存</p>
<p><strong>一致性问题？</strong></p>
<p>​		要保证操作的原子性，数据库和缓存操作要保证同时成功或者回退，使用Spring事务来保证</p>
<p><strong>为什么删除缓存而不是更新缓存？</strong></p>
<p>​		更新缓存会有很大的线程安全问题，当很多的线程同时在改数据库时，更新缓存只会让最后一次更新的线程成功，无法保证是否是最新的数据。</p>
<p><strong>为什么先操作数据库后操作缓存？</strong></p>
<p>​        先删缓存，还没更新数据库时出现新的线程访问缓存未命中，会去查询数据库重建缓存，这时候第一个线程更新完数据库，那新的线程来查询到的缓存和数据库就不一致了</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230328103928766.png" alt="image-20230328103928766"></p>
<p>右边情况，写缓存的时间比较短，发生的概率比较小。选择右边的先操作数据库再删除缓存</p>
<p><strong>缓存会遇到的问题，说明如何解决</strong></p>
<ul>
<li><p>缓存穿透</p>
<p>请求不存在的key，对后端的数据库产生很大压力，失去了缓存保护后端持久的意义</p>
<p>解决方法：</p>
<ul>
<li>缓存空对象，写入空值</li>
<li>布隆过滤，使用bitmap做布隆过滤器，类似于hash。在到达redis前先做布隆过滤，但是不能保证百分百准确，不存在一定不存在，存在不一定存在</li>
</ul>
</li>
<li><p>缓存雪崩</p>
<p>同一时间大量key失效或者redis服务宕机</p>
<p>解决方法：</p>
<ul>
<li>缓存预热，给不同key的TTL添加随机值</li>
<li>使用redis集群提高服务可用性</li>
<li>给缓存业务添加降级限流</li>
<li>给业务添加多级缓存</li>
</ul>
</li>
<li><p>缓存击穿</p>
<p>热点key问题，被高并发访问，数据库重建比较复杂的key，同时大量线程来重建缓存，加大后端负载</p>
<p>解决方法：</p>
<ul>
<li><p>互斥锁</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230315190127940.png" alt="image-20230315190127940"></p>
</li>
<li><p>逻辑过期</p>
<p>​		将原本的key的数据加上逻辑时间封装到新的类中保存到redis。查询到缓存时（因为逻辑过期，本质永远不会过期，一定能查到）判断是否过期。逻辑已经过期了就去尝试获取互斥锁来重建。没过期或者没能获取到锁就直接返回商铺的目前的信息</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230315185909234.png" alt="image-20230315185909234"></p>
</li>
</ul>
</li>
</ul>
<h3 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a>优惠券秒杀</h3><ul>
<li><p><strong>如何生成全局唯一ID的订单</strong></p>
<p>前面的位置固定时间戳等信息，后32位为redis自增字段，因此可以一秒内支持2^32次订单不重复</p>
</li>
<li><p><strong>库存超卖怎么解决</strong></p>
<ul>
<li>乐观锁：更新库存时候判断是否和查询一样（检查版本号是否一致），如果一样就说明没被修改，如果不一样则回滚</li>
<li>悲观锁：下单业务上使用sync关键字，使秒杀业务变成串行，严重影响性能</li>
</ul>
<p><strong>乐观锁带来的问题：</strong></p>
<p>如果同时有大量线程进行操作，此时一个线程成功会导致其他所有线程失败。比如100件商品同时只有1件卖出，在库存充足的情况下判断库存不足。</p>
<p>进一步我们在使用乐观锁时需要使用版本号（这里是库存）。判断库存是否一致时还要判断库存是否充足，不为空则可以顺利进行</p>
</li>
<li><p><strong>怎么保证一人一单</strong></p>
<p>如果两个线程的用户是同一个，在线程1判断是否具有购买资格还没下单时，线程2也得到时间片判断是否具有资格，此时还没下单就还有资格就执行下单操作，之后线程1也执行下单操作。</p>
<p>此时只能添加悲观锁锁住判断资格和下单的逻辑</p>
<p><strong>但是</strong>：悲观锁在集群环境下不起作用，sync关键字只能锁住在同一个JVM下的</p>
</li>
<li><p><strong>分布式锁怎么实现</strong></p>
<p>使用Redis实现分布式锁：</p>
<ul>
<li><p>利用setnx命令获取锁</p>
<ul>
<li>只有不存在才创建，已存在不能获取，使用完删除</li>
<li>多线程只有一个执行返回true，满足互斥性</li>
<li>设置TTL，防止出现故障无法释放导致死锁问题</li>
<li>利用Redis集群提升可用性</li>
</ul>
</li>
<li><p>释放锁需要判断当前锁是否是自己的，只有当前锁是自己才删除</p>
<ul>
<li>设想情况：线程获取互斥锁，但是业务发生阻塞，导致锁超时自动释放，之后的其他线程获取到锁进行执行</li>
</ul>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230329095201338.png" alt="image-20230329095201338"></p>
</li>
<li><p>删除锁需要保证原子性（判断锁是否是自己的和删除操作）</p>
<p>因为在判断锁之后删除时也有概率发生阻塞导致线程安全问题</p>
<ul>
<li>使用lua脚本来实现多条指令原子性</li>
</ul>
</li>
</ul>
<p><strong>Value问题</strong></p>
<p>锁的Value中保存UUID和线程ID，UUID是为了在集群环境下出现同样线程ID用于区别。</p>
<p><strong>可重入锁</strong></p>
<p>上面的锁不具备可重入功能，同一个线程也不能再次获取到锁。可以通过Hash实现可重入锁，使用threadId作为value中的key，每次记录获取次数。释放锁时检查获取次数，如果-1后是0则释放。</p>
<p><strong>Redisson</strong></p>
<p>分布式锁：</p>
<ul>
<li>使用Hash结构实现重入</li>
<li>利用看门狗机制(自动更新获取锁时间)实现续期</li>
<li>使用信号量控制(订阅锁消息)锁重试</li>
</ul>
<p><strong>MutiLock</strong></p>
<p>问题：在集群下，只有主节点可以进行写。线程在主节点上获取了锁写入，此时redis主节点宕机，信息还没更新到从节点。哨兵机制会选择一个新的主机作为主节点，但是此时锁信息没有保存失效了，造成线程安全问题。</p>
<p>解决方法：</p>
<p>使用Redisson的MutiLock，将所有节点视为同一地位，获取锁要分别从3个Redis节点中获取，只有三个节点都写入成功才能获取到锁</p>
</li>
</ul>
<h3 id="点赞-1"><a href="#点赞-1" class="headerlink" title="点赞"></a>点赞</h3><p>使用ScortedSet按照博客ID存放点赞信息，score为点赞时间</p>
<h3 id="关注"><a href="#关注" class="headerlink" title="关注"></a>关注</h3><p>使用redis的set数据类型，可以求交并集</p>
<h3 id="消息推送"><a href="#消息推送" class="headerlink" title="消息推送"></a>消息推送</h3><h3 id="Feed流两种常见模式：-1"><a href="#Feed流两种常见模式：-1" class="headerlink" title="Feed流两种常见模式："></a>Feed流两种常见模式：</h3><ul>
<li>Timeline：不做内容筛选，简单按照内容发布时间排序，常用于好友或者关注，比如朋友圈<ul>
<li>优点：信息全面，不会缺失，实现简单</li>
<li>信息噪音多，用户不一定感兴趣，内容获取效率低</li>
</ul>
</li>
<li>智能排序：利用智能算法屏蔽掉违规的，用户不感兴趣的内容，推送用户感兴趣信息吸引用户<ul>
<li>优点：投喂用户感兴趣信息，用户粘度高，容易沉迷</li>
<li>缺点：如果算法不精准可能起反作用</li>
</ul>
</li>
</ul>
<h3 id="Feed流实现：-1"><a href="#Feed流实现：-1" class="headerlink" title="Feed流实现："></a>Feed流实现：</h3><ul>
<li><p>拉模式：也叫读扩散</p>
<p>发送者将消息存在发件箱中，接收者在需要读取消息的时候才去读取信息。优点是节省空间，缺点是读取时间久</p>
</li>
<li><p>推模式：写扩散</p>
<p>当用户要发消息会直接推送到所有关注者的收件箱。优点是延时低，缺点是内存占有高</p>
</li>
<li><p>推拉结合模式</p>
<p>针对关注者很多的大V等发布者，对于活跃粉丝采用推模式，普通粉丝采用拉模式</p>
</li>
</ul>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230327195700276.png" alt="image-20230327195700276"></p>
<p>推模式实现：</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230327200018235.png" alt="image-20230327200018235"></p>
<p>因为Feed流在不断更新，角标会变化，使用分页查询会出现数据重复情况：</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230327200230839.png" alt="image-20230327200230839"></p>
<p>选择使用滚动分页：<br>记录最后查到的元素<code>lastId</code></p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230327200341045.png" alt="image-20230327200341045"></p>
<p>list结构只能通过角标，首位查询，无法完成滚动分页。SortedSet可以支持值范围查找，每次只要记录最小时间戳往后查询即可。</p>
<p>实现逻辑：在保存笔记内容后推送送给所有粉丝（使用Redis，SortedSet作为收件箱）。粉丝在收件箱进行滚动分页ZRANGEBYSCORE查询</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/15/%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/" data-id="clix3qjvv000nqwuecv7v74uu" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-操作系统笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2023-06-15T12:12:02.280Z" itemprop="datePublished">2023-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="操作系统笔记"><a href="#操作系统笔记" class="headerlink" title="操作系统笔记"></a>操作系统笔记</h1><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><ul>
<li><p>先到先服务（FCFS，Fist Come，Fist served）：从就绪队列中选择最先进入队列的进程分配资源。使其立即执行并一致执行到完成或者发生某事件而被阻塞放弃占用CPU时再重新调度</p>
</li>
<li><p>短作业优先（SJF，Shortest Job First）：从就绪队列选择一个估计运行时间最短的进程分配资源。使其立即执行并一致执行到完成或者发生某事件而被阻塞放弃占用CPU时再重新调度</p>
</li>
<li><p>时间片轮转（RR，Round-Robin）：最古老，最简单，公平而广泛的算法。每一个进程分配一个时间段，称为时间片，即该线程允许运行的时间</p>
</li>
<li><p>多级反馈队列（MFQ，Mutil-Level Feedback Queue）：既能使高优先级的作业响应又能使短作业迅速完成，公认的较好的进程调度算法。UNIX操作系统就是采用这种</p>
<p>算法流程：</p>
<ul>
<li>进程在进入等待队列时，进入优先级最高的Q1等待</li>
<li>先调度高优先级队列的进程，如果没有则调度次优先级队列进程</li>
<li>对于同一队列进程，按照FCFS分配时间片调度。比如当前队列的时间片为N，当前队列的进程在经历N个时间片后还没完成则进入下一个优先级的队列，同样一级一级下降直到完成</li>
<li>在最后一个队列的各个进程按照时间片轮转分配时间片调度</li>
<li>如果低优先级的进程在运行，新的进程到达，必须把正在运行的进程收回当前队列队尾，优先处理新来的高优先级进程</li>
</ul>
</li>
<li><p>优先级调度（Priority）：给每个进程分配优先级，首先执行高优先级进程，优先级相同则FCFS</p>
</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>产生死锁的四个条件</p>
<p>如何防止死锁</p>
<p>见<a href="C:\Users\Bubble\Desktop\note\并发问题（多线程）.md">并发问题笔记</a></p>
<h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p>进程申请使用资源的时候，银行家算法通过试探分配给该进程资源后，通过安全性算法判断分配后的系统是否处于安全状态，如果不安全则试探分配作废，让该线程继续等待。</p>
<p><strong>判断安全状态？</strong></p>
<p>剩下的资源够不够队列里某一个队列的加入</p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>计算机内存管理的重要技术。本质上是逻辑存在，是假想的内存空间，主要作用是作为进程访问主存（物理内存）</p>
<p>虚拟内存提供了以下能力：</p>
<ul>
<li>隔离进程：物理内存通过虚拟地址空间访问，虚拟地址空间和进程一一对应，进程认为自己拥有整个物理内存，进程间彼此隔离。所以一个进程中的代码无法更改正在进行另一组或操作系统使用的物理内存</li>
<li>提升物理内存利用率：操作系统只需要将进程正在使用的部分数据或指令加载如物理内存。</li>
<li>简化内存管理：进程有一个一致私有的虚拟地址空间，程序员不用和真正的物理内存交流，借助虚拟地址空间访问内存，简化了内存管理。</li>
<li>多个进程共享物理内存：进程运行过程中会依赖许多操作系统的动态库，这些库对每个进程都是公用的。他们在内存中实际只会加载一份，这一部分被称为共享空间</li>
<li>提高内存使用安全性：控制进程对物理内存的访问，隔离不同进程访问权限，提高系统安全性</li>
<li>提供更大的可直接使用内存空间：可以让程序拥有超过系统内存大小的内存空间</li>
</ul>
<h2 id="虚拟地址-x2F-物理地址"><a href="#虚拟地址-x2F-物理地址" class="headerlink" title="虚拟地址&#x2F;物理地址"></a>虚拟地址&#x2F;物理地址</h2><p>物理地址：真正物理内存中的地址，即寄存器的地址，程序中访问的是虚拟地址</p>
<p>地址翻译</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/physical-virtual-address-translation.png" alt="地址翻译过程"></p>
<h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><ol>
<li>先来先服务算法（FCFS）：按照请求到达磁盘调度器的顺序进行处理</li>
<li>最短寻道时间优先算法（SSTF）：优先选择距离当前磁头位置最近的请求服务</li>
<li>扫描算法（SCAN）：也称电梯算法，沿着一个方向扫描磁盘，如果有经过的磁道有请求就处理，直到到达边界然后改变方向反复</li>
<li>循环扫描算法（C-SCAN）：SCAN的变体，只在一侧进行扫描，并且只按照一个方向，直到边界后回到起点开始循环</li>
<li>边扫描边观察算法（LOOK）：对SCAN的改进，如果这个方向之后没有需要处理的请求，就立即改变磁头方向</li>
<li>均衡循环扫描算法（C-LOOK）：C-SCAN的改进，如果磁头移动方向没有磁道访问请求，就立即让磁头返回，磁头只返回到有请求的位置</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/" data-id="clix3qjvt000lqwue46ts0kbp" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-并发问题（多线程）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/15/%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2023-06-15T12:12:02.273Z" itemprop="datePublished">2023-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="并发问题（多线程）"><a href="#并发问题（多线程）" class="headerlink" title="并发问题（多线程）"></a>并发问题（多线程）</h1><h2 id="概念问题"><a href="#概念问题" class="headerlink" title="概念问题"></a>概念问题</h2><h3 id="进程与线程的概念"><a href="#进程与线程的概念" class="headerlink" title="进程与线程的概念"></a>进程与线程的概念</h3><p>进程：系统运行程序的基本单位，运行一个程序就是进程的创建。</p>
<p>线程：一个进程可以包括多个线程，是更小的执行单位。</p>
<p>一个Java程序的运行就是main线程和其他多个线程同时运行。</p>
<p>线程是抽象概念，在Linux内核上没有线程，只有进程和轻量级进程，区别是有没有自己独立的存储空间</p>
<h3 id="进程与线程的关系和区别，以及优缺点"><a href="#进程与线程的关系和区别，以及优缺点" class="headerlink" title="进程与线程的关系和区别，以及优缺点"></a>进程与线程的关系和区别，以及优缺点</h3><p>进程之间是相互独立的，线程之间会有互相影响。线程执行的开销更小，但是不利于资源管理和保护，进程相反。</p>
<p><strong>为什么程序计数器是私有的？</strong></p>
<p>为了线程切换后能恢复到正确执行位置。结合线程计数器的作用回答</p>
<p><strong>为什么虚拟机栈和本地方法栈线程私有？</strong></p>
<p>结合二者的作用，为了防止局部变量被其他线程访问。</p>
<h3 id="并发与并行区别"><a href="#并发与并行区别" class="headerlink" title="并发与并行区别"></a>并发与并行区别</h3><ul>
<li><p>并发：两个及以上的作业在同一<strong>时间段</strong>内执行</p>
</li>
<li><p>并行：两个以上的作业在同一<strong>时刻</strong>执行</p>
</li>
</ul>
<p>最关键：是否同时执行</p>
<h3 id="异步和同步"><a href="#异步和同步" class="headerlink" title="异步和同步"></a>异步和同步</h3><ul>
<li>同步：发出一个调用在没有得到结果以前不可以返回，一直等待。</li>
<li>异步：调用发出后不用等待返回结果直接返回</li>
</ul>
<h3 id="为何要使用多线程"><a href="#为何要使用多线程" class="headerlink" title="为何要使用多线程"></a>为何要使用多线程</h3><p>总的来说：</p>
<ul>
<li>计算机底层来看：线程可以看作更轻量级的进程，是执行的最小单位，线程之间的切换和调度成本远远小于进程。多核CPU意味着可以同时运行多歌线程，减少了切换的开销。</li>
<li>从互联网发展趋势：系统的并发量到百万千万级，多线程是其中的基础，多线程可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>计算机底层：</p>
<ul>
<li>单核时代：提高进程利用系统资源的整体效率。主要为了提高单进程利用CPU和IO系统的效率。只有一个线程时候，线程发生阻塞则进程会被阻塞，此时只运行一处的性能，降低了效率。</li>
<li>多核时代：为了提高进程利用多核CPU的能力，可以同时使用多个CPU核心，单线程只能使用单独的CPU核心。</li>
</ul>
<h3 id="多线程的问题"><a href="#多线程的问题" class="headerlink" title="多线程的问题"></a>多线程的问题</h3><p>并发会带来内存泄漏，死锁，线程不安全等等问题</p>
<h3 id="线程的生命周期和状态（重要）"><a href="#线程的生命周期和状态（重要）" class="headerlink" title="线程的生命周期和状态（重要）"></a>线程的生命周期和状态（重要）</h3><p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/640.png" alt="Java 线程状态变迁图"></p>
<p>6种状态：</p>
<p>new: 线程创建但是没被调用<br>runnable: start调用了等待运行进入ready，等待时间片分配就开始进入running</p>
<p>blocked: 阻塞状态，需要等待锁释放。当线程进入synchronized方法&#x2F;块，或者调用wait后重新进入synchronized，但是锁被其他线程占有。</p>
<p>waiting: 执行wait()方法，需要等待其他线程做出一些动作（通知或者中断）</p>
<p>time_waiting: 超时等待，可以在指定时间后自行返回，而不是像waiting一样一直等待。调用waiting(long millis)或者sleep(long millis)相当于在waiting的基础上增加了超时限制</p>
<p>terminated: 终止状态，执行完了run()方法</p>
<p>在操作系统层面可以看到running状态和ready状态</p>
<p><strong>为什么JVM没有区分ready和running呢？</strong></p>
<p>现在的时分多任务操作系统架构使用时间分片进行抢占式和轮转调度式。这个时间分片一般只有10-20ms量级，线程切换很快，区分二者意义不大。</p>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>线程在执行过程中的运行条件和状态称为上下文，比如程序计数器，栈信息。遇到以下情况线程会从占有cpu的状态中退出：</p>
<ul>
<li>主动让出CPU，比如调用了sleep(),wait()方法</li>
<li>时间片用完，防止其他线程或者进程饿死</li>
<li>调用了阻塞类型的系统中断，比如请求IO</li>
<li>被终止或者结束运行</li>
</ul>
<p>前三种都要发生线程切换，意味着要保留当前线程的上下文，并加载下一个要使用线程的上下文。</p>
<h3 id="线程死锁？如何避免"><a href="#线程死锁？如何避免" class="headerlink" title="线程死锁？如何避免"></a>线程死锁？如何避免</h3><p>多个线程被同时阻塞，互相等待对方释放的资源。</p>
<p>四个必要条件</p>
<ol>
<li>互斥条件：资源在任意一个时刻只由一个线程占有</li>
<li>请求与保持条件：一个线程因请求资源而阻塞时，对自己获得的资源保持不放</li>
<li>不剥夺条件：线程已获得的资源在没有使用完之前不能被其他线程强行剥夺，必须要等待自己使用完毕后释放</li>
<li>循环等待条件：若干线程之间形成头尾相接的循环等待资源关系</li>
</ol>
<p>如何避免？</p>
<p>破坏产生的必要条件：</p>
<ol>
<li>破坏请求与保持条件：一次申请所有资源</li>
<li>破坏不剥夺条件：占有部分资源的线程申请其他资源申请不到则主动释放占有的资源</li>
<li>破坏循环条件：按序申请资源，按照一定顺序申请资源，释放则反序</li>
</ol>
<p>银行家算法：对资源分配进行计算评估，使其进入安全状态</p>
<h3 id="sleep-方法和wait-方法的对比"><a href="#sleep-方法和wait-方法的对比" class="headerlink" title="sleep()方法和wait()方法的对比"></a>sleep()方法和wait()方法的对比</h3><p>共同点：二者都可以暂停线程</p>
<p>区别：</p>
<ul>
<li>sleep不释放锁，wait释放锁</li>
<li>wait用于线程间交互&#x2F;通信，sleep用于暂停执行</li>
<li>wait被调用线程不会自动苏醒，需要调用同一对象上的notify()或者notifyAll()。sleep执行完后会自动苏醒，wait也可以设置超时时间后自动苏醒</li>
<li>sleep是Thread类的静态本地方法，wait是Object类的本地方法</li>
</ul>
<p><strong>为什么wait()方法不定义在Thread中？</strong></p>
<p>wait会主动释放当前线程占用的对象锁，每个对象(Object)都有对象锁，因此要操作对应的对象而非当前线程。</p>
<p><strong>可以直接调用Thread类的run方法吗？</strong></p>
<p>调用start后线程进入就绪状态等待时间片就可以运行，自动完成相应准备工作自动执行run方法。直接运行run方法不会以多线程的方式执行</p>
<h2 id="JMM-Java内存模型"><a href="#JMM-Java内存模型" class="headerlink" title="JMM(Java内存模型)"></a>JMM(Java内存模型)</h2><p><strong>volatile关键字</strong></p>
<p>保证<strong>内存可见性</strong>(到主存中进行读取)和<strong>防止指令重排</strong>(通过插入特定的 内存屏障*的方式来禁止指令重排序)</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/jmm.png" alt="img"></p>
<p>原始意义是禁用CPU缓存，声明告诉JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。<code>volatile</code>能保证数据可见性，但是<strong>不能保证数据原子性</strong>。<code>synchronized</code>二者都可以保证。</p>
<h2 id="Java锁"><a href="#Java锁" class="headerlink" title="Java锁"></a>Java锁</h2><p>查看<a href="C:\Users\Bubble\Desktop\note\Java锁.md">笔记</a></p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>让每个线程绑定自己的值，类似于存放数据的地方。ThreadLocal存储线程的私有数据。</p>
<p>创建了一个ThreadLocal变量，那么每个访问ThreadLocal变量的线程都会有这个变量的本地副本</p>
<p>Thread类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ThreadLoca的set方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前请求的线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//取出 Thread 类内部的 threadLocals 变量(哈希表结构)</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 将需要存储的值放入到这个哈希表中</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中主要有<code>threadLocals</code>和<code>inheritableThreadLocals</code>变量，都是<code>ThreadLocalMap</code>类型。可以理解为ThreadLocal类实现的定制化HashMap，key为线程，value为每个线程的私有数据值。当线程调用ThreadLocal类的set或者get方法才能创建。有多个ThreadLocal对象时，ThreadLocalMap的key存放ThreadLocal对象，value存放对应的值</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/threadlocal-data-structure.png" alt="ThreadLocal 数据结构"></p>
<h3 id="ThreadLocal内存泄漏问题"><a href="#ThreadLocal内存泄漏问题" class="headerlink" title="ThreadLocal内存泄漏问题"></a>ThreadLocal内存泄漏问题</h3><p>ThreadLocalMap的key是ThreadLocal的<strong>弱引用</strong>，value是<strong>强引用</strong>。如果ThreadLocal没被外部强引用，在垃圾回收时会清理掉key，而不会清理value。</p>
<p>此时ThreadLocalMap会出现key为null的Entry，如果不做任何措施，value永远不会被GC回收产生内存泄漏。ThreadLocalMap考虑了这个情况，在调用set，get，remove后都会清理掉key为null的记录。使用完ThreadLocal后最好手动调用remove</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>管理一系列线程的资源池，任务要处理时直接从线程池中获取线程，处理完后线程不销毁，等待下一个任务</p>
<p>线程池，数据库连接池，Http连接池都是类似的思想，目的在减少资源的消耗，提高对资源的利用率</p>
<p>优势：</p>
<ul>
<li>降低资源消耗：通过重复利用自己创建的线程降低线程创建和销毁造成的消耗</li>
<li>提高响应速度：当任务到达时，任务可以不需要等到线程创建</li>
<li>提高线程可管理性：可以对线程进行统一分配，调优和监控</li>
</ul>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ol>
<li><p>ThreadPoolExecutor构造函数创建（推荐）</p>
<p><img src="https://javaguide.cn/assets/threadpoolexecutor%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-d54a5992.png" alt="通过构造方法实现"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个大小为10的线程池</span></span><br><span class="line"><span class="type">BlockingQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>();</span><br><span class="line">ThreadPoolExecutor executor= <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>,Integer.MAX_VALUE,<span class="number">10L</span>, TimeUnit.SECONDS,queue);</span><br><span class="line"><span class="comment">//给线程池添加任务</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  　　  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">    　　    <span class="comment">//这里写你的方法</span></span><br><span class="line">      　　  log.info(<span class="string">&quot;开启线程..&quot;</span>);</span><br><span class="line">    　　&#125;</span><br><span class="line">　　&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过Executor框架工具Executors创建(是通过ThreadPoolExecutor封装的)</p>
<p>可以创建多种类型ThreadPoolExecutor</p>
<ul>
<li>FixedThreadPool:返回一个固定线程数的线程池，线程数量始终不变。新任务如果没有空闲线程会被暂存在任务队列等待线程空闲</li>
<li>SingleThreadExecutor：返回一个只有一个线程的线程池。其他任务会被保存到任务队列，等到线程空闲按照先入先出顺序执行</li>
<li>CacheThreadPool：返回一个可以根据实际情况调整线程数量的线程池。线程空闲可以用会优先使用空闲线程，没有空闲线程会创建新的线程处理任务</li>
<li>ScheduledThreadPool：返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池</li>
</ul>
</li>
</ol>
<p><strong>尽量使用线程池，不允许显式创建线程。</strong></p>
<p>原因：线程池的好处在于减少创建和销毁线程上所消耗的时间和系统资源开销，解决资源不足问题，不使用线程池会造成系统创建大量同类线程而导致消耗完内存或者过度切换的问题</p>
<p><strong>为什么不推荐使用Executors创建？</strong></p>
<ul>
<li>FixedThreadPool和SingleThreadExecutor：使用无界的LinkedBlockingQueue，任务队列最大长度为Integer.MAX_VALUE，可能堆积大量请求，导致OOM</li>
<li>CachedThreadPool：使用同步队列synchronousQueue，允许创建线程数为Integer.MAX_VALUE，可能会创建大量线程导致OOM</li>
<li>ScheduledThreadPool和SingleThreadScheduleExecutor：使用无界的延迟阻塞队列SelayedWorkQueue，任务队列最大长度Integer.MAX_VALUE，可能堆积大量请求，从而导致OOM</li>
</ul>
<p>ThreadPoolExecutor的重要参数：</p>
<ul>
<li>corePoolSize：任务未达到队列容量时，最大可以同时运行的线程数</li>
<li>maximumPoolSize：任务队列中存放的任务达到队列容量时，当前可以同时运行的线程数量变为最大线程数</li>
<li>WorkQueue：新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到会被存放在队列中</li>
</ul>
<p>其他常用参数：</p>
<ul>
<li>keepAliveTime：线程池的线程数大于corePoolSize时，没有新任务提交，核心线程以外的线程不会立即销毁而是等待，等到等待时间超过keepAliveTime</li>
<li>unit：keepAliveTime的时间单位</li>
<li>threadFactory：executor创建线程时用到</li>
<li>handler：饱和策略</li>
</ul>
<p><img src="https://javaguide.cn/assets/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%84%E4%B8%AA%E5%8F%82%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB-d65f3309.png" alt="线程池各个参数的关系"></p>
<h3 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h3><p>当同时运行的线程数达到最大线程数量，队列也放满了任务时使用的策略</p>
<ul>
<li>ThreadPoolExecutor.AbortPolicy（默认）：抛出RejectedExecutionException来拒绝新任务的处理</li>
<li>ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。</li>
<li>ThreadPoolExecutor.DiscardPolicy：不处理新任务，直接丢弃</li>
<li>ThreadPoolExecutor.DiscardOldstPolicy：丢弃最早的未处理的任务请求</li>
</ul>
<h3 id="常用阻塞队列"><a href="#常用阻塞队列" class="headerlink" title="常用阻塞队列"></a>常用阻塞队列</h3><ul>
<li>容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（无界队列）：<code>FixedThreadPool</code> 和 <code>SingleThreadExector</code> 。由于队列永远不会被放满，因此<code>FixedThreadPool</code>最多只能创建核心线程数的线程。</li>
<li><code>SynchronousQueue</code>（同步队列）：<code>CachedThreadPool</code> 。<code>SynchronousQueue</code> 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</li>
<li><code>DelayedWorkQueue</code>（延迟阻塞队列）：<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code> 。<code>DelayedWorkQueue</code> 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。<code>DelayedWorkQueue</code> 添加元素满了之后会自动扩容原来容量的 1&#x2F;2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</li>
</ul>
<h3 id="线程池处理流程"><a href="#线程池处理流程" class="headerlink" title="线程池处理流程"></a>线程池处理流程</h3><p><img src="https://oss.javaguide.cn/javaguide/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="图解线程池实现原理"></p>
<ol>
<li>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li>
<li>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</li>
<li>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li>
<li>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li>
</ol>
<h3 id="线程池大小"><a href="#线程池大小" class="headerlink" title="线程池大小"></a>线程池大小</h3><p>线程池不是越大越好，线程数过多会增加上下文切换成本</p>
<p>上下文切换：</p>
<p>线程数一般都大于CPU核心数量，为了让线程都有效执行，CPU会为每个线程分配时间片并轮转。某个线程时间片用完就会重新处于就绪状态让给其他线程使用CPU，就被称为一次上下文切换。上下文切换需要消耗大量CPU时间</p>
<p>Linux的一个优势就是相比其他操作系统，上下文切换和模式切换的时间消耗都非常少</p>
<p>怎么设置合适的线程数：</p>
<ul>
<li>CPU密集型任务（N+1）：消耗主要是CPU资源，可以将线程数设置为N（CPU核心数）+1。多一个线程是为了防止线程偶发的缺页中断，或者其他原因导致任务暂停带来的影响。这时候多出一个线程就可以充分利用CPU空闲时间</li>
<li>I&#x2F;O密集型任务（2N）：系统大部分时间来处理I&#x2F;O交互，线程在处理I&#x2F;O时间段内不会占用CPU来处理，就可以将CPU交给其他线程使用</li>
</ul>
<p>如何判断是什么任务？</p>
<p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p>
<h3 id="如何动态修改线程池参数"><a href="#如何动态修改线程池参数" class="headerlink" title="如何动态修改线程池参数"></a>如何动态修改线程池参数</h3><p>ThreadPoolExecutor提供的方法：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/threadpoolexecutor-methods.png" alt="img"></p>
<p>setCorePoolSize在程序运行时侯调用，会先判断线程池的工作线程是否大于corePoolSize，大于的话会把工作线程回收</p>
<h2 id="Future类"><a href="#Future类" class="headerlink" title="Future类"></a>Future类</h2><p>是异步思想的典型运用。在一些执行耗时任务的场景可以避免程序一直原地等待耗时任务执行完成，执行效率过低。具体来说，当执行到一个耗时任务，可以把这个耗时任务交给一个子线程去异步执行，同时去做其他事。等完成其他事再通过Future类获取耗时任务的执行结果。</p>
<p>多线程中的经典Future模式，类似于一种设计模式，核心是异步调用</p>
<p>Future在Java中是一个JUC包下的泛型接口，定义了五个方法包括四个功能</p>
<ul>
<li>取消任务</li>
<li>判断任务是否被取消</li>
<li>判断任务是否已经执行完成</li>
<li>获取任务执行结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V 代表了Future执行的任务返回值的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">// 取消任务执行</span></span><br><span class="line">    <span class="comment">// 成功取消返回 true，否则返回 false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line">    <span class="comment">// 判断任务是否被取消</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 判断任务是否已经执行完成</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取任务执行结果</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    <span class="comment">// 指定时间内没有返回计算结果就抛出 TimeOutException 异常</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutExceptio</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Callable和Future的关系"><a href="#Callable和Future的关系" class="headerlink" title="Callable和Future的关系"></a>Callable和Future的关系</h3><p>Callable接口旨在定义一个返回结果并可能引发异常的任务。它在 java.util.concurrent 包中声明。此接口还包含一个单一的、无参数的方法，称为 call ()，将被此接口的实现者覆盖。该方法与Runnable接口的run()方法类似，只是它返回一个值，并且可以抛出一个已检查的异常。事实上，整个想法是 Callable 只不过是 Runnable，因为这两个接口都指定了一个有可能被另一个线程执行的类，只是它不受 Runnable 的限制。</p>
<p><strong>FutureTask</strong>提供了Future接口的基本实现，常用于封装Callable和Runnable，有取消任务，查看任务是否执行完成以及获取任务执行结果的方法。ExecutorService.submit()方法返回的就是Future的实现类FutureTask</p>
<p>FutureTask有两个构造函数可以传入Callable或者Runnable对象，实际上传入Runnable也会在方法内部转换为Callable对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.callable = callable;</span><br><span class="line">    <span class="built_in">this</span>.state = NEW;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Runnable runnable, V result)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过适配器RunnableAdapter来将Runnable对象runnable转换成Callable对象</span></span><br><span class="line">    <span class="built_in">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="built_in">this</span>.state = NEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java8之后引入的CompletableFuture可以解决Future的一些缺陷，提供了更好用更强大的Future，还提供了函数式编程，异步任务编排组合等能力</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p><code>AbstractQueuedSynchronizer</code>，JUC很多的并发类的封装都是基于AQS的，AQS是抽象类，用于构建锁和同步器</p>
<p>可以观看<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12K411G7Fg/?spm_id_from=333.880.my_history.page.click&vd_source=3dacc7eebe628991e8227eebc0b49039">视频</a>帮助理解</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>如果线程请求的共享资源被占用，需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制就是AQS利用CLH队列锁实现的</p>
<p>CLH（Craig，Landin，and Hagersten）队列是虚拟的双向队列（不存在队列实例，仅存在节点之间的关联关系），FIFO。AQS将每个请求共享资源的线程封装成CLH锁队列的一个节点（Node）来实现锁的分配，节点保存现成的引用，当前节点在队列的状态（waitStatus），前驱节点（prev），后继节点（next）</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40cb932a64694262993907ebda6a0bfe~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>AQS中state来表示同步状态，类型为int(线程可以重入重复获取锁，因此可以累计，在共享模式下也可以表示占用线程数)，由volatile修饰保证线程可见性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure>

<p>state可以通过protected修饰的getState，setState，compareAndSetState来操作，都是final修饰无法被子类重写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">     state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ReentrantLock中，state初始为0，未锁定状态。此时A线程lock时会调用tryAcquire，独占锁并将state+1，其他线程就无法获得锁，直到state&#x3D;0时。释放锁前线程A可以重复获取锁，每次获取将state+1，解锁要与获取锁次数一致</p>
<p>CountDownLatch，任务共有N个子线程，state初始化为N，线程并行执行。每个线程执行完成就countDown一次，state会CAS方式-1，所有线程countDown后，state&#x3D;0，然后unpark主调用线程，主调用线程会从await函数返回继续后余动作</p>
<p>获取锁：上层需要重写，不然抛出异常</p>
<ul>
<li>tryAcquire：尝试获取锁，失败后可以选择直接返回或者调用acquire进行等待</li>
<li>acquire：public final修饰，不允许继承类重写。会先tryAcquire，失败后使用addWaiter（加入队列）和acquireQueued方法（配合release实现对线程的挂起和响应）入队</li>
</ul>
<h3 id="Semaphore（信号量）"><a href="#Semaphore（信号量）" class="headerlink" title="Semaphore（信号量）"></a>Semaphore（信号量）</h3><p>synchronized和ReentrantLock一次只允许一个线程访问某个资源，而Semaphore可以用来控制同时访问特定资源的线程数量</p>
<p>使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始共享资源数量</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 获取1个许可</span></span><br><span class="line">semaphore.acquire();</span><br><span class="line"><span class="comment">// 释放1个许可</span></span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure>

<p>如果资源初始化为1，Semaphore退化为排他锁</p>
<p>类似Reentrant Lock，Semaphore也有公平（调用acquire）和非公平模式（详见<a href="C:\Users\Bubble\Desktop\note\Java锁.md">Java锁</a>）</p>
<p>对应构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">  	sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">  	sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(<span class="keyword">permits</span>) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用场景：</p>
<p>用于资源有明确访问数量的场景，比如限流（限单机模式），项目中通常使用Redis+Lua</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>是共享锁的一种实现，默认构造AQS，state值为permits，可理解为许可证数量，拿到许可证的线程才能够执行。在state&gt;&#x3D;0时拿到许可证，然后用CAS操作修改state值使其-1。当state&lt;0时获取许可证失败，会创建一个Node节点加入阻塞队列挂起线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  获取1个许可证</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"> 	 sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 共享模式下获取许可证，获取成功则返回，失败则加入阻塞队列，挂起线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        <span class="comment">// 尝试获取许可证，arg为获取许可证个数，当可用许可证数减当前获取的许可证数结果小于0,则创建一个节点加入阻塞队列，挂起当前线程。</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">      doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>release释放操作类似</p>
<h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>允许count个线程阻塞在同一个地方，等到所有线程任务执行完毕。</p>
<p>（比如找七龙珠，分七个人出去找是最快的，找到之后主线程才能召唤神龙）</p>
<p>比如使用六个任务去处理六个文件，返回给客户的需要这几个文件处理的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample1</span> &#123;</span><br><span class="line">    <span class="comment">// 处理文件的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//处理文件的业务操作</span></span><br><span class="line">                    <span class="comment">//......</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//表示一个文件已经被完成</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进：使用Java8提供的CompletableFuture，提供了很多多线程便利的接口</p>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>类似于CountDownLatch，实现线程间的等待，但是功能更复杂强大，应用场景类似CountDownLatch</p>
<p>CountDownLatch基于AQS，CyclicBarrier基于ReentrantLock和Condition</p>
<p>Cyclibarrier让一组线程到达一个同步点时被阻塞，直到最后一个线程到达同步点，此时同步点（又称屏障，名字中的Barrier）才会打开，所有被拦截阻塞的线程才会继续工作</p>
<h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>CyclicBarrier内部通过count变量作为计数器，初始值为parties属性的初始化值，当有一个计数器到达同步点，就把count计数器-1，当计数器为0，表示所有线程都到达了，就尝试执行我们在构造方法输入的任务</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/15/%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89/" data-id="clix3qjvs000jqwuefkq59oit" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/14/hello-world/" class="article-date">
  <time class="dt-published" datetime="2023-06-14T12:51:48.875Z" itemprop="datePublished">2023-06-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/06/14/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/14/hello-world/" data-id="clix3qjvp000dqwue5vvjcspw" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/06/15/sam%20related%20note/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/06/15/Sam%20on%20tooth/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/06/15/nnUNetv2%E7%AC%94%E8%AE%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/06/15/MedNeXt%20Transformer-driven%20Scaling%20of%20ConvNets%20for%20Medical%20Image%20Segmentation/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/06/15/%E5%BC%82%E4%BD%8D%E8%90%8C%E5%87%BA%E4%BB%BB%E5%8A%A1/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>