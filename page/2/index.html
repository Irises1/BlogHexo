<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-SAM结合笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/15/SAM%E7%BB%93%E5%90%88%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2023-06-15T12:12:08.515Z" itemprop="datePublished">2023-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MedSegDiff-V2-Diffusion-based-Medical-Image-Segmentation-with-Transformer"><a href="#MedSegDiff-V2-Diffusion-based-Medical-Image-Segmentation-with-Transformer" class="headerlink" title="MedSegDiff-V2: Diffusion based Medical Image Segmentation with Transformer"></a>MedSegDiff-V2: Diffusion based Medical Image Segmentation with Transformer</h1><p>(基于Diffusion的Transformer医学分割模型)</p>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>MedSegDiff证明扩散模型在医学影像领域是有用的，直接结合UNet主干的模型性能很差</p>
<p>提出了一种基于Transformer的UNet框架</p>
<p>一种新的Spectrum-Space(频谱空间) Transformer 来对噪声和语义特征之间交互建模</p>
<p>以上的两个改进产生了一种基于Diffusion的医学图像分割方法，改进了MedSegDiff的性能</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>基于Transformer的条件UNet架构：</p>
<p>在扩散过程中使用两种不同的调节技术来condition具有图像分割特征的主干模型：</p>
<ol>
<li>anchor condition：将conditional分割特征集成到扩散模型编码器中减少扩散方差</li>
<li>结合conditional 分割嵌入到diffusion嵌入结合成语义condition</li>
</ol>
<p>为了有效弥补扩散噪声嵌入和条件语义之间的差距提出一种新的变换机制：SS-Former</p>
<p>是一个交错的交叉注意力链，一部分使用噪声嵌入增强语义嵌入，另一部分使用语义嵌入增强噪声嵌入。在频域上设计了一种新的交叉注意力机制，来消除噪声嵌入中的高频噪声</p>
<p>Contribution：</p>
<ul>
<li>第一个将Transformer集成到基于diffusion的模型中用于医学分割</li>
<li>具有高斯空间注意力的anchor condition，来减轻扩散方差并加快ensemble</li>
<li>使用SS-Former对分割噪声和语义特征交互进行建模的语义条件</li>
<li>在不同图像模式的16个医学分割任务上的SOTA性能</li>
</ul>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230525142513309.png" alt="image-20230525142513309"></p>
<h1 id="SpectFormer-Frequency-and-Attention-is-what-you-need-in-a-Vision-Transformer"><a href="#SpectFormer-Frequency-and-Attention-is-what-you-need-in-a-Vision-Transformer" class="headerlink" title="SpectFormer: Frequency and Attention is what you need in a Vision Transformer"></a>SpectFormer: Frequency and Attention is what you need in a Vision Transformer</h1><p>(SpectFormer：频率和注意力是视觉Transformer所需要的)</p>
<p>在Transformer上结合频谱层和多头注意力层</p>
<p>提出了一种新的Transformer体系架构，使用傅里叶变换实现的频谱层来捕获体系结构初始层中的相关特征，同时在更深层中使用多头自注意力</p>
<p>Contribution：</p>
<ul>
<li>使用初始谱层和更深的多头注意力来设计谱层。光谱层的学习滤波器可视化更加局部化，采用混合谱注意和后面的多头注意可以改善结果</li>
<li>在CIFAR-10和100数据集上使用迁移学习模式（在ImageNet训练），specformer取得了合理的性能</li>
<li>评估在MS COCO数据集上的性能证明了specformer在其他任务中获得一致的性能</li>
</ul>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230525144640228.png" alt="image-20230525144640228"></p>
<p>光谱层的位置：</p>
<p>全注意力，全光谱，相反顺序的对比</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230525145701524.png" alt="image-20230525145701524"></p>
<p>光谱层：</p>
<p>目的是捕获图像不同频率的组成来理解局部频率，可以通过频谱门控网络实现，包括一个快速傅里叶变换层(FFT)，接一个加权门控，然后逆FFT层，利用FFT可以把物理空间转换到光谱空间，对每个频率分量的权重使用一个科学系的权重参数，来捕获图像的线和边</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/15/SAM%E7%BB%93%E5%90%88%E7%AC%94%E8%AE%B0/" data-id="clix3qjvl0007qwueahe0gkb4" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-笔面试记录" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/15/%E7%AC%94%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/" class="article-date">
  <time class="dt-published" datetime="2023-06-15T12:12:02.405Z" itemprop="datePublished">2023-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="笔-x2F-面试记录"><a href="#笔-x2F-面试记录" class="headerlink" title="笔&#x2F;面试记录"></a>笔&#x2F;面试记录</h1><p>一些概率很大必须熟悉的考点：</p>
<ul>
<li><p>快排</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">quickSortUtil</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] array)</span>&#123;</span><br><span class="line">        quick(array,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">//递归结束条件:这里代表只有一个根   大于号：有可能没有子树  1  2  3   4  1为基准，pivot-1就越界了</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(array, left, right);</span><br><span class="line">        quick(array,left,pivot-<span class="number">1</span>);</span><br><span class="line">        quick(array,pivot+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;<span class="comment">//这里存开始时基准的下标，为了循环结束后，相遇值和基准值交换时能找到基准值的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> array[start];<span class="comment">//这是基准</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end &amp;&amp; array[end] &gt;= key)&#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end &amp;&amp; array[start] &lt;= key)&#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(array,start,end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到这里s和e相遇，把相遇值和基准值交换</span></span><br><span class="line">        swap(array,start,i);</span><br><span class="line">        <span class="keyword">return</span> start;<span class="comment">//返回基准下标</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> n, <span class="type">int</span> m)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[n];</span><br><span class="line">        array[n] = array[m];</span><br><span class="line">        array[m] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
</li>
<li><p>堆排</p>
<ul>
<li><p>使用优先队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;(n, (a,b) -&gt; b-a);</span><br><span class="line">PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;(n, (a,b) -&gt; a-b);</span><br></pre></td></tr></table></figure>
</li>
<li><p>不适用优先队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大顶堆实现排序（每次从堆顶取出最大值然后放到最后）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">heapSortUtil</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapAdj</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> parent, <span class="type">int</span> length)</span>&#123;</span><br><span class="line">        <span class="comment">//调整堆，堆顶元素下沉</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[parent];</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(child&lt;length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(child+<span class="number">1</span>&lt;length &amp;&amp; arr[child+<span class="number">1</span>] &gt; arr[child]) child++;</span><br><span class="line">            <span class="keyword">if</span>(arr[child] &lt;= temp) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            arr[parent] = arr[child];</span><br><span class="line">            parent = child;</span><br><span class="line">            child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[parent] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">     	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">//从局部到全局保证每个子树都是大顶堆</span></span><br><span class="line">            heapAdj(arr, i, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">//每次取出堆顶最大值放入最后</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = temp;</span><br><span class="line">            heapAdj(arr, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>归并排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr, left, right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        sort(arr, left, c);</span><br><span class="line">        sort(arr, c+<span class="number">1</span>, right);</span><br><span class="line">        merge(arr, left, c, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//目的：对数组arr的left到right，按照c为中点，两侧都已经为有序。将两边合并成新的有序数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> c, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="comment">//将两边的有序数组合并</span></span><br><span class="line">        <span class="comment">//临时数组，先在这里排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tempArr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        <span class="comment">//右侧有序数组开头的指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> c + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//临时数组中当前排序的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">//记录原始数组的开头，最后通过这个索引复制已经排序完成的数组回来</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> left; </span><br><span class="line">        <span class="comment">//对两个有序数组，比较开头的元素大小存入临时数组</span></span><br><span class="line">        <span class="comment">//左边有序数组是从left开始到c，右侧是从rs开始到right</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=c &amp;&amp; rs&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[left]&lt;=arr[rs])&#123;</span><br><span class="line">                tmpArr[p++] = arr[left++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmpArr[p++] = arr[rs++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//两边哪边剩下，全部存入临时数组后面</span></span><br><span class="line">        <span class="keyword">while</span>(rs&lt;=right)&#123;</span><br><span class="line">            tmpArr[p++] = arr[rs++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=c)&#123;</span><br><span class="line">            tmpArr[p++] = arr[left++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//复制回原数组</span></span><br><span class="line">        <span class="keyword">while</span>(tmp&lt;=right)&#123;</span><br><span class="line">            arr[tmp] = tmpArr[tmp++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

</li>
<li><p>单例模式</p>
<p>详情查看设计模式笔记</p>
</li>
<li><p>二分查找</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
<h2 id="海康"><a href="#海康" class="headerlink" title="海康"></a>海康</h2><h3 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h3><ol>
<li><p>对序列化对象的存储和读取用什么流</p>
<p>对象流：<code>ObjectInputStream</code>和<code>ObjectOutputStream</code></p>
</li>
<li><p>OSI层有哪些</p>
<p>OSI是国际标准化组织提的，也是最完整复杂的7层：物理层，数据链路层，网络层，传输层，会话层，表达层，应用层</p>
<p>比较简单的常用是五层结构：物理层，数据链路层，网络层，传输层，应用层</p>
</li>
<li><p>Java中Thread的操作</p>
<p>start方法：启动线程，在调用start方法会开启新线程来执行用户定义的子任务，并分配资源</p>
<p>run方法：用于执行线程运行时的代码，线程具体去做的事情</p>
<p>sleep方法：线程休眠，但是不释放锁，所以别的线程无法获取当前线程资源</p>
<p>yield方法：当前线程交出cpu权限，类似sleep，也不释放锁，不能控制时间，线程重回就绪状态</p>
<p>getId方法：获取线程ID</p>
</li>
<li><p>Java8中Switch语句不支持的类型</p>
<p>long、float、double、boolean、复杂的表达式</p>
</li>
<li><p>servlet生命周期</p>
<p><img src="https://img.php.cn/upload/image/859/931/869/1677130717818216.png" alt="1.png"></p>
<ul>
<li><p>init方法</p>
<p>只在创建servlet时调用一次，初始化加载创建数据</p>
</li>
<li><p>service方法</p>
<p>执行实际任务的主要方法，检查请求类型，在适当时候调用不同的方法处理客户端请求并把格式化的响应写回客户端</p>
</li>
<li><p>doGet方法</p>
<p>最常用的方法，处理Get请求</p>
</li>
<li><p>doPost方法</p>
<p>处理post请求</p>
</li>
<li><p>destory方法</p>
<p>Servlet生命周期结束时被调用，来销毁对象</p>
</li>
</ul>
</li>
<li><p>清空设置了主键自增的数据库表全部数据，使id可以从1开始</p>
<p>truncate table 表名</p>
</li>
<li><p>Servlet API实现转向时不在地址栏中显示转向后的地址</p>
<p>forward：转发，服务器去获取资源后返回给客户端，客户端（浏览器）不知道从哪来</p>
<p>redirect：重定向，告诉客户端去哪重新拿资源，会显示转向后的地址</p>
</li>
<li><p>排序复杂度</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230509104537010.png" alt="image-20230509104537010"></p>
</li>
<li><p>创建3个线程为Thread1Thread2Thread3 需要对一个数字进行递减操作 当数字递减到0的时候，输出“数字为0，结束递减”</p>
<p>以下是互斥锁的实现，效率低</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">countWithThread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//创建三个线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义线程，实现Runable接口，重写run方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">countThread</span> <span class="keyword">implements</span> <span class="title class_">Runable</span>&#123;</span><br><span class="line">    <span class="comment">//给所有线程共享的资源，需要递减的数字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">static</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">    <span class="comment">//定义一下线程id，方便可视化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> threadID;</span><br><span class="line">    <span class="comment">//用构造方法每次定义时候写一下线程id</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">countThread</span><span class="params">(<span class="type">int</span> threadId)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.threadId = threadId;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//定义实际执行的方法体</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//要对资源加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span>(countThread.class)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前线程:&quot;</span>+threadID);</span><br><span class="line">                <span class="comment">//每个线程交替进行，那就判断当前要减的数是否与线程id对应</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> num % <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(index == threadID)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;当前操作线程:&quot;</span>+threadID);</span><br><span class="line">                    System.out.println(<span class="string">&quot;数字为&quot;</span>+(num--));</span><br><span class="line">                    <span class="keyword">if</span>(num == <span class="number">0</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;为0结束！&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    countThread.class.notifyAll();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        countThread.class.wait();</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                        e.printStace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面写的太丑了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Count</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Integer num;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Count</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.num = n;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">decrease</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runable</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span>(Count.class)&#123;</span><br><span class="line">                        <span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        	System.out.println(<span class="string">&quot;thread name:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + num--);</span><br><span class="line">                    	&#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用CAS乐观锁来实现提升效率</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Count</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> AtomicInteger num;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Count</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.num = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(n)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">decrease</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runable</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(num.get()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;thread name:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + num.decrementAndGet());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>数据库</p>
<ul>
<li><p>创建学生表，包括学号，姓名，性别，年龄，联系方式</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">	sid <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key,</span><br><span class="line">	sname <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">	ssex <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">	sage <span class="type">int</span>,</span><br><span class="line">	sphone <span class="type">int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加字段：家庭地址</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Alter</span> <span class="keyword">Table</span> student <span class="keyword">ADD</span> saddress <span class="type">int</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入五条数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果整行插入可以省略字段名</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student (sid,sname,ssex,sage,sphone,saddress)</span><br><span class="line"><span class="keyword">values</span>(),</span><br><span class="line">(),</span><br><span class="line">(),</span><br><span class="line">(),</span><br><span class="line">(),</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用观察者模式,实现以下业务场景:一栋3层的楼房中，每层有一个保安值守（原题的一部分）</p>
<p> 这题大概的意思就是。当有一层楼道着火时，检测中心能够通知到保安去处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象被观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer o)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体被观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Building</span> <span class="keyword">implements</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line">    <span class="comment">//楼层数</span></span><br><span class="line">    <span class="type">int</span> floorCount;</span><br><span class="line">    <span class="comment">//观察者集合</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Observer&gt; observers;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Building</span><span class="params">(<span class="type">int</span> floorCount)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.floorCount = floorCount;</span><br><span class="line">        <span class="built_in">this</span>.observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer o)</span>&#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(observrs.contains(o))&#123;</span><br><span class="line">            observer.remove(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> floor)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Guard</span> <span class="keyword">implements</span> <span class="title class_">Oberver</span>&#123;</span><br><span class="line">    <span class="comment">//值班楼层</span></span><br><span class="line">    <span class="type">int</span> workFloor;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Guard</span><span class="params">(<span class="type">int</span> workFloor)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.workFloor = workFloor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> floor)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(floor == workFloor)&#123;</span><br><span class="line">            extinguishing(floor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">extinguishing</span><span class="params">(<span class="type">int</span> floor)</span>&#123;</span><br><span class="line">        System.out.println(floor + <span class="string">&quot;层保安正在灭火&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>归并排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr, left, right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        sort(arr, left, c);</span><br><span class="line">        sort(arr, c+<span class="number">1</span>, right);</span><br><span class="line">        merge(arr, left, c, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> c, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="comment">//将两边的有序数组合并</span></span><br><span class="line">        <span class="comment">//临时数组，先在这里排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tempArr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        <span class="comment">//第二个数组开头的指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> c + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//临时数组中当前排序的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">third</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">//记录原始数组的开头，最后通过这个索引复制已经排序完成的数组回来</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">//对两个有序数组，比较开头的元素大小存入临时数组</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=c &amp;&amp; mid&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[left]&lt;=arr[mid])&#123;</span><br><span class="line">                tmpArr[third++] = arr[left++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmpArr[third++] = arr[mid++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//两边哪边剩下，全部存入临时数组后面</span></span><br><span class="line">        <span class="keyword">while</span>(mid&lt;=right)&#123;</span><br><span class="line">            tmpArr[third++] = arr[mid++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=c)&#123;</span><br><span class="line">            tmpArr[third++] = arr[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//复制回原数组</span></span><br><span class="line">        <span class="keyword">while</span>(tmp&lt;=right)&#123;</span><br><span class="line">            arr[tmp] = tmpArr[tmp++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


</li>
<li><p>实现单例模式</p>
<p> 详细查看设计模式笔记</p>
</li>
</ol>
<h2 id="大应科技"><a href="#大应科技" class="headerlink" title="大应科技"></a>大应科技</h2><p>笔：</p>
<ol>
<li><p>实现一个LRU缓存</p>
<p>题源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/">LRU Cache</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;Integer,Integer&gt;&#123;</span><br><span class="line">    <span class="comment">//使用哈希链表LinkedHashMap(HashMap+双向链表)模拟LRU缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        构造方法</span></span><br><span class="line"><span class="comment">        使用源码中的构造方法：</span></span><br><span class="line"><span class="comment">        这里的 accessOrder 默认是为false，如果要按读取顺序排序需要将其设为 true</span></span><br><span class="line"><span class="comment">        initialCapacity 代表 map 的 容量，loadFactor 代表加载因子 (默认即可)</span></span><br><span class="line"><span class="comment">        public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123;</span></span><br><span class="line"><span class="comment">            super(initialCapacity, loadFactor);</span></span><br><span class="line"><span class="comment">            this.accessOrder = accessOrder;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="comment">//HashMap默认的加载因子是0.75，最大容量是16,s实际容量就是12，加载因子越大，空间利用率越高但是hash冲突概率越大</span></span><br><span class="line">    <span class="comment">//如果accessOrder为true，则会把访问过的元素放在链表后面，放置顺序是访问的顺序；如果accessOrder为flase的话，则按插入顺序来遍历  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(capacity,<span class="number">0.75F</span>,<span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="comment">// LinkedHashMap 中的 getOrDefault()，即当 key 不存在时会返回默认值 -1,符合题意</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可以删除不写，与父类一致，但是要重写removeEldestEntry</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题需要深入理解LinkedHashMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get方法相关</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line"><span class="comment">//调用父类HashMap的getEntry()方法，取得要查找的元素</span></span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 记录访问顺序</span></span><br><span class="line">        e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="comment">// These fields comprise the doubly linked list used for iteration.</span></span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line"> </span><br><span class="line">        Entry(<span class="type">int</span> hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//在HashMap的put和get方法中，会调用该方法，在HashMap中该方法为空；</span></span><br><span class="line"><span class="comment">//在LinkedHashMap中，</span></span><br><span class="line"><span class="comment">//当按访问顺序排序时，该方法会将当前节点插入到链表尾部(头结点的前一个节点)，</span></span><br><span class="line"><span class="comment">//否则不做任何事</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> &#123;</span><br><span class="line">            LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</span><br><span class="line">            <span class="keyword">if</span> (lm.accessOrder) &#123;</span><br><span class="line">                lm.modCount++;</span><br><span class="line"><span class="comment">//移除当前节点</span></span><br><span class="line">                remove();</span><br><span class="line"><span class="comment">//将当前节点插入到头结点前面</span></span><br><span class="line">                addBefore(lm.header);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> &#123;</span><br><span class="line">            after  = existingEntry;</span><br><span class="line">            before = existingEntry.before;</span><br><span class="line">            before.after = <span class="built_in">this</span>;</span><br><span class="line">            after.before = <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put方法相关</span></span><br><span class="line"><span class="comment">//put方法完全继承了HashMap</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;      <span class="comment">//数组为null时</span></span><br><span class="line">        inflateTable(threshold);     <span class="comment">//给数组根据阈值分配内容空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)      <span class="comment">//key为null时</span></span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);  <span class="comment">//通过key计算hash</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);  <span class="comment">//计算在数组中的索引位置</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">           <span class="comment">//使用的是LinkedHashMap重写的方法</span></span><br><span class="line">                     <span class="number">1</span> </span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);         </span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">   <span class="comment">//addEntry调用的是LinkedHashMap重写了的方法</span></span><br><span class="line">             <span class="number">2</span> </span><br><span class="line">    addEntry(hash, key, value, i);     </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊点在于对recordAccess和addEntry进行了重写</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> &#123;      <span class="number">1</span></span><br><span class="line">            <span class="comment">//将传入的HashMap类型的m强制转换成LinkedHashMap类型的    </span></span><br><span class="line">            LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;  </span><br><span class="line">            <span class="comment">//accessOrder默认的是false，当accessOrder为true时进入</span></span><br><span class="line">            <span class="keyword">if</span> (lm.accessOrder) &#123; </span><br><span class="line">                lm.modCount++;</span><br><span class="line">                <span class="comment">//移除当前节点 </span></span><br><span class="line">                remove(); </span><br><span class="line">                <span class="number">3</span>      </span><br><span class="line">                addBefore(lm.header);           </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;           <span class="number">2</span></span><br><span class="line">        <span class="comment">// 重写了HashMap中的createEntry方法</span></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);  </span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Remove eldest entry if instructed</span></span><br><span class="line">        Entry&lt;K,V&gt; eldest = header.after;   <span class="comment">//还是header自身</span></span><br><span class="line">        <span class="keyword">if</span> (removeEldestEntry(eldest)) &#123;            <span class="number">4</span></span><br><span class="line">            removeEntryForKey(eldest.key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">//扩容到原来的2倍  </span></span><br><span class="line">        <span class="keyword">if</span> (size &gt;= threshold)             <span class="number">5</span></span><br><span class="line">            resize(<span class="number">2</span> * table.length);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//一般重写此方法，如果内存已满返回true，</span></span><br><span class="line"><span class="comment">//这样当再次向LinkedHashMap中putEntry时，在调用的addEntry方法中便会将近期最少使用的节点删除掉（header后的那个节点）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;    <span class="number">4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>找出数组第K大的数</p>
<p>题源：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/xx4gT2/">剑指 Offer II 076. 数组中的第 k 大的数字</a>，<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array">数组中的第K个最大元素</a></p>
<ol>
<li><p>快排思路</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// private final static Random random = new Random(System.currentTimeMillis());</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSort(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">//排序是升序，记得目标反过来</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> nums.length-k;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(nums, start, end);</span><br><span class="line">        <span class="keyword">if</span>(p==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[p];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p&gt;target)&#123;</span><br><span class="line">            <span class="keyword">return</span> quickSort(nums,start,p-<span class="number">1</span>,k);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> quickSort(nums,p+<span class="number">1</span>,end,k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="comment">//为了防止极端测试例，使用以下随机数会加快速度</span></span><br><span class="line">        <span class="comment">// int randomIndex = l + random.nextInt(r - l + 1);</span></span><br><span class="line">        <span class="comment">// swap(nums, l, randomIndex);</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> nums[l];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[r] &gt;= key) r--;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[l] &lt;= key) l++;</span><br><span class="line">            <span class="keyword">if</span>(l&lt;r)</span><br><span class="line">                swap(nums,l,r);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,l,p);</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>堆排（优先队列）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//大顶堆</span></span><br><span class="line">        <span class="comment">// PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;Integer&gt;(k,(a,b) -&gt; b-a);</span></span><br><span class="line">        <span class="comment">//小顶堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;(k,(a,b) -&gt; a-b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; k; i++)&#123;</span><br><span class="line">            heap.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> heap.peek();</span><br><span class="line">            <span class="keyword">if</span>(temp&lt;nums[i])&#123;</span><br><span class="line">                heap.poll();</span><br><span class="line">                heap.offer(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap.peek();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/15/%E7%AC%94%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/" data-id="clix3qjvv000oqwue0brfaq9d" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Spring相关问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/15/Spring%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2023-06-15T12:12:02.398Z" itemprop="datePublished">2023-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Spring相关问题"><a href="#Spring相关问题" class="headerlink" title="Spring相关问题"></a>Spring相关问题</h1><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><h3 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h3><p>控制反转，一种设计思想。将原本在程序中手动创建对象的控制权，交给Spring框架管理</p>
<p>当需要创建一个对象时，直接问spring要就行，不用管对象如何创建，只需要提前配置好。</p>
<p>IoC容器时Spring实现IoC的载体，实际上IoC容器是一个Map结构，存放各种对象。</p>
<h3 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h3><p>依赖注入，是IoC的一种最常见合理的实现方式</p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol>
<li>对象之间的耦合度或者依赖程度降低</li>
<li>资源更容易管理</li>
</ol>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>见下方章节</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h3><p>被IoC容器管理的对象，通过配置元数据定义</p>
<h4 id="声明Bean的注解"><a href="#声明Bean的注解" class="headerlink" title="声明Bean的注解"></a>声明Bean的注解</h4><ul>
<li>@Component：通用注解，可标注任意类为Spring组件，如果一个Bean不属于哪一层就使用@Component</li>
<li>@Repository：对应持久层（Dao层），用于数据库相关操作</li>
<li>@Service：对应服务层，设计复杂的逻辑，用到Dao层</li>
<li>@Controller：对应Spring MVC的控制层，用于接受用户请求并调用Service层返回数据给前端页面</li>
</ul>
<h4 id="Component和-Bean的区别是什么"><a href="#Component和-Bean的区别是什么" class="headerlink" title="@Component和@Bean的区别是什么"></a>@Component和@Bean的区别是什么</h4><ul>
<li>@Component注解作用于类，@Bean用于方法</li>
<li>@Component通常通过类路径扫描自动侦测装配到Spring容器（可以用@ComponentScan定义扫描路径）。@Bean是在注释的方法中定义了这个Bean，@Bean告诉Spring这是某个类的实例，需要的时候可以还给我</li>
<li>@Bean的自定义性更强，很多地方只能通过@Bean来注册Bean，比如第三方库的类需要装配到Spring</li>
</ul>
<p>上面太啰嗦：</p>
<p>1、@Component注解表明一个类会作为组件类，并告知Spring要为这个类创建bean。</p>
<p>2、@Bean注解告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的bean。通常方法体中包含了最终产生bean实例的逻辑。</p>
<h2 id="Bean的注入注解"><a href="#Bean的注入注解" class="headerlink" title="Bean的注入注解"></a>Bean的注入注解</h2><ul>
<li>@Autowired：（Spring内置）</li>
<li>@Resource：（JDK自带）</li>
<li>@Inject：（基本不用，JDK自带）</li>
</ul>
<h3 id="Autowired和-Resource的区别"><a href="#Autowired和-Resource的区别" class="headerlink" title="@Autowired和@Resource的区别"></a>@Autowired和@Resource的区别</h3><ul>
<li>@Autowired：Spring提供的注解，@Resource是JDK提供的注解</li>
<li>@Autowired默认注入方式byType，@Resource默认注入byName</li>
<li>一个接口存在多个实现类时，@Autowired和@Resource都要通过名称才能正确匹配到对应的Bean，@Autowired可以通过@Qualifier来显式指定名称，@Resource可以通过name属性来显式指定名称</li>
</ul>
<p>Autowired默认byType的问题：当一个接口存在多个实现类，就不知道选哪个了，此时使用@Qualifier(value &#x3D; “实现类名”)指定名称</p>
<p>Resource默认byName，可以使用属性名选择名称，@Resource(name &#x3D; “实现类名”)</p>
<h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><p>一共有6种</p>
<ul>
<li>singleton：IoC容器中只有唯一bean，Spring中的bean默认单例</li>
<li>prototype：每次获取都会创建一个新的bean实例，也就是连续getBean两次得到的bean是不同的</li>
<li>request：（仅Web应用）每一次HTTP请求都会产生一个新的bean（请求bean），仅在当前HTTP request内有效</li>
<li>session：（仅Web应用）每一次来自session的HTTP请求都会产生一个新的bean（会话bean），仅在当前HTTP session内有效</li>
<li>application&#x2F;global-session：（仅Web应用）每个Web应用在启动时创建一个Bean（应用Bean），仅在当前应用启动时间内有效</li>
<li>websocket：（仅Web应用）每一次WebSocket会话产生一个新的bean</li>
</ul>
<p>如何配置</p>
<p>注解方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">personPrototype</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单例Bean的线程安全问题"><a href="#单例Bean的线程安全问题" class="headerlink" title="单例Bean的线程安全问题"></a>单例Bean的线程安全问题</h3><p>多个线程在操作的时候，是同一个Bean实例，会存在线程安全问题</p>
<p>Bean有状态：即是有实例变量的对象，其中可以保存数据，线程不安全</p>
<p>解决方法：</p>
<ol>
<li>在Bean中尽量避免定义可变的成员变量</li>
<li>在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在ThreadLocal中（推荐）</li>
</ol>
<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>Bean容器实现</p>
<ol>
<li><strong>实例化Bean</strong>：在配置文件上（注释或者配置类）找到Spring Bean的定义，然后容器利用Java Reflection API创建一个Bean的实例</li>
<li><strong>Bean属性的赋值</strong>：涉及到的一些属性值用<strong>set方法</strong>设置</li>
<li><strong>检查Bean是否实现类Aware相关的接口</strong>，若实现则调用这些接口的方法<ul>
<li>若实现BeanNameAware，Spring会把Bean名字传递给Bean</li>
<li>若实现BeanClassLoaderAware，Spring会调用setBeanClassLoader方法加载该Bean的类加载器ClassLoader传递给Bean</li>
<li>若实现BeanFactoryAware，Spring会调用setBeanFactory方法把工厂对象BeanFactory传给Bean</li>
</ul>
</li>
<li><strong>执行Bean后处理器的before方法</strong>：如果有BeanPostProcessor对象，执行前处理方法</li>
<li><strong>检查Bean是否实现InitializingBean</strong>，若实现则调用afterPropertiesSet方法（这也是一个初始化方法，可以和Bean自己的init-method配合使用，这个方法直接执行，init-method通过反射执行，afterPropertiesSet会和Spring耦合）</li>
<li><strong>初始化Bean</strong>，调用Bean的init-method属性，执行指定方法</li>
<li><strong>执行Bean后处理器的after方法</strong>：如果有BeanPostProcessor对象，执行后处理方法</li>
<li><strong>使用Bean</strong></li>
<li><strong>检查Bean是否实现DisposbleBean</strong>，若实现则调用destory方法</li>
<li><strong>销毁Bean</strong></li>
</ol>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/b5d264565657a5395c2781081a7483e1.jpg" alt="Spring Bean 生命周期"></p>
<p>Bean完整的生命周期经历各种方法调用，可以划分为：</p>
<ol>
<li>Bean自身的方法：包括Bean本身调用的方法和通过配置文件中<code>&lt;bean&gt;</code>的init-method和destory-method指定的方法</li>
<li>Bean级生命周期接口方法：包括了BeanNameAware，BeanFactoryAware，InitializingBean和DiposableBean这些接口的方法</li>
<li>容器级生命周期接口方法：包括InstantiationAwareBeanPostProcessor和BeanPostProcessor着两个接口实现，一般称它们的实现类为“后处理容器”</li>
<li>工厂后处理器接口方法：包括了Aspect&#x2F;WeavingEnabler，ConfigurationClassPostProcessor，CustomAutowireConfigurer等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的，在应用上下文装配配置文件后立即调用</li>
</ol>
<p><img src="https://images0.cnblogs.com/i/580631/201405/181453414212066.png" alt="img"></p>
<p><img src="https://images0.cnblogs.com/i/580631/201405/181454040628981.png" alt="img"></p>
<h2 id="AOP-1"><a href="#AOP-1" class="headerlink" title="AOP"></a>AOP</h2><p>AOP（面向切面编程）可以把和业务无关但是被业务模块共同调用的逻辑或者责任（事务处理，日志管理，权限控制）封装起来，减少系统的重复代码，降低模块间的耦合度，并且利于未来拓展。</p>
<p>底层基于动态代理，如果要代理的对象实现了某个接口，AOP会使用JDK Proxy去创建代理对象。对于没有实现接口的对象，无法使用JDK Proxy代理，AOP就会使用Cglib生成一个被代理对象的子类来作为代理</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/230ae587a322d6e4d09510161987d346.jpeg" alt="SpringAOPProcess"></p>
<p>也可以使用AspectJ，Spring  AOP集成了AspectJ</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>请阅读理解设计模式的代理模式，在笔记中有记录各种动态代理静态代理，见<a href="C:\Users\Bubble\Desktop\note\设计模式.md">笔记</a></p>
<p>回顾一下事务失效通过动态代理解决的问题<a href="C:\Users\Bubble\Desktop\note\Spring事务失效问题.md">笔记</a></p>
<h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>JDK中提供了一个动态代理类Proxy，提供一个创建代理对象的静态方法<code>newProxyInstance()</code>来获取代理对象，在程序运行过程中生成在内存动态生成继承Proxy(因为Java的单继承，所以只能实现接口，导致JDK动态代理的对象必须实现接口)，实现抽象主题接口的代理类。</p>
<p>执行流程：</p>
<ol>
<li>通过代理对象调用某个业务方法</li>
<li>根据多态，执行的的是代理类的这个业务方法</li>
<li>代理类的被执行方法调用InvocationHandler接口的子实现类对象的invoke方法</li>
<li>invoke方法通过反射执行了真实对象所属类的这个业务方法</li>
</ol>
<h4 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h4><p>对于没有定义抽象主题接口的代理类，可以直接使用CGLib创建Enhancer对象来创建代理对象</p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>CGLib底层采用ASM字节码生成框架，不能对声明为final的类或者方法进行代理。在JDK1.8之后，JDK动态代理的效率更高，因此如何选择取决于有没有定义接口，定义了接口优先选择JDK动态代理</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li>目标：被通知的对象</li>
<li>代理：向目标对象应用通知之后创建的代理对象</li>
<li>连接点：目标对象的所属类中，定义的<strong>所有方法</strong>均为连接点</li>
<li>切入点：被切面拦截&#x2F;增强的连接点（切入点一定是连接点，连接点不一定是切入点）</li>
<li>通知：增强的逻辑（代码），即拦截到目标对象的连接点之后要做的事情</li>
<li>切面：切入点+通知</li>
<li>Weaving（织入）：将通知应用到目标对象，进而生成代理对象的过程动作</li>
</ul>
<h3 id="Spring-AOP和AspectJAOP的区别"><a href="#Spring-AOP和AspectJAOP的区别" class="headerlink" title="Spring AOP和AspectJAOP的区别"></a>Spring AOP和AspectJAOP的区别</h3><ul>
<li><p>Sping AOP是运行时增强，AspectJ是编译时增强</p>
</li>
<li><p>SpringAOP基于代理，AspectJ基于字节码操作</p>
</li>
<li><p>SpringAOP集成了AspectJ，AspectJ是Java生态中最完整的AOP框架</p>
</li>
<li><p>AspectJ功能更强大，SpringAOP更简单</p>
</li>
</ul>
<p>如果切面很多，比较复杂，最好选择AspectJ，相比于SpringAOP更快</p>
<h3 id="AspectJ定义的通知类型"><a href="#AspectJ定义的通知类型" class="headerlink" title="AspectJ定义的通知类型"></a>AspectJ定义的通知类型</h3><ul>
<li>Before</li>
<li>After</li>
<li>AfterReturning</li>
<li>AfterThrowing</li>
<li>Around</li>
</ul>
<h3 id="多个切面的执行顺序"><a href="#多个切面的执行顺序" class="headerlink" title="多个切面的执行顺序"></a>多个切面的执行顺序</h3><p>类似过滤器，使用@Order注解的值定义，或者实现Order接口重写getOrder方法</p>
<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>严格来说不属于设计模式，是软件设计规范</p>
<p>模型Model，视图View，控制器Controller的简写。核心思想是通过将业务逻辑，数据，显示，三块内容分离来组织代码</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/de6d2b213f112297298f3e223bf08f28.png" alt="img"></p>
<p><strong>核心组件</strong>：</p>
<ul>
<li><strong>DispatcherServlet</strong>：核心中央处理器，负责接收请求，分发，并给予客户端响应</li>
<li>HandlerMapping：处理器映射器，根据uri匹配查找能处理的Handler，并将请求涉及到的拦截器和handler一起封装</li>
<li>HandlerAdapter：处理器适配器，根据HandlerMapping找到的Handler，适配执行对应的Handler</li>
<li>Handler：请求处理器，处理实际请求的处理器，返回ModelAndView，就是返回的数据和视图</li>
<li>ViewResolver：视图解析器，根据Handler返回的逻辑视图&#x2F;视图，解析并渲染真正的视图，传递给DispatcherServlet响应客户端</li>
</ul>
<h3 id="统一的异常处理"><a href="#统一的异常处理" class="headerlink" title="统一的异常处理"></a>统一的异常处理</h3><p>使用@ControllerAdvice+@ExceptionHandler两个注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(BaseException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; handleAppException(BaseException ex, HttpServletRequest request) &#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = ResourceNotFoundException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ErrorReponse&gt; <span class="title function_">handleResourceNotFoundException</span><span class="params">(ResourceNotFoundException ex, HttpServletRequest request)</span> &#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>会给所有或者指定的Controller织入异常处理逻辑（AOP方式），当Controller抛出异常，会被@ExceptionHandler注解修饰的方法进行处理</p>
<h2 id="Spring框架中用到的设计模式"><a href="#Spring框架中用到的设计模式" class="headerlink" title="Spring框架中用到的设计模式"></a>Spring框架中用到的设计模式</h2><ul>
<li>工厂模式：创建Bean对象中使用了工厂模式，通过BeanFactory，ApplicationContext来创建</li>
<li>代理模式：AOP功能的实现</li>
<li>单例模式：默认Bean实现都是单例的</li>
<li>模板方法：jdbcTemplate，hibernateTemplate等以Template结尾的对数据库操作的类都使用了模板模式</li>
<li>包装类设计模式：项目需要连接多个数据库，不同的客户在每次访问中会根据需要去访问不同数据库，这个模式可以根据用户需求动态切换数据源</li>
<li>观察者模式：Spring事件驱动模型就是观察者模式的经典应用</li>
<li>适配器模式：AOP增强或者通知都用到了适配器模式，Spring MVC中也是用适配器模式适配Controller</li>
</ul>
<h2 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h2><p>事务特性ACID：</p>
<ol>
<li>A，原子性（Atomicity）：事务是最小执行单位，不允许分割。事务要么全部完成，要么全部不起作用</li>
<li>C，一致性（Consistency）：执行事务前后数据保持一致，比如转账业务，无论事务是否成功，转账者和收款人总额不变</li>
<li>I，隔离性（Isolation）：并发访问数据库，事务不被其他事务干扰，各并发事务的数据库独立</li>
<li>D，持久性（Durability）：事务被提交之后，对数据库数据的改变是持久的，数据库发生故障也不应该有影响</li>
</ol>
<p>注意：AID是手段，C是目的，只有保证事务持久性，原子性，隔离性，一致性才能得到保障</p>
<h3 id="事务管理方式"><a href="#事务管理方式" class="headerlink" title="事务管理方式"></a>事务管理方式</h3><ul>
<li>编程式事务：使用硬编码（不推荐），通过TransactionTemplate或者TransactionManager手动管理事务</li>
<li>声明式事务：在XML配置文件中配置或者基于注解，实际上通过AOP实现（@Transactional全注解方式最常使用）</li>
</ul>
<p>@Transactional常用配置：</p>
<ul>
<li>propagation：传播行为</li>
<li>isolation：隔离级别</li>
<li>timeout：事务超时时间，如果超出这个时间限制事务还没有完成，会自动回滚</li>
<li>readOnly：指定事务是否为只读事务</li>
<li>rollbackFor：指定能触发事务回滚的异常类型，可以指定多个异常类型</li>
</ul>
<h3 id="传播行为的事务"><a href="#传播行为的事务" class="headerlink" title="传播行为的事务"></a>传播行为的事务</h3><p>事务传播是为了解决业务层方法之间相互调用的事务问题</p>
<p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。（继续在现有事务中运行或者开启一个新事务）</p>
<p>事务传播行为可能的值：</p>
<ul>
<li>TransactionDefintion.PROPAGATION_REQUIRED：propagation(传播) <strong>required</strong> 使用最多，@Transactional注解默认这个事务传播行为。如果当前存在事务，则加入该事务，如果当前没有事务，则创建一个新事务。</li>
<li>TransactionDefintion。PROPAGATION_REQUIRE_NEW：<strong>required new</strong> 创建一个新事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否已经开启事务，都开启一个新事务，事务之间相互独立</li>
<li>TransactionDefintion。PROPAGATION_NESTED：<strong>nested</strong>(嵌套) 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务运行，如果没有事务，则等价于TransactionDefintion.PROPAGATION_REQUIRED</li>
<li>TransactionDefintion.PROPAGATION_MANDATORY：<strong>mandatory</strong>(强制性）如果当前存在事务则加入事务，否则抛出异常</li>
</ul>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul>
<li>TransactionDefintion.ISOLATION_DEFAULT：<strong>Default</strong>后端数据库默认隔离级别，MySQL是REPEATABLE_READ隔离级别，ORACLE默认是READ_COMMITTED隔离级别</li>
<li>TransactionDefintion.ISOLATION_READ_UNCOMMITTED：read uncommitted， 最低的隔离级别，committed(提交)，允许读取尚未提交的数据变更，导致脏读幻读或者不可重复读</li>
<li>TransactionDefintion.ISOLATION_READ_COMMITTED：允许读取并发事务已经提交的数据，可以阻止脏读，幻读和不可重复读仍可能发生</li>
<li>TransactionDefintion.ISOLATION_REPEATABLE_READ：repeatable read，对同一字段多次读取结果一致，除非数据被本身事务自己修改，可以阻止脏读和不可重复读，幻读仍可能发生</li>
<li>TransactionDefintion.ISOLATION_SERIALIZABLE：serializable(串行的，可序列化的)，最高隔离级别，完全服从ACID。所有事务一次逐个执行。但是严重影响程序性能</li>
</ul>
<p>并发环境下会发生的一致性问题：</p>
<ul>
<li>脏读：读取到了其他事务未提交的数据，意味着这些数据有可能会回滚（实际上这些数据是不存在的数据）</li>
<li>不可重复读：在同一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一数据出现不一致</li>
<li>幻读：事务select某条记录发现不存在，准备insert，在insert时又发现这条数据存在无法插入</li>
</ul>
<h3 id="Transactional-rollbackFor-x3D-Exception-class-注解"><a href="#Transactional-rollbackFor-x3D-Exception-class-注解" class="headerlink" title="@Transactional(rollbackFor &#x3D; Exception.class)注解"></a>@Transactional(rollbackFor &#x3D; Exception.class)注解</h3><p>如果不配置Exception.ckass的rollback，只会在遇到RuntimeException才会回滚，配置rollbackFor &#x3D; Exception.class可以让其他的非运行时异常也回滚</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/15/Spring%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/" data-id="clix3qjvq000eqwuedvtw7bdx" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Spring事务失效问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/15/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2023-06-15T12:12:02.390Z" itemprop="datePublished">2023-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Spring事务失效问题"><a href="#Spring事务失效问题" class="headerlink" title="Spring事务失效问题"></a>Spring事务失效问题</h1><h2 id="1-方法没有被public修饰"><a href="#1-方法没有被public修饰" class="headerlink" title="1.方法没有被public修饰"></a>1.方法没有被public修饰</h2><p>官方文档：When using proxies, you should apply the @<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Transactional&spm=1001.2101.3001.7020">Transactional</a> annotation only to methods with <strong>public</strong> visibility. If you do annotate protected, private or package-visible methods with the @Transactional annotation, no error is raised, but the annotated method does not exhibit the configured transactional settings. Consider the use of AspectJ (see below) if you need to annotate non-public methods.</p>
<p>事务管理的方法必须由public修饰，编译器也会发现提醒，容易避免</p>
<h2 id="2-方法所在类没有被Spring管理"><a href="#2-方法所在类没有被Spring管理" class="headerlink" title="2.方法所在类没有被Spring管理"></a>2.方法所在类没有被Spring管理</h2><p>事务方法需要在被Spring管理的类中：即所在类需要被加载为Bean</p>
<h2 id="3-数据库引擎不支持事务"><a href="#3-数据库引擎不支持事务" class="headerlink" title="3.数据库引擎不支持事务"></a>3.数据库引擎不支持事务</h2><p>以MySQL为例，引擎中InnoDB支持事务，MyISAM不支持事务</p>
<h2 id="4-自身调用问题"><a href="#4-自身调用问题" class="headerlink" title="4.自身调用问题"></a>4.自身调用问题</h2><p>重要！</p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>一个类中定义了两个方法，他们之间存在相互调用：</p>
<p>黑马点评项目中为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VocherOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;VocherOrderMapper, VoucherOrder&gt; <span class="keyword">implements</span> <span class="title class_">IVoucherOrderService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	业务逻辑</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//创建订单提交</span></span><br><span class="line">        <span class="keyword">return</span> createVocherOrder(voucherId)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="comment">//创建订单并提交</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">createVocherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	方法体</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时事务会失效，原因是方法中调用<strong>同类</strong>方法省略了前缀this，不会经过Spring代理类。</p>
<p>类似拓展到一个事务中开启另一个事务(此时事务不会生效):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    insert();</span><br><span class="line">    </span><br><span class="line">    调用其他系统;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span>&#123;</span><br><span class="line">    向数据库中添加数据;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决方法（如何在一个事务中开启另一个事务）"><a href="#解决方法（如何在一个事务中开启另一个事务）" class="headerlink" title="解决方法（如何在一个事务中开启另一个事务）"></a>解决方法（如何在一个事务中开启另一个事务）</h3><p>对于上面的事务中开启另一个事务修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> ServiceB serviceB;</span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>&#123;</span><br><span class="line">    serviceB.insert();</span><br><span class="line">    调用其他系统;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceB</span> &#123;</span><br><span class="line">  <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span>&#123;</span><br><span class="line">    向数据库中添加数据;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确简化方法：</p>
<p>使用代理对象</p>
<p>步骤1：pom文件中写入坐标</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>步骤2：Spring启动类中开启暴露代理对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAspectJAutoProxy(exposeProxy = true)</span></span><br></pre></td></tr></table></figure>

<p>步骤3：在调用中使用AOP代理对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VocherOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;VocherOrderMapper, VoucherOrder&gt; <span class="keyword">implements</span> <span class="title class_">IVoucherOrderService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	业务逻辑</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//创建订单提交</span></span><br><span class="line">        <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">        <span class="keyword">return</span> proxy.createVocherOrder(voucherId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="comment">//创建订单并提交</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">createVocherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	方法体</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于这里AOP代理对象是基于动态代理的，根据接口创建代理对象，所以还需要在接口中写入方法</p>
<p>请加深对AOP的理解：</p>
<h2 id="5-异常没有被Spring事务捕获"><a href="#5-异常没有被Spring事务捕获" class="headerlink" title="5.异常没有被Spring事务捕获"></a>5.异常没有被Spring事务捕获</h2><p>Spring事务要根据异常回滚，如果异常没有捕捉则事务会失效</p>
<h2 id="6-异常类型问题"><a href="#6-异常类型问题" class="headerlink" title="6.异常类型问题"></a>6.异常类型问题</h2><p>事务默认回滚是RuntimeException，如果其他异常想要触发回滚，需要在注解上配置（仅限Throwable异常类及其子类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/15/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/" data-id="clix3qjvo000bqwue35v8120j" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Redis理论知识" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/15/Redis%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/" class="article-date">
  <time class="dt-published" datetime="2023-06-15T12:12:02.382Z" itemprop="datePublished">2023-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Redis的认识"><a href="#Redis的认识" class="headerlink" title="Redis的认识"></a>Redis的认识</h1><h2 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h2><p>开源的<strong>内存数据结构存储</strong>，用作数据库，缓存，消息代理和流引擎。</p>
<p>提供了数据结构例如字符串，散列，列表，集合，带范围查询的排序集合，位图，超日志，地理空间索引和流，对这些数据类型的操作都是原子性的</p>
<p>内置了赋值，Lua脚本，LRU驱逐，事务，多种集群方案（主从复制，哨兵，切片机），发布订阅模式，内存淘汰机制，过期删除机制和不同级别的磁盘持久性</p>
<h2 id="为什么用Redis做MySQL缓存"><a href="#为什么用Redis做MySQL缓存" class="headerlink" title="为什么用Redis做MySQL缓存"></a>为什么用Redis做MySQL缓存</h2><ol>
<li><p>Redis具备高性能</p>
<p>Redis直接操作内存，速度相当快</p>
</li>
<li><p>Redis具备高并发</p>
<p>单台设备QPS是SQL十倍</p>
</li>
</ol>
<h1 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h1><p>常见数据类型和使用场景</p>
<ul>
<li>String：缓存对象，常规计数，分布式锁，共享session信息</li>
<li>List：消息队列（有一定问题：生产者需要自行实现全局唯一id，不能消费组形式消费数据）</li>
<li>Hash：缓存对象，购物车</li>
<li>Set：聚合计算（交集，并集，差集等），点赞，共同关注，抽象活动</li>
<li>Zset：排序场景，排行榜，电话姓名等</li>
<li>BitMap：二值状态统计，签到，用户登陆状态，连续签到用户等</li>
<li>HyperLogLog：海量数据基数统计的场景，比如百万级的网页UV计数</li>
<li>GEO：存储地理位置信息</li>
<li>Stream：消息队列，可以自动生成全局唯一消息ID，支持以消费组形式消费数据</li>
</ul>
<h1 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h1><p>Redis是单线程，指Redis的[接收客户端请求-&gt;解析请求-&gt;进行数据读写等操作-&gt;发送数据给客户端]这一个过程都是由一个主线程来完成的。</p>
<p>但是Redis并不是单线程，在启动时还会启动后台进程：</p>
<ul>
<li>处理关闭文件</li>
<li>AOF刷盘</li>
<li>异步释放Redis内存的Lazyfree线程</li>
</ul>
<p>因为这些内存都比较耗时</p>
<h2 id="为什么Redis单线程还很快"><a href="#为什么Redis单线程还很快" class="headerlink" title="为什么Redis单线程还很快"></a>为什么Redis单线程还很快</h2><ul>
<li>Redis的大部分操作都在内存中完成，且使用高效的数据结构。所以Redis的瓶颈是机器内存或者网络带宽而不是CPU</li>
<li>单线程可以避免多线程的竞争，省去多线程切换带来的时间和性能上的开销，也不会出现死锁</li>
<li>采用I&#x2F;O多路复用机制处理大量客户端Socket请求。即一个线程处理多个IO流</li>
</ul>
<h2 id="为什么Redis6-0之后引入多线程"><a href="#为什么Redis6-0之后引入多线程" class="headerlink" title="为什么Redis6.0之后引入多线程"></a>为什么Redis6.0之后引入多线程</h2><p>因为随着网络硬件性能提升，Redis性能瓶颈会出现在网络I&#x2F;O处理上，为了提高网络I&#x2F;O并行度，Redis采用多线程，但是对于命令的执行还是使用单线程</p>
<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>三种持久化方式：AOF日志，RDB快照，混合持久化方式</p>
<h2 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h2><p>Redis执行一条写操作，就把命令以追加的方式写到一个文件中，当Redis重启会读取文件记录命令逐一执行来恢复数据</p>
<h3 id="为什么先执行命令再写入日志"><a href="#为什么先执行命令再写入日志" class="headerlink" title="为什么先执行命令再写入日志"></a>为什么先执行命令再写入日志</h3><p>好处</p>
<ul>
<li>避免额外检查开销：错误的命令无法执行，执行了命令保证语法通过</li>
<li>不会阻塞当前写操作命令的执行</li>
</ul>
<p>风险</p>
<ul>
<li>数据可能丢失，如果执行了命令还没来得及写入日志服务器宕机，数据就有丢失风险</li>
<li>可能阻塞其他操作：写操作执行成功才记录到AOF，不会阻塞当前命令。但是AOF日志也在主线程执行，写入磁盘时会阻塞后续操作</li>
</ul>
<h3 id="AOF写回策略"><a href="#AOF写回策略" class="headerlink" title="AOF写回策略"></a>AOF写回策略</h3><p>Redis写入AOF日志可以概括为：</p>
<ol>
<li>Redis执行写操作，将命令追加到server.aof_buf缓冲区</li>
<li>通过write()系统调用，写入AOF文件，还没写入到硬盘，拷贝到了内核缓冲区page cache，等待内核将数据写入硬盘</li>
<li>具体内核缓冲区数据什么时候写入硬盘由内核决定</li>
</ol>
<p>写回策略就是这里第三步什么时候写入硬盘</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230615111102495.png" alt="image-20230615111102495"></p>
<p>三种写回策略的优缺点</p>
<h2 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h2><h2 id="混合持久化方式"><a href="#混合持久化方式" class="headerlink" title="混合持久化方式"></a>混合持久化方式</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/15/Redis%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/" data-id="clix3qjvk0005qwue47pd77l6" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Redis缓存问题-穿透雪崩击穿" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/15/Redis%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98-%E7%A9%BF%E9%80%8F%E9%9B%AA%E5%B4%A9%E5%87%BB%E7%A9%BF/" class="article-date">
  <time class="dt-published" datetime="2023-06-15T12:12:02.379Z" itemprop="datePublished">2023-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Redis缓存问题"><a href="#Redis缓存问题" class="headerlink" title="Redis缓存问题"></a>Redis缓存问题</h1><h2 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1.缓存穿透"></a>1.缓存穿透</h2><h3 id="1-1-问题描述"><a href="#1-1-问题描述" class="headerlink" title="1.1.问题描述"></a>1.1.问题描述</h3><p>​		客户端请求数据在缓存层中和持久层（数据库）中都不存在，这样缓存永远不会生效，这些请求都会打到持久层，失去了缓存保护后端持久的意义。</p>
<p><img src="C:\Users\Bubble\Desktop\note\pic\缓存穿透.png" alt="缓存穿透"></p>
<div align = "center">缓存穿透示意</div>

<h3 id="1-2-解决方法"><a href="#1-2-解决方法" class="headerlink" title="1.2.解决方法"></a>1.2.解决方法</h3><ul>
<li><h4 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h4><p>向缓存中写入空值。</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230315164111509.png" alt="image-20230315164111509"></p>
<ul>
<li><strong>优点</strong>：实现简单，维护方便</li>
<li><strong>缺点</strong>（一般会为空值对象设置较短的TTL）：<ul>
<li>会造成额外内存消耗</li>
<li>可能造成短期内的不一致</li>
</ul>
</li>
</ul>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithPassThrough</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">//1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopjson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);</span><br><span class="line">        <span class="comment">//2.判断是否存在</span></span><br><span class="line">        <span class="comment">//3.存在直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isNotBlank(shopjson))&#123;</span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(shopjson, Shop.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断命中是否为空值,防止缓存穿透,之前isNotBlank判断中，空值和null都会跳出if</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//如果是空值不是null说明已经对不存在的key缓存了空值，视为命中</span></span><br><span class="line">        <span class="keyword">if</span> (shopjson != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.不存在，根据id查询数据库</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="comment">//5.不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//防止穿透，空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id,<span class="string">&quot;&quot;</span>,CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.存在，写入redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">//7.返回</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="布隆过滤"><a href="#布隆过滤" class="headerlink" title="布隆过滤"></a>布隆过滤</h4><p>​		访问缓存层和存储层之前，将存在的key用布隆过滤器提前保存起来，做第一层拦截，当收到一个对key请求时先用布隆过滤器验证是key否存在，如果存在在进入缓存层、存储层。可以使用bitmap做布隆过滤器。</p>
<p>​		布隆过滤器实际上是一个很长的二进制向量和一系列随机映射函数。类似哈希映射。如果判断存在则实际有可能不存在，如果判断不存在则一定不存在（类似哈希冲突）。因此不是百分百准确。</p>
</li>
</ul>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230315183102551.png" alt="image-20230315183102551"></p>
<ul>
<li><strong>优点</strong>：内存占用少，没有多余key</li>
<li><strong>缺点</strong>：<ul>
<li>实现复杂</li>
<li>存在误判可能</li>
</ul>
</li>
</ul>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用bitmap实现</span></span><br><span class="line"><span class="comment">//todo</span></span><br></pre></td></tr></table></figure>





<h2 id="2-缓存雪崩"><a href="#2-缓存雪崩" class="headerlink" title="2.缓存雪崩"></a>2.缓存雪崩</h2><h3 id="2-1-问题描述"><a href="#2-1-问题描述" class="headerlink" title="2.1.问题描述"></a>2.1.问题描述</h3><p>​		同一时段的大量缓存key同时失效或者redis服务宕机，此时大量请求会到达数据库产生压力。</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230315183942065.png" alt="image-20230315183942065"></p>
<h3 id="2-2-解决方法"><a href="#2-2-解决方法" class="headerlink" title="2.2.解决方法"></a>2.2.解决方法</h3><ul>
<li>缓存预热，使用缓存reload机制，预先更新缓存。给不同key的TTL添加随机值</li>
<li>利用redis集群提高服务可用性，利用sentinel或者cluster实现</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存</li>
</ul>
<h2 id="3-缓存击穿"><a href="#3-缓存击穿" class="headerlink" title="3.缓存击穿"></a>3.缓存击穿</h2><h3 id="3-1-问题描述"><a href="#3-1-问题描述" class="headerlink" title="3.1.问题描述"></a>3.1.问题描述</h3><p>​		被高并发访问，并且数据库重建业务比较复杂的key失效，此时会有大量线程来重建缓存，造成后端负载加大。</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230315184800659.png" alt="image-20230315184800659"></p>
<h3 id="3-2-解决方法"><a href="#3-2-解决方法" class="headerlink" title="3.2.解决方法"></a>3.2.解决方法</h3><ul>
<li>互斥锁<ul>
<li>优点：<ul>
<li>没有额外内存消耗</li>
<li>保持一致性</li>
<li>实现简单</li>
</ul>
</li>
<li>缺点<ul>
<li>线程需要等待，性能受到影响</li>
<li>有死锁风险</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230315190127940.png" alt="image-20230315190127940"></p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥锁解决缓存击穿</span></span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">shopjson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);</span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isNotBlank(shopjson))&#123;</span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(shopjson, Shop.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shopjson != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实现缓存重建</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取互斥锁</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">            <span class="comment">//判断是否成功</span></span><br><span class="line">            <span class="comment">//失败，休眠重试，成功，查数据库</span></span><br><span class="line">            <span class="comment">//这里递归实现不太好</span></span><br><span class="line">            <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//DoubleCheck</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">shopjson_dc</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);</span><br><span class="line">                <span class="keyword">if</span>(StrUtil.isNotBlank(shopjson))&#123;</span><br><span class="line">                    <span class="keyword">return</span> JSONUtil.toBean(shopjson_dc, Shop.class);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shopjson_dc != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            shop = getById(id);</span><br><span class="line">            <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//数据库也没有，防止穿透，写入空值</span></span><br><span class="line">                stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, <span class="string">&quot;&quot;</span>,CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放互斥锁</span></span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">            <span class="comment">//setIfAbsent等价于redis语句的setnx，key不存在时才可以设置</span></span><br><span class="line">            <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="comment">//返回基本类型，flag是封装类型，会自动拆箱，容易出现空指针异常，使用工具类防止报异常</span></span><br><span class="line">            <span class="keyword">return</span> BooleanUtil.isTrue(flag);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>逻辑过期<ul>
<li>优点：线程无需等待，性能比较好</li>
<li>缺点<ul>
<li>不一致性</li>
<li>有额外内存消耗</li>
<li>实现复杂</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>实现：将原本key的数据加上逻辑时间封装到新的类中保存到redis。</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230315185909234.png" alt="image-20230315185909234"></p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逻辑过期解决缓存击穿</span></span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithLogicalExpire</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">        <span class="type">String</span> <span class="variable">shopjson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    	<span class="comment">//实际上有的key一定会在缓存中只是逻辑时间超时，未命中的肯定是没有的key</span></span><br><span class="line">        <span class="comment">//缓存未命中返回空</span></span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isBlank(shopjson))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//命中，json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(shopjson, RedisData.class);</span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">//未过期返回</span></span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now()))&#123;</span><br><span class="line">            <span class="keyword">return</span> shop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//过期缓存重建</span></span><br><span class="line">        <span class="comment">//获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">//成功开启独立线程重建</span></span><br><span class="line">        <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">            <span class="comment">//使用线程池来重建</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(()-&gt;&#123;</span><br><span class="line">                <span class="comment">//重建</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//save2Redis(key,expireScond)更新key的过期时间</span></span><br><span class="line">                    <span class="built_in">this</span>.saveShop2Redis(id, <span class="number">20L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放锁</span></span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//失败返回过期商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/15/Redis%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98-%E7%A9%BF%E9%80%8F%E9%9B%AA%E5%B4%A9%E5%87%BB%E7%A9%BF/" data-id="clix3qjvk0006qwue6ecif7nl" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Leecode" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/15/Leecode/" class="article-date">
  <time class="dt-published" datetime="2023-06-15T12:12:02.372Z" itemprop="datePublished">2023-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Leecode算法题"><a href="#Leecode算法题" class="headerlink" title="Leecode算法题"></a>Leecode算法题</h1><h2 id="岛屿问题"><a href="#岛屿问题" class="headerlink" title="岛屿问题"></a>岛屿问题</h2><p>需要熟悉网格类问题的DFS：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先看熟悉的树的dfs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">treeDfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="comment">//结束遍历的条件</span></span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    dfs(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">    <span class="comment">//同样节点不在网格中结束遍历</span></span><br><span class="line">    <span class="keyword">if</span>(!inGrid(grid,r,c)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//如果遍历到的不是岛屿就返回</span></span><br><span class="line">    <span class="keyword">if</span>(grid[r][c] != <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//将访问过的岛屿置2防止重复访问</span></span><br><span class="line">    grid[r][c] = <span class="number">2</span>;</span><br><span class="line">    dfs(grid, r-<span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r+<span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c-<span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">inGrid</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>&lt;=r &amp;&amp; r&lt;grid.length &amp;&amp; <span class="number">0</span>&lt;=c &amp;&amp; c&lt;grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Leecode695：岛屿最大面积（Medium）"><a href="#Leecode695：岛屿最大面积（Medium）" class="headerlink" title="Leecode695：岛屿最大面积（Medium）"></a>Leecode695：岛屿最大面积（Medium）</h3><p>遍历的时候遇到岛屿面积+1即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxAreaOfIsland</span><span class="params">(<span class="type">int</span>[][] grid)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                res = Math.max(res, dfs(grid,i,j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!inGrid(grid,r,c)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(grid[r][c] != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+dfs(grid,c-<span class="number">1</span>,r)+dfs(grid,c+<span class="number">1</span>,r)+dfs(grid,c,r-<span class="number">1</span>)+dfs(grid,c,r+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">boolean</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r&gt;=<span class="number">0</span> &amp;&amp; r&lt;grid.length &amp;&amp; c&gt;=<span class="number">0</span> &amp;&amp; c&lt;grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Leecode827：填海造岛（Hard）"><a href="#Leecode827：填海造岛（Hard）" class="headerlink" title="Leecode827：填海造岛（Hard）"></a>Leecode827：填海造岛（Hard）</h3><p>最大面积问题升级版，可以把一个海洋变成陆地，最大可以构造多大岛屿</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230530210711808.png" alt="image-20230530210711808"></p>
<p>一个海洋格子跟两个不同的岛屿相邻，就可以得到改变之后的面积是两边的岛屿面积+1。用岛屿面积标记不同岛屿会出现重复，要用一个新的数组存放索引和面积，用索引标记岛屿。</p>
<p>这样需要第一遍dfs遍历岛屿并标记，第二遍遍历海洋，找到有两个不同岛屿相邻的海洋计算改造后的大小</p>
<h3 id="Leecode463：岛屿周长（Easy）"><a href="#Leecode463：岛屿周长（Easy）" class="headerlink" title="Leecode463：岛屿周长（Easy）"></a>Leecode463：岛屿周长（Easy）</h3><p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230530212512858.png" alt="image-20230530212512858"></p>
<p>最好的方法不是dfs，但是可以用来练习dfs</p>
<p>当dfs遍历到超出grid的节点就说明走过了一条黄色的和网络边界相邻的边，走到海洋节点就说明走过了一条蓝色的和海洋格子相邻的边</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!inGrid(grid,r,c)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(grid[r][c] == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(grid[r][c] == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> dfs(grid, r - <span class="number">1</span>, c)</span><br><span class="line">        + dfs(grid, r + <span class="number">1</span>, c)</span><br><span class="line">        + dfs(grid, r, c - <span class="number">1</span>)</span><br><span class="line">        + dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Leecode200：岛屿数量"><a href="#Leecode200：岛屿数量" class="headerlink" title="Leecode200：岛屿数量"></a>Leecode200：岛屿数量</h3><p>统计岛屿的数量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;grid.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt;grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    dfs(grid,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!inGrid(grid, r, c)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[r][c] != <span class="string">&#x27;1&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        grid[r][c] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        dfs(grid,r-<span class="number">1</span>,c);</span><br><span class="line">        dfs(grid,r+<span class="number">1</span>,c);</span><br><span class="line">        dfs(grid,r,c-<span class="number">1</span>);</span><br><span class="line">        dfs(grid,r,c+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">inGrid</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> r&gt;=<span class="number">0</span> &amp;&amp; r&lt;grid.length &amp;&amp; c&gt;=<span class="number">0</span> &amp;&amp; c&lt;grid[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="Leecode-SQL题"><a href="#Leecode-SQL题" class="headerlink" title="Leecode SQL题"></a>Leecode SQL题</h1><h2 id="176-第二高的薪水"><a href="#176-第二高的薪水" class="headerlink" title="176.第二高的薪水"></a>176.第二高的薪水</h2><p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230404194318064.png" alt="image-20230404194318064"></p>
<p>查询第二高薪水：</p>
<ul>
<li><p>按照薪水降序排序（Order By salary DESC）</p>
</li>
<li><p>不存在输出null</p>
<ul>
<li><p>使用<code>IFNULL</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    IFNULL(</span><br><span class="line">      (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Salary</span><br><span class="line">       <span class="keyword">FROM</span> Employee</span><br><span class="line">       <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span></span><br><span class="line">        LIMIT <span class="number">1</span> <span class="keyword">OFFSET</span> <span class="number">1</span>),</span><br><span class="line">    <span class="keyword">NULL</span>) <span class="keyword">AS</span> SecondHighestSalary</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>(<code>IFNULL() </code>函数用于判断第一个表达式是否为 NULL，如果为 NULL 则返回第二个参数的值，如果不为 NULL 则返回第一个参数的值)</p>
<ul>
<li>重复值怎么办：DISTINCT关键字去重</li>
</ul>
<p>拓展到第N高的薪水</p>
<h2 id="177-第N高的薪水"><a href="#177-第N高的薪水" class="headerlink" title="177.第N高的薪水"></a>177.第N高的薪水</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">set</span> N <span class="operator">=</span> N<span class="number">-1</span>; </span><br><span class="line">  <span class="keyword">RETURN</span> (</span><br><span class="line">      # Write your MySQL query statement below.</span><br><span class="line">      <span class="keyword">select</span> IFNULL(</span><br><span class="line">          (<span class="keyword">select</span> <span class="keyword">distinct</span> salary</span><br><span class="line">          <span class="keyword">from</span> Employee</span><br><span class="line">          <span class="keyword">Order</span> <span class="keyword">By</span> salary <span class="keyword">DESC</span></span><br><span class="line">          Limit N,<span class="number">1</span>)</span><br><span class="line">          ,<span class="keyword">null</span>) <span class="keyword">as</span> getNthHighestSalary</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<ol>
<li>limit后的起始值和计数值都只接受整数</li>
<li>对函数中的变量改变，使用set</li>
</ol>
<h2 id="178-分数排名"><a href="#178-分数排名" class="headerlink" title="178.分数排名"></a>178.分数排名</h2><p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230404201021061.png" alt="image-20230404201021061"></p>
<p><code>rank()</code>函数的使用</p>
<ul>
<li>rank() over (排序条件)：排名不一定连续（有两个第一名，就没有第二名，直接下一个第三名）</li>
<li>dense_rank() over (排序条件)：密集排名，排名连续（两个第一名，第三个人还是第二名）</li>
<li>row_number() over(排序条件)：没有并列，排名连续不重复</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> score, <span class="built_in">dense_rank</span>() <span class="keyword">over</span> (<span class="keyword">Order</span> <span class="keyword">By</span> score <span class="keyword">DESC</span>) `rank`</span><br><span class="line"><span class="keyword">from</span> Scores;</span><br></pre></td></tr></table></figure>

<h2 id="180-连续出现数字"><a href="#180-连续出现数字" class="headerlink" title="180.连续出现数字"></a>180.连续出现数字</h2><ol>
<li>连续出现</li>
<li>group by后的having</li>
</ol>
<h2 id="183-从不订购的客户"><a href="#183-从不订购的客户" class="headerlink" title="183.从不订购的客户"></a>183.从不订购的客户</h2><p>判断是否是<code>null</code>要使用<code>xx is Null</code>而不是<code>xx = Null</code></p>
<h2 id="184-部门工资最高员工"><a href="#184-部门工资最高员工" class="headerlink" title="184.部门工资最高员工"></a>184.部门工资最高员工</h2><p>分组在Employee中查出每个部门Id和最高的工资，然后用内连接连接两个表使用IN查询满足各个部门最高工资的条件。</p>
<h2 id="196-删除重复邮箱"><a href="#196-删除重复邮箱" class="headerlink" title="196.删除重复邮箱"></a>196.删除重复邮箱</h2><p>用person表选出最小id和email，连接到原始person表（原person左连接选出的），然后delete null的记录</p>
<h2 id="197-上升的气温（找比前一日温度高的日子）"><a href="#197-上升的气温（找比前一日温度高的日子）" class="headerlink" title="197.上升的气温（找比前一日温度高的日子）"></a>197.上升的气温（找比前一日温度高的日子）</h2><p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230405133802667.png" alt="image-20230405133802667"></p>
<p>1.窗口函数LAG</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span></span><br><span class="line">  (<span class="keyword">select</span> <span class="operator">*</span>,</span><br><span class="line">  <span class="built_in">LAG</span>(Temperature, <span class="number">1</span>) <span class="keyword">over</span>(<span class="keyword">Order</span> <span class="keyword">By</span> recordDate) <span class="keyword">As</span> yd </span><br><span class="line">  <span class="keyword">from</span> Weather) <span class="keyword">new</span></span><br><span class="line"><span class="keyword">where</span> new.yd <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">NULL</span> <span class="keyword">and</span> new.Temperature <span class="operator">&gt;</span> new.yd;</span><br></pre></td></tr></table></figure>

<p>按照日期排序，但是无法处理日期不连续时的问题</p>
<p>2.DATEDIFF</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> w2.id <span class="keyword">from</span></span><br><span class="line">  Weather w1, Weather w2</span><br><span class="line">  <span class="keyword">where</span> DATEDIFF(w2.recordDate, w1.recordDate) <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> w2.Temperature <span class="operator">&gt;</span> w1.Temperature</span><br><span class="line">;</span><br></pre></td></tr></table></figure>



<h2 id="511-游戏玩法分析"><a href="#511-游戏玩法分析" class="headerlink" title="511.游戏玩法分析"></a>511.游戏玩法分析</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#比较以下两种查询区别</span><br><span class="line">#<span class="number">1</span></span><br><span class="line"><span class="keyword">select</span> player_id, <span class="built_in">MIN</span>(event_date) <span class="keyword">as</span> first_login </span><br><span class="line"><span class="keyword">from</span> Activity</span><br><span class="line"><span class="keyword">Group</span> <span class="keyword">By</span> player_id;</span><br><span class="line"></span><br><span class="line">#<span class="keyword">Having</span>指定的是分组后显示的组的条件，无法对组里的条件进行约束</span><br><span class="line">#<span class="number">2</span></span><br><span class="line"><span class="keyword">select</span> player_id, event_date <span class="keyword">as</span> first_login </span><br><span class="line"><span class="keyword">from</span> Activity</span><br><span class="line"><span class="keyword">Group</span> <span class="keyword">By</span> player_id</span><br><span class="line"><span class="keyword">Having</span> event_date <span class="operator">=</span> <span class="built_in">MIN</span>(event_date);</span><br></pre></td></tr></table></figure>

<h2 id="550-游戏玩法分析IV"><a href="#550-游戏玩法分析IV" class="headerlink" title="550.游戏玩法分析IV"></a>550.游戏玩法分析IV</h2><p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230405145341203.png" alt="image-20230405145341203"></p>
<p>查询首次登陆后连续登录两天的玩家数量：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">from</span> Activity a <span class="keyword">Left</span> <span class="keyword">Join</span> </span><br><span class="line">(<span class="keyword">select</span> player_id, <span class="built_in">MIN</span>(event_date) <span class="keyword">As</span> first_login</span><br><span class="line"><span class="keyword">from</span> Activity</span><br><span class="line"><span class="keyword">Group</span> <span class="keyword">By</span> player_id) fl</span><br><span class="line"><span class="keyword">on</span> a.player_id <span class="operator">=</span> fl.player_id</span><br><span class="line"><span class="keyword">where</span> DATEDIFF(a.event_date, fl.first_login) <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>如何在这里除以玩家总数<code>select count(Distinct player_id)</code>，进一步要用round四舍五入<code>round(value,n)</code>，n为小数点后位数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> round(player_num.num<span class="operator">/</span><span class="built_in">count</span>(<span class="keyword">Distinct</span> player_id),<span class="number">2</span>) <span class="keyword">as</span> fraction </span><br><span class="line"><span class="keyword">from</span> Activity,</span><br><span class="line">(<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num</span><br><span class="line"><span class="keyword">from</span> Activity a <span class="keyword">Left</span> <span class="keyword">Join</span> </span><br><span class="line">(<span class="keyword">select</span> player_id, <span class="built_in">MIN</span>(event_date) <span class="keyword">As</span> first_login</span><br><span class="line"><span class="keyword">from</span> Activity</span><br><span class="line"><span class="keyword">Group</span> <span class="keyword">By</span> player_id) fl</span><br><span class="line"><span class="keyword">on</span> a.player_id <span class="operator">=</span> fl.player_id</span><br><span class="line"><span class="keyword">where</span> DATEDIFF(a.event_date, fl.first_login) <span class="operator">=</span> <span class="number">1</span>) player_num</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>我自己的做法效率有点低</p>
<h2 id="584-寻找用户推荐人"><a href="#584-寻找用户推荐人" class="headerlink" title="584.寻找用户推荐人"></a>584.寻找用户推荐人</h2><p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230524212130639.png" alt="image-20230524212130639"></p>
<p>很直观想到一个where判断 <code>referee_id != 2</code>，或者&lt;&gt;符号判断不等于。但是结果就输出了一个Zack，referee_id&#x3D;NULL的都没输出</p>
<p>因为MySQL使用三值逻辑，除了True和False以外还有UNKNOWN。任何和NULL比较都会变成与UNKNOWN比较，所以和NULL比较要用<code>IS NULL</code>和<code>IS NOT NULL</code>。所以对于可能有NULL值的字段要单独判断</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> customer <span class="keyword">WHERE</span> referee_id <span class="operator">&lt;&gt;</span> <span class="number">2</span> <span class="keyword">OR</span> referee_id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
























      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/15/Leecode/" data-id="clix3qjvi0003qwue2yuo76rl" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JVM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/15/JVM/" class="article-date">
  <time class="dt-published" datetime="2023-06-15T12:12:02.366Z" itemprop="datePublished">2023-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JVM（JAVA虚拟机）"><a href="#JVM（JAVA虚拟机）" class="headerlink" title="JVM（JAVA虚拟机）"></a>JVM（JAVA虚拟机）</h1><h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230319195806332.png" alt="image-20230319195806332"></p>
<h3 id="线程私有空间"><a href="#线程私有空间" class="headerlink" title="线程私有空间"></a>线程私有空间</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>可以视作当前线程执行的字节码的行号指示器。</p>
<p>作用：</p>
<ul>
<li>字节码解释器通过改变程序计数器来依次读取指令从而实现代码的<strong>流程控制</strong></li>
<li>在多线程情况下，程序计数器用于<strong>记录当前线程执行的位置</strong>，线程被切换回来时候知道上次运行到哪</li>
</ul>
<p>注意：程序计数器是唯一不会出现<code>OutOfMemoryError</code>的内存区域，生命周期随着线程创建而生，线程结束而亡</p>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>所有Java方法都是通过调用栈来实现的。方法的调用数据需要通过栈来传递，每一次方法调用都会有对应的栈帧被压入栈，每一个方法结束都会有一个栈帧被弹出。每一个栈帧包括：局部变量表，操作数栈，动态链接，方法返回地址。</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230320211644627.png" alt="image-20230320211644627"></p>
<p><strong>局部变量表：</strong>存放编译期可知的<strong>数据类型</strong>（8种基本数据类型），<strong>对象引用</strong>（reference类型，可能是指向对象起始地址的引用指针也有可能是对象句柄）</p>
<p><strong>操作数栈：</strong>主要作为方法调用的中转站，用于存放方法执行过程中产生的中间计算结果。以及计算过程中产生的临时变量</p>
<p><strong>动态链接：</strong>服务一个方法需要调用其他方法的场景。动态链接定义为——将<strong>符号引用</strong>转换为调用方法的<strong>直接引用</strong>。符号引用保存在Class文件的常量池中，一个方法要调用其他方法时需要将常量池中指向方法的符号引用转化为在内存地址中的直接引用</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230320213759506.png" alt="image-20230320213759506"></p>
<p>当函数调用陷入循环会导致栈中压入太多栈帧，会出现错误。</p>
<p><strong>栈空间中出现的两种错误</strong></p>
<ul>
<li>**<code>StackOverFlowError</code>**：若内存大小不允许动态扩展，那么当线程请求栈的深度超过当前虚拟机栈的最大深度时就会抛出<code>StackOverFlowError</code>错误。</li>
<li>**<code>OutOfMemoryError</code>**：若栈的内存大小可以动态扩展，如果虚拟机在动态扩展栈时无法申请到足够内存空间就会抛出<code>OutOfMemoryError</code>错误。</li>
</ul>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>作用类似虚拟机栈，虚拟机栈为虚拟机执行Java方法（字节码）服务，本地方法栈给虚拟机使用的Native方法服务。在HotSpot虚拟机中与Java虚拟机栈合二为一。</p>
<h3 id="线程共享空间"><a href="#线程共享空间" class="headerlink" title="线程共享空间"></a>线程共享空间</h3><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>Java虚拟机管理内存最大的一块，所有线程共享，唯一目的就是存放<strong>对象实例</strong>，几乎所有的对象实例和数据都在这里分配内存。（JDK1.7开始默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（未逃逸），那么对象可以直接在栈上分配内存。）</p>
<p>Java堆是垃圾收集器管理的主要区域，因此也可称GC堆（Garbage Collected Heap）。由于收集器都采用分代垃圾收集算法，因此Java堆还可以细分：新生代和老年代，再进一步还有：Eden，Survivor，Old等空间。细分的目的在于更好更高效的管理分配内存。</p>
<p>JDK7之前，堆内存分为以下三部分：</p>
<ol>
<li>新生代内存（Young Generation）</li>
<li>老生代（Old Generation）</li>
<li>永久代（Permanent Generation）</li>
</ol>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230321212200400.png" alt="image-20230321212200400"></p>
<p>如图，Eden和两个Survivor区S0和S1都属于新生代，中间属于老年代，最下面一层MetaSpace属于永久代。</p>
<p>对象首先在Eden区域分配，在一次新生代垃圾回收后，如果对象还存活会进入S0或者S1，同时对象年龄+1，当年龄增加到一定程度（默认15），就会晋升到老年代。这个年龄阈值可以通过参数<code>-XX:MaxTenuringThreshold</code>来设置。</p>
<p>Hotspot动态年龄计算算法：</p>
<p>先遍历所有的对象按照年龄从小到大对占有的大小进行累积（即计算某年龄以下的所有空间），当累积的大小超过Survivor区的一半时，取这个年龄和MaxTenuringThreshold中的较小值作为新的晋升年龄阈值。</p>
<p><strong>容易出现的错误：</strong><code>OutOfMemoryError</code></p>
<ol>
<li><strong><code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li>
<li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过<code>-Xmx</code>参数配置，若没有特别配置，将会使用默认值)</li>
</ol>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>JVM运行时数据区域的一块逻辑区域，各线程共享。</p>
<p>当虚拟机要使用一个类时，会读取解析Class文件相关信息，然后存入方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p>
<p>改到MetaSpace的原因：基于本地内存，内存溢出的几率会更小。</p>
<p>元空间溢出错误：<code>java.lang.OutOfMemoryError: MetaSpace</code></p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>Class文件除了方法区中的信息外，还有存放编译时期产生的各种字面量（Literal）和符号引用（Symbolic Reference）（虚拟机栈中动态链接有提到）的常量池表。</p>
<p>无法申请到内存会抛出 <code>OutOfMemoryError</code> </p>
<h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p>为了提升性能减少内存消耗针对字符串（String类）专门开辟的区域，为了避免字符串重复创建。当创建的字符串在常量池中已经有时，会直接引用。JDK1.7字符串常量池和静态变量从永久代移到了java堆中。（因为永久代GC的回收效率太低）</p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>一种特殊的内存缓冲区，不再堆或者方法区中分配，在JNI方式在本地内存上分配，不是虚拟机运行时数据区的一部分，也不是虚拟机规范定义的区域，但是被频繁的用到</p>
<h3 id="HotSpot虚拟机"><a href="#HotSpot虚拟机" class="headerlink" title="HotSpot虚拟机"></a>HotSpot虚拟机</h3><h4 id="对象创建（重要）"><a href="#对象创建（重要）" class="headerlink" title="对象创建（重要）"></a>对象创建（重要）</h4><p><strong>Step1：类加载检查</strong></p>
<p>首先检查是否能在常量池中找到这个类的符号引用。</p>
<p>并检查这个符号引用代表的类是否被加载，解析，初始化过。</p>
<p>如果没有那必须执行相应<strong>类加载</strong>过程。</p>
<p><strong>Step2：分配内存</strong></p>
<p>类加载检查通过后，虚拟机将为新生对象分配内存。对象需要空间大小在类加载后就可以确定。分配方式有<strong>“指针碰撞”</strong>和<strong>“空闲列表”</strong>。如何选择由Java堆是否规整决定，堆是否规整又由采用的垃圾收集器是否带有压缩整理功能决定。</p>
<p>内存分配方式（需掌握）：</p>
<ul>
<li><p>指针碰撞</p>
<ul>
<li>适用场景：堆内存规整（没有内存碎片）</li>
<li>原理：用过的内存全整合到一边，与没用过的内存适用分界指针隔开，向着没用过的内存方向移动指针，移动对象内存需要的大小位置即可。</li>
<li>适用分配方式的GC收集器：Serial，ParNew</li>
</ul>
</li>
<li><p>空闲列表</p>
<ul>
<li>适用场景：堆内存不规整</li>
<li>原理：虚拟机维护一个列表，记录哪些内存块可用，分配时找一块足够大小的划分给对象实例，然后更新列表</li>
<li>使用分配方式的GC收集器：CMS</li>
</ul>
</li>
</ul>
<p>内存分配的并发问题（需掌握）：</p>
<p>虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li>CAS(同步处理)+失败重试：乐观锁（假设没有冲突完成操作，一旦因为冲突失败了才重试，直到成功）的一种实现方式。使用CAS+失败重试可以保证更新操作的原子性。</li>
<li>TLAB(本地线程分配缓存)：为每一个线程预先在Eden分配一块内存，JVM给线程的对象分配内存时首先在TLAB中分配。当对象大于TLAB的剩余内存或者内存已用尽，再采用上述的CAS分配内存。</li>
</ul>
<p><strong>Step3：初始化零值</strong></p>
<p>内存分配之后，虚拟机对分配的内存空间初始化为零值（不包括对象头），保证了对象实例在代码中不赋初始值就可以直接使用，程序可以直接访问对应数据类型对应的零值。</p>
<p><strong>Step4：设置对象头</strong></p>
<p>对象是哪个类的实例，如何找到类的元数据信息，对象哈希码，对象GC分代年龄等信息写入对象头。虚拟机并根据当前运行状态不同，如是否启用偏向锁，对对象头设置方式会有不同。</p>
<p><strong>Step5：执行init方法</strong></p>
<p>对对象开始初始化成员字段</p>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>java对象的存储布局：</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230319204718723.png" alt="image-20230319204718723"></p>
<ul>
<li>对象头：Java对象头占用2个机器码（如果对象是数组则需要3个）</li>
<li>实例数据：存放类的属性数据信息，包括父类的属性信息</li>
<li>对齐填充：因为虚拟机要求，对象起始地址必须是8字节整数倍</li>
</ul>
<p>对象头内容：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f8f5088839a9f1e36a3dd84e80c572e3.png" alt="img"></p>
<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>通过栈上的reference来操作堆上的具体对象，访问方式由虚拟机实现，主流有：<strong>使用句柄</strong>，<strong>直接指针</strong></p>
<ul>
<li><p>使用句柄</p>
<p>堆会划分一块内存作为句柄池，reference存储句柄地址，句柄包含了对象实例数据和对象类型数据各自的具体地址信息</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/access-location-of-object-handle.png" alt="对象的访问定位-使用句柄"></p>
</li>
<li><p>直接指针</p>
<p>reference直接存储对象地址</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/access-location-of-object-handle-direct-pointer.png" alt="对象的访问定位-直接指针"></p>
</li>
</ul>
<p>句柄方式的好处是reference存储稳定句柄地址，对象被移动只要改变句柄的实例数据指针，不用更改reference</p>
<p>直接指针优势是速度快，节省了一次指针定位的时间开销</p>
<h2 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h2><h3 id="内存分配和回收原则"><a href="#内存分配和回收原则" class="headerlink" title="内存分配和回收原则"></a>内存分配和回收原则</h3><p>大多数情况下，对象在新生代的的Eden分配，当Eden区没有足够空间进行分配时，虚拟机会发起一次Minor GC。</p>
<h4 id="大对象"><a href="#大对象" class="headerlink" title="大对象"></a>大对象</h4><p>大对象（需要大量连续内存空间，比如字符串和数组）直接进入老年代，因为为了避免大对象分配内存时由于分配担保机制带来的复制而降低效率。</p>
<h4 id="长期存活对象"><a href="#长期存活对象" class="headerlink" title="长期存活对象"></a>长期存活对象</h4><p>虚拟机给了每个对象一个年龄（Age）计数器：</p>
<p>对象在Eden出生并经过第一次Minor GC后仍然存活，且被Survivor容纳被移动到Survivor空间的s0或者s1时，对象年龄设置为1。（Eden区-&gt;Survivor区后对象初始年龄变为1）</p>
<p>在Survivor区每熬过一次Minor GC，年龄增加1岁，当年龄增加到一定程度（默认15岁，可以通过参数<code>-XX:MaxTenuringThreshold</code>设置），就会被晋升到老年代。</p>
<p>Hotspot对老年代的年龄晋升阈值动态计算：</p>
<p>先遍历所有的对象按照年龄从小到大对占有的大小进行累积（即计算某年龄以下的所有空间），当累积的大小超过Survivor区的一半时，取这个年龄和MaxTenuringThreshold中的较小值作为新的晋升年龄阈值。</p>
<h4 id="主要进行GC的区域"><a href="#主要进行GC的区域" class="headerlink" title="主要进行GC的区域"></a>主要进行GC的区域</h4><p>GC准确分类主要有两大种</p>
<ul>
<li><p>部分收集（Partial GC）：</p>
<ul>
<li>新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集；</li>
<li>老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。注意Major在有的语境中也用于指代整堆收集</li>
<li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集</li>
</ul>
</li>
<li><p>整堆收集（Full GC）：整个Java堆和方法区</p>
</li>
</ul>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>为了确保在Minor GC之前老年代本身还有容纳新生代所有对象的剩余空间</p>
<h3 id="死亡对象的判断方法"><a href="#死亡对象的判断方法" class="headerlink" title="死亡对象的判断方法"></a>死亡对象的判断方法</h3><p>垃圾回收的第一步：判断哪些对象已经死亡（不能再被任何途径使用的对象）</p>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>给对象添加一个引用计数器</p>
<ul>
<li>每当有一个地方引用，计数器就+1</li>
<li>当引用失效，计数器-1</li>
<li>任何时候计数器为0的对象就是不可能再次被使用</li>
</ul>
<p>实现简单，效率高。但是主流虚拟机没有选择这个算法，原因是很难解决对象之间相互循环引用的问题。</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>基本思想是通过一系列的称为”GC Roots“的对象作为起点，从这些节点向下搜索，节点所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连证明此对象不可用，需要被回收。</p>
<p>如果对象之间有引用关系，但是GC Roots不可达，还是会成为需要回收的对象</p>
<p>可以作为GC Roots的对象：</p>
<ul>
<li>虚拟机栈（帧栈中的本地变量表）中引用的对象</li>
<li>本地方法栈（Native方法）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
</ul>
<p>判断对象可以被回收就一定会被回收吗？</p>
<p>真正判断一个对象死亡，要经过两次标记过程。可达性分析的不可达对象被第一次标记且进行一次筛选，筛选条件是此对象是否有必要执行<code>finalize</code>方法。当对象没有覆盖<code>finalize</code>方法或者已经被虚拟机调用过时，这两种情况视为没必要执行对象死亡。判断为需要执行死亡的对象会被放在一个队列中进行二次标记，除非这个对象和引用链上任何一个对象建立关联，否则就会被真的回收。</p>
<p><code>Object</code>的<code>finalize</code>方法加重了Java语言的负担，影响了Java语言的安全性和GC性能。在JDK9后续版本各个类的<code>finlize</code>方法被逐渐弃用移除。</p>
<p>引用计数法和可达性分析法判断是否可达，都和引用有关，引用分为：</p>
<ul>
<li>强引用</li>
</ul>
<p>大部分引用，如果一个对象有强引用，垃圾回收器就绝不会回收。当内存不足时宁愿抛出OutOfMemoryError错误也不会随意回收有强引用的对象</p>
<ul>
<li>软引用</li>
</ul>
<p>类似于可有可无，内存足够就不会回收，内存不足就会回收。软引用可以用来实现内存敏感的高速缓存。</p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列。</p>
<ul>
<li>弱引用</li>
</ul>
<p>弱引用与软引用的区别：只有弱引用的对象拥有更短暂的生命周期。当垃圾回收器发现弱引用对象，不管内存是否充足都会回收。</p>
<p>也可以和软引用一样和引用队列回收使用</p>
<ul>
<li>虚引用</li>
</ul>
<p>形同虚设，等价于没有引用，任何时候都可能会被垃圾回收。与弱引用软引用主要的区别：必须结合引用队列使用。当虚引用的对象被加入引用队列就可以在被回收前采取必要行动。</p>
<p>一般程序设计很少使用弱引用和虚引用，软引用使用比较多。因为软引用可以加速JVM对垃圾回收的回收速度，维护系统运行安全，防止内存溢出。</p>
<h4 id="判断废弃常量"><a href="#判断废弃常量" class="headerlink" title="判断废弃常量"></a>判断废弃常量</h4><p>假如字符串常量池中有一个字符串，如果当前没有任何String对象引用这个字符串常量就说明这个字符串就是废弃常量，内存回收的时候会被清理。</p>
<h4 id="判断无用类"><a href="#判断无用类" class="headerlink" title="判断无用类"></a>判断无用类</h4><p>同时满足三个条件可以被回收，不是必然回收：</p>
<ul>
<li>该类的所有实例都已经被回收，即Java堆中不存在该类任何实例</li>
<li>加载该类的<code>ClassLoader</code>已经被回收</li>
<li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>最基础的收集算法：先标记出所有<strong>不需要回收</strong>的对象，标记完成后统一回收所有没有标记的对象。</p>
<p>两个明显问题：</p>
<ol>
<li>效率问题</li>
<li>空间问题（产生大量不连续的碎片）</li>
</ol>
<p><img src="https://javaguide.cn/assets/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.c1fbd0fe.jpeg" alt="img"></p>
<h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><p>将内存分为大小相同的两块，每次使用其中一块，当这一块内存使用完后，将还存活的对象复制到另一块，然后清理使用的空间。这样每次的内存回收都对内存区间的一半进行</p>
<p><img src="https://javaguide.cn/assets/90984624.e8c186ae.png" alt="复制算法"></p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>根据老年代的特点提出的一种标记算法，过程仍然和””标记-清除”算法一样，但是不是直接对可回收对象回收，而是让所有存活对象向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><img src="https://javaguide.cn/assets/94057049.22c58294.png" alt="标记-整理算法 "></p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，根据每个年代的特点选择合适的垃圾收集算法。</p>
<p>新生代每次收集都会有大量对象死去，可以选择“标记-复制”算法，因为复制对象的成本很小。老年代对象存活的几率比较高，而且没有额外的空间对它进行分配担保，所以选择“标记-清除”或者“标记-整理”算法进行垃圾收集。</p>
<p>延申面试问题：为什么HotSpot要分新生代和老年代？可以根据这里分代收集算法的介绍回答</p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>垃圾收集器是内存回收的具体实现。垃圾收集器有多种，要根据应用场景选择适合自己的垃圾收集器</p>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>Serial（串行）收集器：最基本，历史最久，是个单线程收集器。意味着使用一条垃圾收集器线程去完成垃圾收集，并且进行收集工作时候必须暂停其他所有工作线程。新生代使用标记-复制算法，老年代使用标记-整理算法</p>
<p>好处是简单而高效（与其他收集器的单线程比较），对于运行在Client模式下的虚拟机来说是不错的选择</p>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>就是Serial收集器的多线程版本，除了多线程以外其他的与Serial收集器完全一样</p>
<p>是许多运行在Server模式下虚拟机的首要选择，除了Serial收集器以外只有它可以和CMS收集器（真正意义的并发收集器，见下）配合工作</p>
<ul>
<li><p>并行：多条垃圾收集器线程并行工作，此时用户线程仍然等待</p>
</li>
<li><p>并发：用户线程和垃圾收集器线程同时执行（可能并行，可能交替执行）</p>
</li>
</ul>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p>使用标记-复制算法的多线程收集器，看上去几乎和ParNew一样。</p>
<p>关注吞吐量，CMS等收集器关注用户线程的停顿时间。</p>
<p>新生代使用标记-复制，老年代使用标记-整理</p>
<h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>Serial收集器的老年代版本，两种用途：在JKD1.5以前的版本与Parallel Scavenge收集器搭配使用，另一种是作为CMS收集器的后备方案</p>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>Parallel Scavenge收集器的老年代版本。使用多线程和标记-整理算法。在注重吞吐量和CPU资源的场合可以优先考虑Parallel Scavenge收集器和Parallel Old收集器。</p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS（<strong>Concurrent Mark Sweep</strong>）：一种以获取最短回收停顿时间为目标的收集器。第一款真正并发收集器，第一次实现让垃圾收集器和用户线程（基本上）同时工作。标记-清除算法实现，运作过程稍微复杂一点。四个步骤：</p>
<ul>
<li>初始标记：暂停其他所有线程，记录下与root相连的对象，速度很快</li>
<li>并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象。在这个阶段结束，这个闭包结构并不能保证当前所有可达对象。因为用户线程可能会不断更新引用域，所以GC线程无法保证可达性分析的实时性。这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li>重新标记：为了修正并发期间因为用户程序运行而导致标记变动的那一部分对象的标记记录。这个阶段的停顿时间比初始标记稍微长，但是远远比并发标记时间短</li>
<li>并发清除：开启用户线程，同时GC线程开始对为标记的区域做清扫</li>
</ul>
<p><img src="https://javaguide.cn/assets/CMS%E6%94%B6%E9%9B%86%E5%99%A8.8a4d0487.png" alt="CMS 垃圾收集器 "></p>
<p>优点：并发收集，低停顿</p>
<p>缺点</p>
<ul>
<li>对CPU资源敏感</li>
<li>无法处理浮动垃圾</li>
<li>使用“标记-清除”算法会导致收集结束时有大量空间碎片产生</li>
</ul>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>（Garbage First）：一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。极高概率满足GC停顿时间要求的同时还具备高吞吐量性能特征。特点有以下：</p>
<ul>
<li>并行和并发：可以充分利用CPU，多核环境下的硬件优势，使用多个CPU来缩短停顿时间。而且可以通过并发的方式让java程序继续执行</li>
<li>分代收集：虽然不需要其他垃圾收集器配合就可以独立管理整个GC堆，但还是保留了分代的概念</li>
<li>空间整合：与CMS的标记-清除算法不同，虽然整体上是基于“标记-整理”算法实现，局部上是基于“标记-复制”算法实现</li>
<li>可预测的停顿：除了追求低停顿还能建立可预测的停顿时间模型，让使用者明确指定在一个长度为M毫秒的时间片段内</li>
</ul>
<p>运作分为以下步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ul>
<p>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，选择回收价值最大的Regin。这种使用Regin划分内存空间以及有优先级的区域回收方式保证了G1收集器在有限的时间内尽可能提高收集效率（将内存化整为零）。</p>
<h4 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h4><p>与CMS中的ParNew和G1类似，也采用了标记-复制算法，不过ZGC对算法做了重大改进，出现停顿其他线程的情况会更少。</p>
<h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h2><p>JVM可以理解的代码就是字节码，即<code>.class</code>文件，不面向任何特定处理器，只面向虚拟机。使用字节码的好处是<strong>既一定程度解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点</strong>。因此java语言无须重新编译就可以在多种不同操作系统的计算机上运行。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/bg/desktop%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88.png" alt="java虚拟机"></p>
<p><code>.class</code>文件是不同的语言在Java虚拟机之间的重要桥梁，也是支持Java跨平台的一个重要原因</p>
<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>Class文件通过<code>ClassFile</code>定义，类似于C语言的结构体，结构如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类可以有多个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="魔数（Magic-Number）"><a href="#魔数（Magic-Number）" class="headerlink" title="魔数（Magic Number）"></a>魔数（Magic Number）</h4><p>4字节，作用是确定这个文件是否是一个能被虚拟机接收的Class文件</p>
<h4 id="Class文件版本号（Minor-amp-Major-Version）"><a href="#Class文件版本号（Minor-amp-Major-Version）" class="headerlink" title="Class文件版本号（Minor&amp;Major Version）"></a>Class文件版本号（Minor&amp;Major Version）</h4><p>4字节</p>
<h4 id="常量池（Constant-Pool）"><a href="#常量池（Constant-Pool）" class="headerlink" title="常量池（Constant Pool）"></a>常量池（Constant Pool）</h4><p>数量是<code>constant_pool_count - 1</code></p>
<p>存放两大常量：</p>
<ul>
<li><p>字面量</p>
<p>类似Java语言层面的常量概念</p>
</li>
<li><p>符号引用</p>
<p>编译概念，包括：类和接口的全限定名，字段的名称和描述符，方法的名称和描述符</p>
</li>
</ul>
<p>常量池中每一项常量都是一个表</p>
<h4 id="访问标志（Access-Flag）"><a href="#访问标志（Access-Flag）" class="headerlink" title="访问标志（Access Flag）"></a>访问标志（Access Flag）</h4><p>识别一些类或者接口层次的访问信息</p>
<p>包括：</p>
<p>是类还是接口，是否为<code>public</code>或者<code>abstract</code>，类是否声明为<code>final</code>等</p>
<h4 id="当前类（This-Class），父类（Super-Class），接口（Interfaces）索引集合"><a href="#当前类（This-Class），父类（Super-Class），接口（Interfaces）索引集合" class="headerlink" title="当前类（This Class），父类（Super Class），接口（Interfaces）索引集合"></a>当前类（This Class），父类（Super Class），接口（Interfaces）索引集合</h4><p>继承关系由这三项集合确定，类索引确定类的全限定名，父类索引确定类的父类全限定名，接口索引集合描述实现哪些接口。</p>
<h4 id="字段表集合（Fields）"><a href="#字段表集合（Fields）" class="headerlink" title="字段表集合（Fields）"></a>字段表集合（Fields）</h4><p>描述接口或者类中声明的变量，包括类级变量和实例变量，不包括内部声明的局部变量</p>
<h4 id="方法表集合（Methods）"><a href="#方法表集合（Methods）" class="headerlink" title="方法表集合（Methods）"></a>方法表集合（Methods）</h4><p>方法数量和方法表</p>
<h4 id="属性表集合（Attributes）"><a href="#属性表集合（Attributes）" class="headerlink" title="属性表集合（Attributes）"></a>属性表集合（Attributes）</h4><p>描述某些场景专有的信息</p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>七个阶段：</p>
<p>加载（Loading），验证（Verification），准备（Preparation），解析（Resolution），初始化（Initialization），使用（Using），卸载（Unloading）</p>
<p>（前三个阶段可统称连接（Linking））</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/lifecycle-of-a-class.png" alt="一个类的完整生命周期"></p>
<h3 id="类加载过程-1"><a href="#类加载过程-1" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>虚拟机加载Class文件的过程，主要是三步：加载-&gt;连接（验证-&gt;准备-&gt;解析）-&gt;初始化</p>
<h4 id="加载：（由类加载器完成）"><a href="#加载：（由类加载器完成）" class="headerlink" title="加载：（由类加载器完成）"></a>加载：（由类加载器完成）</h4><ol>
<li>通过全类名获取定义此类的二进制字节流</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表该类的<code>Class</code>对象，作为方法区这些数据的访问入口</li>
</ol>
<p>加载具体的类，具体由哪个类加载器加载由<strong>双亲委派模型</strong>决定。</p>
<p>每个Java类都有一个引用指向加载它的<code>ClassLoader</code>，除了数组类是通过JVM在需要的时候自动创建的，数组类在通过<code>getClassLoader()</code>方法获取<code>ClassLoader</code>和该数组的元素类型<code>ClassLoader</code>是一致的</p>
<p>非数组类在加载阶段是可控性最强的阶段，可以去完成自定义类加载器去控制字节流的获取方式（重写一个类加载器的<code>LoadClass()</code>方法）</p>
<p>加载阶段和连接阶段的部分动作是交叉进行的，类加载没结束可能连接阶段已经开始。</p>
<h4 id="验证："><a href="#验证：" class="headerlink" title="验证："></a>验证：</h4><p>连接阶段的第一步，目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的约束要求，确保这些信息作为代码运行后不会危害虚拟机自身安全。</p>
<p>如果全部代码已经被反复使用和验证过，在生产环境的实施阶段可以考虑使用<code>-Xverify:none</code>参数关闭大部分类验证措施，缩短虚拟机类加载时间。</p>
<p>四个检验阶段：</p>
<ol>
<li>文件格式验证（Class文件格式检查）</li>
<li>元数据验证（字节码语义检查）</li>
<li>字节码验证（程序语义检查）</li>
<li>符号引用验证（类的正确性检查）</li>
</ol>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/class-loading-process-verification.png" alt="验证阶段示意图"></p>
<h4 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h4><p>正式为类变量分配内存并设置类变量初始值，内存都将在方法区分配</p>
<p>注意</p>
<ol>
<li>此时进行内存分配的仅包括类变量，即静态（<code>static</code>）变量，不包括实例变量，实例变量跟随对象实例化一起分配在java内存</li>
<li>概念上，类变量所有的内存都在方法区分配。JDK 7之后HotSpot把原本在永久代的字符串常量池，静态变量等移动到了堆中，类变量也随着一起到了Java堆</li>
<li>这里的初始值通常是默认零值，比如定义<code>public static int value = 111</code>，那么在这里，初始化value变量为0而不是111（初始化阶段才赋值），但是如果加上了final关键字，这里就会被赋值为111</li>
</ol>
<h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>虚拟机将常量池内符号引用替换为直接引用。解析动作主要针对类或者接口，字段，接口方法，方法类型，方法句柄和调用限定符7类符号</p>
<ul>
<li>符号引用：一组符号描述引用的目标，符号可以是任何形式，只要可以无歧义定位到目标，引用的也不一定是加载到虚拟机内存中的内容。</li>
<li>直接引用：可以直接指向目标的指针，相对偏移量或者直接定位到目标的句柄，和虚拟机内存布局直接相关，有了直接引用，引用的目标则一定在虚拟机内存中存在。</li>
</ul>
<h4 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h4><p>执行初始化方法<code>&lt;clinit&gt;()</code>过程，这时候JVM才真正执行类定义的Java程序代码。<code>&lt;clinit&gt;()</code>是编译后自动生成的。<code>&lt;clinit&gt;()</code>带锁线程安全，在多线程环境下类初始化会引起多个线程阻塞，虚拟机要保证多线程环境下的安全性。</p>
<p>虚拟机严格规范有且只有以下五种情况，必须对类初始化（只有主动使用类才会初始化）</p>
<ol>
<li>遇到<code>new</code>，<code>getstatic</code>（访问类静态变量），<code>putstatic</code>（给类静态变量赋值）或者<code>invokestatic</code>（调用类静态方法）这四条直接码指令时，对应<code>new</code>一个类，读取静态字段或者调用类静态方法时。</li>
<li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用时比如<code>Class.forname(&quot;...&quot;)</code>，<code>newInstance()</code>等等，如果类没初始化需要触发其初始化。</li>
<li>初始化一个类，其父类还没初始化，先触发父类初始化</li>
<li>虚拟机启动，用户需要定义一个执行的主类（包含<code>main</code>），虚拟机会先初始化这个类</li>
<li><code>MethodHandle</code>和<code>VarHandle</code>可以看作轻量级的反射调用机制，如果想要使用这两个调用，必须先使用<code>findStaticVarHandle</code>来初始化要调用的类</li>
<li>一个接口定义了JDK8新加入的默认方法，如果这个接口的实现类发生初始化，那接口要在其之前初始化</li>
</ol>
<h3 id="类卸载"><a href="#类卸载" class="headerlink" title="类卸载"></a>类卸载</h3><p>即类的Class对象被GC</p>
<p>满足三个要求：</p>
<ol>
<li>该类的所有实例对象都已经被GC，堆不存在该类的实例对象</li>
<li>该类没有在其他任何地方被引用</li>
<li>该类的类加载器实例已经被GC</li>
</ol>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>类加载过程：加载-&gt;连接-&gt;初始化</p>
<p>连接分为：验证-&gt;准备-&gt;解析</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/class-loading-procedure.png" alt="类加载过程"></p>
<p>类加载主要完成3件事</p>
<ol>
<li>通过全类名获得定义类的二进制字节流</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表该类的<code>Class</code>对象，作为方法区这些数据的访问入口</li>
</ol>
<p>类加载其是一个负责加载类的对象<code>ClassLoader</code>是一个抽象类。给定类二进制名称，类加载器尝试定位或生成构成类定义的数据，典型策略就是将名称转换为文件名，然后从文件系统读取该类名称的“类文件”</p>
<ul>
<li>类加载器是一个负责加载类的对象，用于实现类加载过程中的加载一步</li>
<li>每个Java类都有一个引用指向加载它的<code>ClassLoader</code></li>
<li>数组类不是通过<code>ClassLoader</code>创建，由JVM直接生成</li>
</ul>
<h3 id="类加载器加载规则"><a href="#类加载器加载规则" class="headerlink" title="类加载器加载规则"></a>类加载器加载规则</h3><p>根据需要动态加载，大部分类在具体用到才去加载。已加载的类放在<code>ClassLoader</code>，类加载时候先判断是否被加载过，已加载会直接返回，否则才尝试加载。</p>
<h3 id="常用类加载器"><a href="#常用类加载器" class="headerlink" title="常用类加载器"></a>常用类加载器</h3><ol>
<li><code>BootstrapClassLoader</code>(启动类加载器)：最顶层的加载类，由C++实现，通常表示为null且没有父级，主要用来加载JKD内部的核心类库以及被<code>-Xbootclasspath</code>参数指定的路径下的所有类</li>
<li><code>ExtensionClassLoader</code>(扩展类加载器)：主要负责加载<code>%JRE_HOME%/lib/ext</code>目录下的jar包和类以及被<code>java.ext.dirs</code>系统变量指定的路径下的所有类</li>
<li><code>AppClassLoader</code>(应用程序加载类)：面向用户的加载器，负责加载当前应用classpath下的所有jar包和类</li>
</ol>
<p>除<code>BootstrapClassLoader</code>是JVM自身一部分以外，其他的类加载器都是在JVM外部实现，且都继承自<code>ClassLoader</code>抽象类。好处是用户可以自定义类加载器</p>
<p>每个类加载器都通过<code>getParent()</code>获取父类加载器，如果是null的话表示通过<code>BootstrapClassLoader</code>加载</p>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>继承<code>ClassLoader</code>抽象类</p>
<p>两个关键方法：</p>
<ul>
<li><code>protrcted Class loadClass(String name, boolean resolve)</code>：加载指定二进制名称的类，实现双亲委派机制。<code>name</code>是类的二进制名称，<code>resove</code>如果是true，加载时调用<code>resolveClass(Class&lt;?&gt; c)</code>方法解析该类。</li>
<li><code>protected Class findClass(String name)</code>：根据类的二进制名称来查找类，默认实现是空方法</li>
</ul>
<p>如果要打破双亲委派模型就重需要重写<code>loadClass()</code>方法</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p><code>ClassLoader</code>使用委托模型来搜索类和资源，每个<code>ClassLoader</code>的实例都有一个相关父类加载器。需要查找类或者资源时，<code>ClassLoader</code>实例会试图亲自查找类或者资源之前，将搜索类或者资源的任务委托给父类加载器。</p>
<ul>
<li><code>ClassLoader</code>使用委托模型搜索类和资源</li>
<li>双亲委派模型要求除了顶层的启动类加载器以外的类加载器都要有自己的父类加载器</li>
<li><code>ClassLoader</code>实例在亲自查找类或者资源之前，将搜索类或资源的任务委托给父类加载器</li>
</ul>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/class-loader-parents-delegation-model.png" alt="类加载器层次关系图"></p>
<p>类加载器之间的父子关系不是继承来实现的，是使用组合关系来服用父加载器的代码：定义一个final的成员变量，并通过构造器赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 组合</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">ClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(checkCreateClassLoader(), parent);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>面向对象编程中的设计原则：组合优于继承，多用组合少用继承。</p>
<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p>见代码，<code>java.lang.ClassLoader</code>的<code>loadClass()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//首先，检查该类是否已经加载过</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果 c 为 null，则说明该类没有被加载过</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器不为空，则通过父类的loadClass来加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器为空，则调用启动类加载器来加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">//非空父类的类加载器无法找到相应的类，则抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//当父类加载器无法加载时，则调用findClass方法来加载该类</span></span><br><span class="line">                <span class="comment">//用户可通过覆写该方法，来自定义类加载器</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//用于统计类加载器相关的信息</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            <span class="comment">//对类进行link操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程可以概括为</p>
<ol>
<li><strong>类加载时先判断当前类是否被加载过，已经加载过会直接返回，否则尝试加载（每个父类加载器都会走一遍）</strong></li>
<li><strong>类加载器开始类加载，首先将请求委派给父类加载器，这样所有请求最终都会传到顶层的类启动加载器<code>BooststrapClassLoader</code>中</strong></li>
<li><strong>当父类加载器返回无法完成这个请求（搜索范围内没有找到所需的类），子加载器才会尝试自己去加载（调用自己的<code>findClass()</code>方法）</strong></li>
</ol>
<p>判断Java类相同的规则：</p>
<p>JVM不仅看两个类全名是否相同，还要看加载此类的类加载器是否一样。所以两个类来源于同一个<code>Class</code>文件，被同一虚拟机加载，只要加载的类加载器不同这两个类就必定不同</p>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>保证Java程序稳定运行，避免类重复加载，也保证Java的核心API不被篡改</p>
<p>如果没有双亲委派模型，而是每个类加载器加载自己会出现一些问题，比如编写了一个称为<code>java.lang.Object</code>类，在程序运行时，系统会出现两个Object类。双亲委派模型可以保证加载的是JRE里面的<code>Object</code>为不是自己写的<code>Object</code>，因为通过双亲委派模型，类加载会请求到<code>BoostrapClassLoader</code>，<code>BoostrapClassLoader</code>发现已经加载过<code>Object</code>就会直接返回。</p>
<h4 id="打破模型的方法"><a href="#打破模型的方法" class="headerlink" title="打破模型的方法"></a>打破模型的方法</h4><p>不想打破双亲委派模型，自定义类加载器（需要继承<code>ClassLoader</code>）时重写<code>findClass()</code>方法即可。想打破双亲委派模型要重写<code>loadClass()</code>方法，因为将请求委派给父类加载器通过调用<code>loadClass()</code>方法来加载类。比如Tomecat服务器为了保证优先加载Web应用目录下的类，然后加载其他目录下的类，就自定义了类加载器<code>WebAppClassLoader</code>来打破双亲委托机制。因此也是Tomcat下Web应用之间实现隔离的具体原理。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/15/JVM/" data-id="clix3qjsl0000qwuegtrwaorw" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java知识点" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/15/Java%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time class="dt-published" datetime="2023-06-15T12:12:02.358Z" itemprop="datePublished">2023-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Java知识点"><a href="#Java知识点" class="headerlink" title="Java知识点"></a>Java知识点</h1><h2 id="Java值传递"><a href="#Java值传递" class="headerlink" title="Java值传递"></a>Java值传递</h2><ul>
<li>值传递：方法接收的是实参值的拷贝，会创建副本</li>
<li>引用传递：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改影响到实参</li>
</ul>
<p>Java中只有值传递</p>
<h2 id="Java序列化"><a href="#Java序列化" class="headerlink" title="Java序列化"></a>Java序列化</h2><ul>
<li>序列化：将数据结构或者对象转换成二进制字节流的过程</li>
<li>反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>
</ul>
<p>常用场景</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String不可变"><a href="#String不可变" class="headerlink" title="String不可变"></a>String不可变</h3><p>不可变指如果要在原字符串上增删字符，会新建一个新的字符串而不会改变原本字符串</p>
<p>原因：</p>
<ul>
<li>String类内使用数组保存字符串，这个数组被final修饰且为private</li>
<li>String类为final，不可被子类继承，从而破坏不可变</li>
</ul>
<h3 id="String，StringBuffer，-StringBuilder"><a href="#String，StringBuffer，-StringBuilder" class="headerlink" title="String，StringBuffer， StringBuilder"></a>String，StringBuffer， StringBuilder</h3><p>StringBuffer， StringBuilder继承自AbstractBuilder，也是用数组保存字符串，但是没有使用final和private修饰，还提供了修改方法比如append，因此是可变的</p>
<p>String是线程安全的，StringBuffer添加了同步锁所以也是线程安全的，StringBuffer线程不安全</p>
<p>性能上：String&lt;StringBuffer&lt;StringBuilder</p>
<h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h3 id="comparable与Comparator"><a href="#comparable与Comparator" class="headerlink" title="comparable与Comparator"></a>comparable与Comparator</h3><ul>
<li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li>
<li><code>comparator</code>接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li>
</ul>
<p><strong>Comparable 被认为是内比较器，也是自然排序，实现该接口的类，会有自身比较的功能，则依赖compareTo方法的实现</strong></p>
<p><strong>Comparator 被认为是外比较器，我们如果需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口)，那么我们就可以建立一个“该类的比较器”来进行排序，这个“比较器”只需要实现Comparator接口覆盖compare(T o1, T o2)方法，即可，然后通过这个比较器对类进行比较且排序</strong></p>
<p>对集合需要排序时，重写comparaTo方法或者compara方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//省略了arrayList的赋值</span></span><br><span class="line">Collections.sort(arrayList, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compara</span><span class="params">(Integer o1, Integer o2)</span>&#123;</span><br><span class="line">        <span class="comment">//降序</span></span><br><span class="line">        <span class="keyword">return</span> o2.comparaTo(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><ul>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都<strong>不是线程安全</strong>的。</li>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是<strong>哈希表</strong>（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是<strong>链表和哈希表</strong>，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是<strong>红黑树</strong>，元素是有序的，排序的方式有自然排序和定制排序。</li>
<li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素</li>
</ul>
<h3 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h3><ul>
<li><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</li>
<li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 <code>Hashtable</code> 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。<code>Hashtable</code> 没有这样的机制。</li>
</ul>
<p><strong>HashMap扩容机制</strong></p>
<p>初始大小：16，指定初始容量会扩充到2的幂次方（移位操作实现）；</p>
<p>扩容倍数：2；</p>
<p>当哈希冲突时，链表长度大于阈值（8）会转化成红黑树。（数组长度大于64时）</p>
<h3 id="HashMap源码阅读"><a href="#HashMap源码阅读" class="headerlink" title="HashMap源码阅读"></a>HashMap源码阅读</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类声明</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    <span class="comment">//重要常量</span></span><br><span class="line">    <span class="comment">//默认初始容量，2^4</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//默认负载因子，到当前容量的0.75就加载扩容</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">//一个桶转成树的阈值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">//一个桶取消树化的阈值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="comment">//可以树化的最小容量，当桶的数量达到64才进行树化</span></span><br><span class="line">    <span class="comment">//这里有点不明白</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一些成员变量</span></span><br><span class="line">    <span class="comment">//Node的列表，存放entry</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="comment">//保存entrySet的缓存</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">//元素数量</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line">    <span class="comment">//临界值，实际大小超过临界值会进行扩容</span></span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line">    <span class="comment">//加载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap中元素的存储是Node的形式，可以被用作大部分的Entries</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个静态内部类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">	<span class="comment">//因为hash冲突时变成链表，需要next指针</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.hash = hash;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//计算hash值，使用Object的hashCode的key和value位与运算</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>put方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//先检查容器有没有初始化，调用resize初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//如果hash的位置没有元素就新建Node加入</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//对元素进行hash和key的匹配</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">//如果数组中是TreeNode类型，直接在红黑树中查找符合条件节点</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//向单向链表添加数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//节点大于阈值树化</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConcurrentHashMap与Hashtable"><a href="#ConcurrentHashMap与Hashtable" class="headerlink" title="ConcurrentHashMap与Hashtable"></a>ConcurrentHashMap与Hashtable</h3><p>ConcurrentHashMap的segment内部类继承于ReentrantLock</p>
<p>都是线程安全的集合，但是实现方式不同</p>
<ul>
<li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表&#x2F;红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li><strong>实现线程安全的方式（重要）：</strong></li>
<li><ul>
<li>在 JDK1.7 的时候，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</li>
<li>到了 JDK1.8 的时候，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 <code>synchronized</code> 锁做了很多优化） 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li>
<li><strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
</li>
</ul>
<p>Hashtable</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230512105215974.png" alt="image-20230512105215974"></p>
<p>ConcurrentHashMap：JDK1.7</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230512105152028.png" alt="image-20230512105152028"></p>
<p>ConcurrentHashMap：JDK1.8</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230512105234818.png" alt="image-20230512105234818"></p>
<h3 id="Java集合的遍历"><a href="#Java集合的遍历" class="headerlink" title="Java集合的遍历"></a>Java集合的遍历</h3><p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p>**不要在 foreach 循环里进行元素的 <code>remove/add</code> 操作。remove 元素请使用 <code>Iterator</code> 方式，如果并发操作，需要对 <code>Iterator</code> 对象加锁。</p>
</blockquote>
<p>原因是会触发fail-fast机制：fail-fast是一种错误检测机制，一旦检测到可能发生错误，就立马抛出异常，程序不继续往下执行。</p>
<p>情况如下：</p>
<p>在使用foreach循环遍历时，调用了add或者remove方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">&quot;Hollis&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;hollis&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;HollisChuang&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String userName : userNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userName.equals(<span class="string">&quot;Hollis&quot;</span>)) &#123;</span><br><span class="line">        userNames.remove(userName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(userNames);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>会抛出异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.util.ConcurrentModificationException</span><br><span class="line">at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="number">909</span>)</span><br><span class="line">at java.util.ArrayList$Itr.next(ArrayList.java:<span class="number">859</span>)</span><br><span class="line">at com.hollis.ForEach.main(ForEach.java:<span class="number">22</span>)</span><br></pre></td></tr></table></figure>

<p>在foreach循环（增强for循环）实际上调用的是Iterator迭代器</p>
<p>实际上抛出异常的代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="number">909</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中比较了modCount和expectedModCount</p>
<p>modCount是ArrayList中的一个成员变量。它表示该集合实际被修改的次数。</p>
<p>expectedModCount 是 ArrayList中的一个内部类——Itr中的成员变量。</p>
<p>expectedModCount表示这个迭代器预期该集合被修改的次数。其值随着Itr被创建而初始化。只有通过迭代器对集合进行操作，该值才会改变。</p>
<p>remove的核心操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到修改了modCount而没有改变expectedModCount，因此出现fail-fast异常</p>
<p><strong>正确的遍历方式：</strong></p>
<ol>
<li><p>直接使用普通for循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">&quot;Hollis&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;hollis&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;HollisChuang&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userNames.get(i).equals(<span class="string">&quot;Hollis&quot;</span>)) &#123;</span><br><span class="line">        userNames.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(userNames);</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接使用Iterator进行操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">&quot;Hollis&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;hollis&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;HollisChuang&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> userNames.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iterator.next().equals(<span class="string">&quot;Hollis&quot;</span>)) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(userNames);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用java8提供的filter过滤</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">&quot;Hollis&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;hollis&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;HollisChuang&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line">userNames = userNames.stream().filter(userName -&gt; !userName.equals(<span class="string">&quot;Hollis&quot;</span>)).collect(Collectors.toList());</span><br><span class="line">System.out.println(userNames);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用增强for循环时，对只修改一次的操作及时break</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; userNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">&quot;Hollis&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;hollis&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;HollisChuang&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String userName : userNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userName.equals(<span class="string">&quot;Hollis&quot;</span>)) &#123;</span><br><span class="line">        userNames.remove(userName);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(userNames);</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接使用fail-safe的集合类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentLinkedDeque&lt;String&gt; userNames = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedDeque</span>&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(<span class="string">&quot;Hollis&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;hollis&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;HollisChuang&quot;</span>);</span><br><span class="line">    add(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String userName : userNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userName.equals(<span class="string">&quot;Hollis&quot;</span>)) &#123;</span><br><span class="line">        userNames.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h2><p>sun.misc包下的一个类，提供低级别不安全操作的方法。比如直接访问系统内存资源，自主管理内存资源等。</p>
<p>Unsafe提升了Java运行效率，增强Java语言底层资源操作能力，但是增加了程序发生相关指针问题的风险，不正确使用会让程序出错概率变大</p>
<p>Unsafe提供的方法实现依赖本地方法（Native Method）</p>
<h3 id="为什么要使用本地方法"><a href="#为什么要使用本地方法" class="headerlink" title="为什么要使用本地方法"></a>为什么要使用本地方法</h3><ol>
<li>需要用到Java中不具备的依赖于操作系统的特性，Java在实现跨平台的同时要实现对底层的控制，需要借助其他语言发挥作用</li>
<li>其他语言已经完成一些功能实现，可以使用Java直接调用</li>
<li>程序对时间敏感或者对性能要求非常高时，有必要使用更底层的语言，例如C&#x2F;C++甚至汇编</li>
</ol>
<h3 id="获取Unsafe实例"><a href="#获取Unsafe实例" class="headerlink" title="获取Unsafe实例"></a>获取Unsafe实例</h3><p>Unsafe是单例实现，提供了静态方法getUnsafe获取Unsafe实例。</p>
<p>但是直接调用这个静态方法会抛出SecurityException异常</p>
<p><strong>为什么无法直接调用public static的getUnsafe方法？</strong></p>
<p>在getUnsafe方法中会先检查调用者的ClassLoader，判断当前类是否由BootstrapClassLoader加载，如果不是就会抛出SecurityException异常。也就是说只有启动类加载器加载的类才能够调用Unsafe方法</p>
<p>如何获取Unsafe实例：</p>
<ol>
<li><p>利用反射获得Unsafe类已经实例化完成的单例对象theUnsafe</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe <span class="title function_">reflectGetUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">      field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">return</span> (Unsafe) field.get(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      log.error(e.getMessage(), e);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>从getUnsafe的限制条件出发，通过Java命令行-Xbootclasspath&#x2F;a把调用Unsafe相关方法的类A所在的jar包路径追加到默认的bootstrap路径中，让A被引导类加载器加载，从而通过类加载器的限制</p>
</li>
</ol>
<h3 id="Unsafe功能"><a href="#Unsafe功能" class="headerlink" title="Unsafe功能"></a>Unsafe功能</h3><h4 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h4><p>Java中不允许直接操作内存，对象的内存分配和回收都是由JVM完成的，但是Unsafe可以直接进行内存操作</p>
<p>通过以下接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配新的本地空间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">allocateMemory</span><span class="params">(<span class="type">long</span> bytes)</span>;</span><br><span class="line"><span class="comment">//重新调整内存空间的大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">reallocateMemory</span><span class="params">(<span class="type">long</span> address, <span class="type">long</span> bytes)</span>;</span><br><span class="line"><span class="comment">//将内存设置为指定值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> bytes, <span class="type">byte</span> value)</span>;</span><br><span class="line"><span class="comment">//内存拷贝</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">copyMemory</span><span class="params">(Object srcBase, <span class="type">long</span> srcOffset,Object destBase, <span class="type">long</span> destOffset,<span class="type">long</span> bytes)</span>;</span><br><span class="line"><span class="comment">//清除内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">freeMemory</span><span class="params">(<span class="type">long</span> address)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过这种方式分配的内存属于<strong>堆外内存</strong> ，是无法进行垃圾回收的，需要我们把这些内存当做一种资源去手动调用<code>freeMemory</code>方法进行释放，否则会产生内存泄漏。通用的操作内存方式是在<code>try</code>中执行对内存的操作，最终在<code>finally</code>块中进行内存的释放。</p>
<p>使用堆外内存的原因：</p>
<ul>
<li>对垃圾回收停顿的改善，堆外内存不受JVM管理，直接受操作系统管理。使用堆外内存可以保持较小堆内内存规模，让GC回收的停顿减少对应用的影响</li>
<li>提升I&#x2F;O操作性能，I&#x2F;O通信会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存空间数据拷贝且生命周期比较短的暂存数据都建议存在堆外内存</li>
</ul>
<p><strong>应用</strong>：</p>
<p>DirectByteBuffer，是Java用于实现堆外内存的重要类，通信过程中作为缓冲池，在Netty，MINA等NIO框架中应用广泛。DirectByteBuffer的对堆外内存的操作逻辑都是使用Unsafe的堆外内存API实现的</p>
<h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>编译期和CPU在保证程序输出结构一致的情况下对代码会进行重排，从指令优化角度提升性能。可能会带来一个不好的结果，导致CPU的高速缓存和内存中的数据不一致，内存屏障就是<strong>通过阻止屏障两边的指令重新排序从而避免编译期和硬件不正确优化情况。</strong></p>
<p>Unsafe提供的三个内存屏障相关方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存屏障，禁止load操作重新排序，屏障前的load操作不能被重排到屏障后，屏障后不能重排到屏障前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">loadFence</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止store操作重排，屏障两边的store操作不能被重排到另一边</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">storeFence</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止load，store操作重排</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">fullFence</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>可以把内存屏障看做内存随机访问操作的一个同步点，只有此点之前所有读写操作都执行后才可以开始执行之后的操作</p>
<p>在字段上加上volatile关键字可以实现字段在多线程下的可见性，基于读内存屏障也能实现相同的功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监测flag的变化</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChangeThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">/**volatile**/</span> <span class="type">boolean</span> flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;subThread change flag to:&quot;</span> + flag);</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在中间加入内存屏障来测试能不能感知到flag的改变</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">ChangeThread</span> <span class="variable">changeThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChangeThread</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(changeThread).start();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> changeThread.isFlag();</span><br><span class="line">        unsafe.loadFence(); <span class="comment">//加入读内存屏障</span></span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;detected flag changed&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;main thread end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"></span><br><span class="line">subThread change flag to:<span class="literal">false</span></span><br><span class="line">detected flag changed</span><br><span class="line">main thread end</span><br></pre></td></tr></table></figure>

<p><img src="https://oss.javaguide.cn/github/javaguide/java/basis/unsafe/image-20220717144703446.png" alt="img"></p>
<p>运行中的线程不能直接读取主内存的变量，只能操作自己工作内存的变量，然后同步到主内存，线程的工作内存不能共享，以上就是子线程借助主内存将修改后的结果同步给主线程修改主线程的工作空间</p>
<h4 id="对象操作"><a href="#对象操作" class="headerlink" title="对象操作"></a>对象操作</h4><h5 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h5><p>Unsafe还提供了8种基础数据类型以及Object的put和get方法，所有的put方法都可以越过访问权限，直接修改内存中的数据。get可以通过对象的偏移量获得一个对象引用</p>
<p>volatile读写和有序写入方法：</p>
<p>volatile读写比如getIntVolatile，可以保证可见性和有序性，执行get会强制从主存种获取属性值，put会强制更新到主存</p>
<p>循序写入在加入内存屏障StoreStore类型</p>
<p>put，putOrder，putVolatile顺序效率逐渐降低</p>
<h5 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h5><p>Unsafe提供的allocateInstance方法允许使用非常规的方法对对象实例化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个类，构造方法中对成员变量赋值</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.b =<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">objTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//基于构造函数实例化</span></span><br><span class="line">    A a1=<span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    System.out.println(a1.getB());</span><br><span class="line">    <span class="comment">//基于反射</span></span><br><span class="line">    <span class="type">A</span> <span class="variable">a2</span> <span class="operator">=</span> A.class.newInstance();</span><br><span class="line">    System.out.println(a2.getB());</span><br><span class="line">    <span class="comment">//基于Unsafe类</span></span><br><span class="line">    A a3= (A) unsafe.allocateInstance(A.class);</span><br><span class="line">    System.out.println(a3.getB());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"><span class="number">1</span>，<span class="number">1</span>，<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>Unsafe通过allocateInstance方法创建对象，不会调用类的构造方法。如果要跳过对象初始化阶段或者构造器的安全检查就可以使用这种方法。上面把A的构造函数改为private方法就无法通过构造函数和反射创建对象</p>
<h4 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h4><p>通过结合arrayBaseOffset和arrayIndexScale两个方法就可以定位数组每个元素在内存中的位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回数组中第一个元素的偏移地址</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">arrayBaseOffset</span><span class="params">(Class&lt;?&gt; arrayClass)</span>;</span><br><span class="line"><span class="comment">//返回数组中一个元素占用的大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">arrayIndexScale</span><span class="params">(Class&lt;?&gt; arrayClass)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h4><p>关于CAS查看<a href="C:\Users\Bubble\Desktop\note\Java锁.md">笔记</a></p>
<p>相关方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object o, <span class="type">long</span> offset,  Object expected, Object update)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> expected,<span class="type">int</span> update)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> expected, <span class="type">long</span> update)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><p>提供了线程调度的一些方法</p>
<p>AQS中调用的LockSupport.park和LockSupport.unpark就是调用到了这里的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取消阻塞线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Object thread)</span>;</span><br><span class="line"><span class="comment">//阻塞线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">(<span class="type">boolean</span> isAbsolute, <span class="type">long</span> time)</span>;</span><br><span class="line"><span class="comment">//获得对象锁（可重入锁）</span></span><br><span class="line"><span class="comment">//以下方法被标记Deprecated，不建议被使用</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">monitorEnter</span><span class="params">(Object o)</span>;</span><br><span class="line"><span class="comment">//释放对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">monitorExit</span><span class="params">(Object o)</span>;</span><br><span class="line"><span class="comment">//尝试获取对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">tryMonitorEnter</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Class操作"><a href="#Class操作" class="headerlink" title="Class操作"></a>Class操作</h4><p>相关方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取静态属性的偏移量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">staticFieldOffset</span><span class="params">(Field f)</span>;</span><br><span class="line"><span class="comment">//获取静态属性的对象指针</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title function_">staticFieldBase</span><span class="params">(Field f)</span>;</span><br><span class="line"><span class="comment">//判断类是否需要实例化（用于获取类的静态属性前进行检测）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">shouldBeInitialized</span><span class="params">(Class&lt;?&gt; c)</span>;</span><br></pre></td></tr></table></figure>

<p>典型应用：</p>
<p>Lambda表达式的实现需要依赖Unsafe的defineAnonymousClass方法定义实现响应函数式接口的匿名类</p>
<h4 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回系统指针的大小。返回值为4（32位系统）或 8（64位系统）。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">addressSize</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//内存页的大小，此值为2的幂次方。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">pageSize</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>JMM定义对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性</p>
<h3 id="CPU缓存模型"><a href="#CPU缓存模型" class="headerlink" title="CPU缓存模型"></a>CPU缓存模型</h3><p>为了解决CPU处理速度和内存不匹配的问题，创建了一块CPU高速缓存。从外存到内存到CPU，每一级的处理速度都不一样，每一级都有对应的缓存用来处理这些问题。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/cpu-cache.png" alt="CPU 缓存模型示意图"></p>
<p>这里L1-L3的Cache就是每一级的缓存</p>
<p>CPU缓存的<strong>工作方式</strong>：复制一份数据到CPU缓存中，当CPU需要用到就直接从缓存中读取。运算完成后将运算得到的数据写回Main Memory。这样会产生另一个问题：内存缓存不一致性</p>
<p>同时两个线程执行任务，比如i++，两个线程从缓存中都读到i&#x3D;1，运算完写回主存i&#x3D;2，但是实际上此时主存的i&#x3D;3.</p>
<p>CPU为了解决内存缓存不一致行的问题制定了<strong>缓存一致协议</strong>或者其他的手段。缓存一致性协议指在CPU高速缓存和主内存交互的时候需要遵守的原则和规范。</p>
<p>程序运行在<strong>操作系统</strong>之上，操作系统通过内存模型来定义了一些列规范解决这个问题</p>
<h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>为了提高执行速度和性能，计算机在执行程序代码时会对指令重新排序。也就是说系统执行代码不会按照写的顺序依次执行，主要有两种情况：</p>
<ul>
<li>编译器优化重排：编译器（包括JVM，JIT编译器等）在不改变单线程程序语义的前提下重新安排语句的执行顺序</li>
<li>指令并行重排：现代处理器采用指令级并行技术来讲多条指令重叠执行，如果不存在数据的依赖性，处理器可以改变语句对应机器指令的执行顺序</li>
</ul>
<p>还有内存系统也有类似的重排序，但不是真正意义上的，JMM中表现为主存和本地内存的内容可能不一致，进而导致程序在多线程下执行可能出现问题</p>
<p>Java源代码会经历：编译器优化重排，指令并行重排，内存系统重排。重排保证串行语义一致，没有义务保证多线程的语义也一致，所以多线程下指令重排会导致一些问题。</p>
<p>编译器通过禁止特定类型编译器重排序来禁止重排序。处理器通过插入内存屏障来禁止特定类型处理器重排</p>
<h3 id="JMM（Java-Memory-Model）"><a href="#JMM（Java-Memory-Model）" class="headerlink" title="JMM（Java Memory Model）"></a>JMM（Java Memory Model）</h3><p>可以看作Java定义并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外还规定了从Java源代码到CPU可执行指令的转化过程要遵守的并发相关原则和规范。目的是简化多线程编程，增强程序可移植性</p>
<p>通过JMM定义的规范，对于Java开发者就不用了解底层，可以直接使用一些关键字和类（volatile，synchronized，各种Lock）开发出并行安全的程序</p>
<h4 id="线程和主内存之间的关系"><a href="#线程和主内存之间的关系" class="headerlink" title="线程和主内存之间的关系"></a>线程和主内存之间的关系</h4><p>JDK1.2之前Java内存模型的实现总是从主存读取变量，不需要特别注意。现在的Java内存模型线程把变量保存在本地内存（比如寄存器），而不是直接在主存中读写，就有可能造成线程在主存中修改一个变量，另一个线程还继续用寄存器中的变量拷贝造成数据不一致，类似于上面CPU缓存模型的问题</p>
<ul>
<li>主内存：所有线程创建的实例对象都存放在主内存，不管实例对象是成员变量还是方法的局部变量</li>
<li>本地内存：每个线程有私有的本地内存来存储共享变量的副本，并且每个线程只能访问自己的本地内存，无法访问其他线程的本地内存。本地内存是JMM的抽象概念</li>
</ul>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/jmm.png" alt="JMM(Java 内存模型)"></p>
<p>线程1要与线程2通信，必须先把本地内存修改的变量值同步到主内存，然后线程2从主内存读取</p>
<p>多线程下对主内存共享变量操作可能会诱发线程安全问题：</p>
<ol>
<li>线程1和线程2对共享变量操作，一个修改，一个读取</li>
<li>线程2读取到的是线程1修改前还是后的值都有可能</li>
</ol>
<p>Java内存模型定义了以下八种同步操作（不用背</p>
<ul>
<li>锁定（lock）：作用于主内存的变量，给他标记成一个线程独享的变量</li>
<li>解锁（unlock）：作用于主内存中的变量，解除变量的锁定状态，被解锁状态的变量才能被其他线程锁定</li>
<li>读取（read）：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li>载入（load）：把read从主内存得到的变量值放入工作内存的变量副本中</li>
<li>使用（use）：把工作内存的一个变量值传给执行引擎，当虚拟机遇到一个使用变量的指令就会使用</li>
<li>赋值（assign）：作用域工作内存变量，把计算完接收的值赋给工作内存变量</li>
<li>存储（store）：将工作内存的变量值传到主内存</li>
<li>写入（write）：作用域主内存变量，把store过来的变量放入主内存变量</li>
</ul>
<p>还规定了同步规则保证同步操作正确执行（不用背</p>
<ul>
<li>省略</li>
</ul>
<h3 id="JMM（Java内存模型）和Java内存区域的区别"><a href="#JMM（Java内存模型）和Java内存区域的区别" class="headerlink" title="JMM（Java内存模型）和Java内存区域的区别"></a>JMM（Java内存模型）和Java内存区域的区别</h3><ul>
<li>JVM内存结构和Java虚拟机运行时区域相关，定义了JVM在运行时如何分区存储程序数据，比如堆用于存放对象实例</li>
<li>Java内存模型和Java的并发编程相关，抽象了线程和主内存之间的关系。比如线程之间的共享变量必须存储在主内存中，规定了从Java源代码到CPU可执行指令的转化过程要遵守的并发相关原则和规范。目的是为了简化多线程编程，增强程序可移植性</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/15/Java%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="clix3qjv80001qwue4exd02mo" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java锁" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/15/Java%E9%94%81/" class="article-date">
  <time class="dt-published" datetime="2023-06-15T12:12:02.332Z" itemprop="datePublished">2023-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Java锁"><a href="#Java锁" class="headerlink" title="Java锁"></a>Java锁</h1><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>线程访问共享资源可以不停执行无需加锁或者等待，只是在提交修改的时候验证对应资源是否被其他线程修改（方法：CAS或者版本号）</p>
<p><strong>使用场景</strong>：适合于读操作比较多，写比较少的场景。冲突发生不是很频繁的并发场景下效率更高（不存在锁资源竞争的线程阻塞，也不会有死锁问题），但是冲突频发时会频繁失败重试影响性能。</p>
<ul>
<li>CAS：用一个预期值和要更新的变量值比较，相等才更新，不然自旋等待</li>
<li>版本号：数据表中有一个版本号来控制被修改的次数，在线程访问共享资源要提交更新时检查版本号时对比与是否一致。注意检查版本号与提交更新要保持原子性，不然会出现检查版本号一致后资源被修改的情况。</li>
</ul>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>​		Compare And Swap(比较与交换)。用一个预期值与要更新的变量值比较，相等才会更新。失败的线程被告知失败后依旧继续尝试，或者在一定次数或者时间后放弃。</p>
<p><strong>CAS是原子操作。</strong></p>
<p>​		在JUC的atomic包下提供了原子的变量类（比如AtomicInteger，LongAdder）就是使用了CAS实现的，可以定义多线程来修改变量，但是不会有线程安全问题。</p>
<h3 id="乐观锁存在的问题"><a href="#乐观锁存在的问题" class="headerlink" title="乐观锁存在的问题"></a>乐观锁存在的问题</h3><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>​		一个变量，初次读取是A值，在准备赋值时检查到依旧是A值。能保证这个A一定没有被其他线程修改了吗？可能在期间被改变为了其他值后又被改回A，那CAS依旧会误认为没有被修改。</p>
<p><strong>解决方法</strong></p>
<p>​		变量前追加版本号或者时间戳，JDK1.5以后<code>AtomicStampedReference</code>类就用于解决ABA问题。<code>compareAndSet</code>方法首先检查引用是否等于预期引用，标志是否等于预期标志，全部相等才以原子方式设置给定更新值。</p>
<h4 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h4><p>CAS常用自旋操作来进行重试，即不成功就一直循环执行到成功。自旋是CPU操作，长时间不成功会给CPU带来很大执行开销。	</p>
<h4 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h4><p>CAS只对单个共享变量有效，当操作涉及到多个共享变量时CAS无效。JDK1.5之后，提供了<code>AtomicReference</code>类保证引用对象之间的原子性，可以把多个变量放在一个对象里进行CAS操作		</p>
<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p>由JVM提供的一种隐式锁（不需要手动加解锁）</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li>原子性：保证线程互斥访问同步代码（操作是原子不可分的，不会被打断，全部执行或者全部不执行）</li>
<li>可见性：访问的资源所有线程可见（一个线程如果要访问该类或对象必须先获得它的锁，而这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到共享内存当中，保证资源变量的可见性）</li>
<li>有序性：线程执行同步代码块是分先后顺序的</li>
</ol>
<p>​		一种互斥锁。在JDK1.6以前，很多人称之为<strong>重量级锁</strong>，性能不高。但是在JDK1.6之后，对synchronized进行了一些优化，引入了<strong>偏向锁</strong>，<strong>轻量级锁</strong>以及<strong>重量级锁</strong>。这个时候，synchronized会根据<strong>线程竞争的程度</strong>进行<strong>锁升级</strong>或降级。很多的文章或者书籍中都表示synchronized锁升级后就不会降级，其实synchronized存在降级机制，只是这个条件比苛刻。</p>
<p>​		在对象刚被创建时，此时处于一个<strong>无锁状态</strong>，如果有且仅有一个线程对对象进行了加锁，那么此时将会升级到<strong>偏向锁</strong>状态，记录当前线程id并通过<strong>CAS操作修改Mark Word中的标志位</strong>。当有第二个线程来竞争锁时，并且两个线程执行速度非常快并且竞争比较小，那么此时为抢到锁的线程将会一直处于自旋状态并等待对象所被释放。当有多个线程来竞争锁并且竞争非常强烈时，那么此时会升级到重量级锁。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li><p>修饰实例方法（锁对象）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：子类继承父类方法时，如果synchronized修饰父类方法，不会继承同步。如果需要子类方法也同步，可以在子类方法上显式添加synchronized，或者在子类中使用super调用父类方法</p>
</li>
<li><p>修饰静态方法（锁Class类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> staic <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰代码块（锁Class类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> method&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>2修饰静态方法(任何静态成员)和3代码块都是给<strong>Class类</strong>加锁，1实例方法(或对象)是给<strong>对象实例</strong>上锁</p>
<p>注意：</p>
<ul>
<li>接口不能使用synchronized</li>
<li>构造方法不能使用synchronized，但是可以使用synchronized代码块进行同步</li>
</ul>
<h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p>java对象的存储布局：</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230319204718723.png" alt="image-20230319204718723"></p>
<ul>
<li>对象头：Java对象头占用2个机器码（如果对象是数组则需要3个）</li>
<li>实例数据：存放类的属性数据信息，包括父类的属性信息</li>
<li>对齐填充：因为虚拟机要求，对象起始地址必须是8字节整数倍</li>
</ul>
<h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/f8f5088839a9f1e36a3dd84e80c572e3.png" alt="img"></p>
<p>根据锁的不同对象头存储内容不同</p>
<ul>
<li>偏向锁：存储当前占用此对象的线程ID</li>
<li>轻量锁：存储指向线程栈中锁记录的指针</li>
</ul>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法仅有纳米级的差距</td>
<td>如果线程间存在锁的竞争，会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问的同步块场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的相应速度</td>
<td>如果始终得不到锁竞争的线程，使用自旋会消耗CPU</td>
<td>追求响应时间 同步响应非常快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU</td>
<td>线程阻塞，响应时间缓慢</td>
<td>追求吞吐量 同步块执行速度较长</td>
</tr>
</tbody></table>
<h4 id="监视器（Monitor）"><a href="#监视器（Monitor）" class="headerlink" title="监视器（Monitor）"></a>监视器（Monitor）</h4><p>java中（HotSpot虚拟机）由ObjectMonitor（C++：ObjectMonitor.cpp）实现，一个对象会关联到一个Monitor，如果Monitor被持有则会处于锁定状态。synchronized的实现基于进入和退出Monitor对象：</p>
<ol>
<li>MonitorEnter指令：插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁；</li>
<li>MonitorExit指令：插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit；</li>
</ol>
<p>Java中万物都是对象，所有的java对象都可以成为Monitor，因为每个java对象创建时候就带了一把看不见的锁，称为内部锁或者Monitor锁，即synchronized的对象锁。MarkWord锁的标识位为10，指针指向Monitor起始地址。</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>​		JUC下Lock接口的一个实现类。功能比synchronized更灵活，底层实现依赖于<strong>AQS</strong>，支持手动加解锁，支持手动设置<strong>公平锁</strong>和<strong>非公平锁</strong>，支持线程中断。其中定义了一个内部类Sync继承AQS。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/reentrantlock-class-diagram.png" alt="img"></p>
<ul>
<li>公平锁：线程必须依靠先后顺序获取锁，即FIFO队列。公平锁的实现逻辑先判断当前AQS的CLH队列中是否正在排队的线程，如果队列为空，那么通过CAS加锁，如果加锁成功则继续向下执行。如果AQS有正在持有锁的线程，那么会判断持有锁的线程是否为当前线程，如果与当前线程是同一个那么就可以实现锁重入。如果获取锁失败，那么将会插入到CLH队列。</li>
<li>非公平锁（默认）：直接通过CAS进行资源争抢，获取成功继续执行，否则进入FIFO队列等待唤醒。一般情况下非公平锁的效率要优于公平锁。</li>
</ul>
<p>相比synchronized增加的功能：</p>
<ul>
<li>等待可中断：正在等待的线程可以放弃等待改处理其他事</li>
<li>可实现公平锁：可以指定公平锁或者非公平锁，synchronize只能实现风公平锁</li>
<li>可实现选择性通知（可以绑定多个条件）：可以通过Condition接口和newCondition方法实现等待通知机制</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/15/Java%E9%94%81/" data-id="clix3qjva0002qwue07z18a50" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/06/15/sam%20related%20note/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/06/15/Sam%20on%20tooth/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/06/15/nnUNetv2%E7%AC%94%E8%AE%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/06/15/MedNeXt%20Transformer-driven%20Scaling%20of%20ConvNets%20for%20Medical%20Image%20Segmentation/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/06/15/%E5%BC%82%E4%BD%8D%E8%90%8C%E5%87%BA%E4%BB%BB%E5%8A%A1/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>