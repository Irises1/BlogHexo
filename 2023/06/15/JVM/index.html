<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="JVM（JAVA虚拟机）Java内存区域 线程私有空间程序计数器可以视作当前线程执行的字节码的行号指示器。 作用：  字节码解释器通过改变程序计数器来依次读取指令从而实现代码的流程控制 在多线程情况下，程序计数器用于记录当前线程执行的位置，线程被切换回来时候知道上次运行到哪  注意：程序计数器是唯一不会出现OutOfMemoryError的内存区域，生命周期随着线程创建而生，线程结束而亡 Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2023/06/15/JVM/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="JVM（JAVA虚拟机）Java内存区域 线程私有空间程序计数器可以视作当前线程执行的字节码的行号指示器。 作用：  字节码解释器通过改变程序计数器来依次读取指令从而实现代码的流程控制 在多线程情况下，程序计数器用于记录当前线程执行的位置，线程被切换回来时候知道上次运行到哪  注意：程序计数器是唯一不会出现OutOfMemoryError的内存区域，生命周期随着线程创建而生，线程结束而亡 Java">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230319195806332.png">
<meta property="og:image" content="c:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230320211644627.png">
<meta property="og:image" content="c:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230320213759506.png">
<meta property="og:image" content="c:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230321212200400.png">
<meta property="og:image" content="c:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230319204718723.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/f8f5088839a9f1e36a3dd84e80c572e3.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/jvm/access-location-of-object-handle.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/jvm/access-location-of-object-handle-direct-pointer.png">
<meta property="og:image" content="https://javaguide.cn/assets/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.c1fbd0fe.jpeg">
<meta property="og:image" content="https://javaguide.cn/assets/90984624.e8c186ae.png">
<meta property="og:image" content="https://javaguide.cn/assets/94057049.22c58294.png">
<meta property="og:image" content="https://javaguide.cn/assets/CMS%E6%94%B6%E9%9B%86%E5%99%A8.8a4d0487.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/bg/desktop%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/jvm/lifecycle-of-a-class.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/jvm/class-loading-process-verification.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/jvm/class-loading-procedure.png">
<meta property="og:image" content="https://oss.javaguide.cn/github/javaguide/java/jvm/class-loader-parents-delegation-model.png">
<meta property="article:published_time" content="2023-06-15T12:12:02.366Z">
<meta property="article:modified_time" content="2023-05-25T02:50:38.596Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230319195806332.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-JVM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/06/15/JVM/" class="article-date">
  <time class="dt-published" datetime="2023-06-15T12:12:02.366Z" itemprop="datePublished">2023-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JVM（JAVA虚拟机）"><a href="#JVM（JAVA虚拟机）" class="headerlink" title="JVM（JAVA虚拟机）"></a>JVM（JAVA虚拟机）</h1><h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230319195806332.png" alt="image-20230319195806332"></p>
<h3 id="线程私有空间"><a href="#线程私有空间" class="headerlink" title="线程私有空间"></a>线程私有空间</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>可以视作当前线程执行的字节码的行号指示器。</p>
<p>作用：</p>
<ul>
<li>字节码解释器通过改变程序计数器来依次读取指令从而实现代码的<strong>流程控制</strong></li>
<li>在多线程情况下，程序计数器用于<strong>记录当前线程执行的位置</strong>，线程被切换回来时候知道上次运行到哪</li>
</ul>
<p>注意：程序计数器是唯一不会出现<code>OutOfMemoryError</code>的内存区域，生命周期随着线程创建而生，线程结束而亡</p>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>所有Java方法都是通过调用栈来实现的。方法的调用数据需要通过栈来传递，每一次方法调用都会有对应的栈帧被压入栈，每一个方法结束都会有一个栈帧被弹出。每一个栈帧包括：局部变量表，操作数栈，动态链接，方法返回地址。</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230320211644627.png" alt="image-20230320211644627"></p>
<p><strong>局部变量表：</strong>存放编译期可知的<strong>数据类型</strong>（8种基本数据类型），<strong>对象引用</strong>（reference类型，可能是指向对象起始地址的引用指针也有可能是对象句柄）</p>
<p><strong>操作数栈：</strong>主要作为方法调用的中转站，用于存放方法执行过程中产生的中间计算结果。以及计算过程中产生的临时变量</p>
<p><strong>动态链接：</strong>服务一个方法需要调用其他方法的场景。动态链接定义为——将<strong>符号引用</strong>转换为调用方法的<strong>直接引用</strong>。符号引用保存在Class文件的常量池中，一个方法要调用其他方法时需要将常量池中指向方法的符号引用转化为在内存地址中的直接引用</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230320213759506.png" alt="image-20230320213759506"></p>
<p>当函数调用陷入循环会导致栈中压入太多栈帧，会出现错误。</p>
<p><strong>栈空间中出现的两种错误</strong></p>
<ul>
<li>**<code>StackOverFlowError</code>**：若内存大小不允许动态扩展，那么当线程请求栈的深度超过当前虚拟机栈的最大深度时就会抛出<code>StackOverFlowError</code>错误。</li>
<li>**<code>OutOfMemoryError</code>**：若栈的内存大小可以动态扩展，如果虚拟机在动态扩展栈时无法申请到足够内存空间就会抛出<code>OutOfMemoryError</code>错误。</li>
</ul>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>作用类似虚拟机栈，虚拟机栈为虚拟机执行Java方法（字节码）服务，本地方法栈给虚拟机使用的Native方法服务。在HotSpot虚拟机中与Java虚拟机栈合二为一。</p>
<h3 id="线程共享空间"><a href="#线程共享空间" class="headerlink" title="线程共享空间"></a>线程共享空间</h3><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>Java虚拟机管理内存最大的一块，所有线程共享，唯一目的就是存放<strong>对象实例</strong>，几乎所有的对象实例和数据都在这里分配内存。（JDK1.7开始默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（未逃逸），那么对象可以直接在栈上分配内存。）</p>
<p>Java堆是垃圾收集器管理的主要区域，因此也可称GC堆（Garbage Collected Heap）。由于收集器都采用分代垃圾收集算法，因此Java堆还可以细分：新生代和老年代，再进一步还有：Eden，Survivor，Old等空间。细分的目的在于更好更高效的管理分配内存。</p>
<p>JDK7之前，堆内存分为以下三部分：</p>
<ol>
<li>新生代内存（Young Generation）</li>
<li>老生代（Old Generation）</li>
<li>永久代（Permanent Generation）</li>
</ol>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230321212200400.png" alt="image-20230321212200400"></p>
<p>如图，Eden和两个Survivor区S0和S1都属于新生代，中间属于老年代，最下面一层MetaSpace属于永久代。</p>
<p>对象首先在Eden区域分配，在一次新生代垃圾回收后，如果对象还存活会进入S0或者S1，同时对象年龄+1，当年龄增加到一定程度（默认15），就会晋升到老年代。这个年龄阈值可以通过参数<code>-XX:MaxTenuringThreshold</code>来设置。</p>
<p>Hotspot动态年龄计算算法：</p>
<p>先遍历所有的对象按照年龄从小到大对占有的大小进行累积（即计算某年龄以下的所有空间），当累积的大小超过Survivor区的一半时，取这个年龄和MaxTenuringThreshold中的较小值作为新的晋升年龄阈值。</p>
<p><strong>容易出现的错误：</strong><code>OutOfMemoryError</code></p>
<ol>
<li><strong><code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li>
<li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过<code>-Xmx</code>参数配置，若没有特别配置，将会使用默认值)</li>
</ol>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>JVM运行时数据区域的一块逻辑区域，各线程共享。</p>
<p>当虚拟机要使用一个类时，会读取解析Class文件相关信息，然后存入方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p>
<p>改到MetaSpace的原因：基于本地内存，内存溢出的几率会更小。</p>
<p>元空间溢出错误：<code>java.lang.OutOfMemoryError: MetaSpace</code></p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>Class文件除了方法区中的信息外，还有存放编译时期产生的各种字面量（Literal）和符号引用（Symbolic Reference）（虚拟机栈中动态链接有提到）的常量池表。</p>
<p>无法申请到内存会抛出 <code>OutOfMemoryError</code> </p>
<h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p>为了提升性能减少内存消耗针对字符串（String类）专门开辟的区域，为了避免字符串重复创建。当创建的字符串在常量池中已经有时，会直接引用。JDK1.7字符串常量池和静态变量从永久代移到了java堆中。（因为永久代GC的回收效率太低）</p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>一种特殊的内存缓冲区，不再堆或者方法区中分配，在JNI方式在本地内存上分配，不是虚拟机运行时数据区的一部分，也不是虚拟机规范定义的区域，但是被频繁的用到</p>
<h3 id="HotSpot虚拟机"><a href="#HotSpot虚拟机" class="headerlink" title="HotSpot虚拟机"></a>HotSpot虚拟机</h3><h4 id="对象创建（重要）"><a href="#对象创建（重要）" class="headerlink" title="对象创建（重要）"></a>对象创建（重要）</h4><p><strong>Step1：类加载检查</strong></p>
<p>首先检查是否能在常量池中找到这个类的符号引用。</p>
<p>并检查这个符号引用代表的类是否被加载，解析，初始化过。</p>
<p>如果没有那必须执行相应<strong>类加载</strong>过程。</p>
<p><strong>Step2：分配内存</strong></p>
<p>类加载检查通过后，虚拟机将为新生对象分配内存。对象需要空间大小在类加载后就可以确定。分配方式有<strong>“指针碰撞”</strong>和<strong>“空闲列表”</strong>。如何选择由Java堆是否规整决定，堆是否规整又由采用的垃圾收集器是否带有压缩整理功能决定。</p>
<p>内存分配方式（需掌握）：</p>
<ul>
<li><p>指针碰撞</p>
<ul>
<li>适用场景：堆内存规整（没有内存碎片）</li>
<li>原理：用过的内存全整合到一边，与没用过的内存适用分界指针隔开，向着没用过的内存方向移动指针，移动对象内存需要的大小位置即可。</li>
<li>适用分配方式的GC收集器：Serial，ParNew</li>
</ul>
</li>
<li><p>空闲列表</p>
<ul>
<li>适用场景：堆内存不规整</li>
<li>原理：虚拟机维护一个列表，记录哪些内存块可用，分配时找一块足够大小的划分给对象实例，然后更新列表</li>
<li>使用分配方式的GC收集器：CMS</li>
</ul>
</li>
</ul>
<p>内存分配的并发问题（需掌握）：</p>
<p>虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li>CAS(同步处理)+失败重试：乐观锁（假设没有冲突完成操作，一旦因为冲突失败了才重试，直到成功）的一种实现方式。使用CAS+失败重试可以保证更新操作的原子性。</li>
<li>TLAB(本地线程分配缓存)：为每一个线程预先在Eden分配一块内存，JVM给线程的对象分配内存时首先在TLAB中分配。当对象大于TLAB的剩余内存或者内存已用尽，再采用上述的CAS分配内存。</li>
</ul>
<p><strong>Step3：初始化零值</strong></p>
<p>内存分配之后，虚拟机对分配的内存空间初始化为零值（不包括对象头），保证了对象实例在代码中不赋初始值就可以直接使用，程序可以直接访问对应数据类型对应的零值。</p>
<p><strong>Step4：设置对象头</strong></p>
<p>对象是哪个类的实例，如何找到类的元数据信息，对象哈希码，对象GC分代年龄等信息写入对象头。虚拟机并根据当前运行状态不同，如是否启用偏向锁，对对象头设置方式会有不同。</p>
<p><strong>Step5：执行init方法</strong></p>
<p>对对象开始初始化成员字段</p>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>java对象的存储布局：</p>
<p><img src="C:\Users\Bubble\AppData\Roaming\Typora\typora-user-images\image-20230319204718723.png" alt="image-20230319204718723"></p>
<ul>
<li>对象头：Java对象头占用2个机器码（如果对象是数组则需要3个）</li>
<li>实例数据：存放类的属性数据信息，包括父类的属性信息</li>
<li>对齐填充：因为虚拟机要求，对象起始地址必须是8字节整数倍</li>
</ul>
<p>对象头内容：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f8f5088839a9f1e36a3dd84e80c572e3.png" alt="img"></p>
<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>通过栈上的reference来操作堆上的具体对象，访问方式由虚拟机实现，主流有：<strong>使用句柄</strong>，<strong>直接指针</strong></p>
<ul>
<li><p>使用句柄</p>
<p>堆会划分一块内存作为句柄池，reference存储句柄地址，句柄包含了对象实例数据和对象类型数据各自的具体地址信息</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/access-location-of-object-handle.png" alt="对象的访问定位-使用句柄"></p>
</li>
<li><p>直接指针</p>
<p>reference直接存储对象地址</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/access-location-of-object-handle-direct-pointer.png" alt="对象的访问定位-直接指针"></p>
</li>
</ul>
<p>句柄方式的好处是reference存储稳定句柄地址，对象被移动只要改变句柄的实例数据指针，不用更改reference</p>
<p>直接指针优势是速度快，节省了一次指针定位的时间开销</p>
<h2 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h2><h3 id="内存分配和回收原则"><a href="#内存分配和回收原则" class="headerlink" title="内存分配和回收原则"></a>内存分配和回收原则</h3><p>大多数情况下，对象在新生代的的Eden分配，当Eden区没有足够空间进行分配时，虚拟机会发起一次Minor GC。</p>
<h4 id="大对象"><a href="#大对象" class="headerlink" title="大对象"></a>大对象</h4><p>大对象（需要大量连续内存空间，比如字符串和数组）直接进入老年代，因为为了避免大对象分配内存时由于分配担保机制带来的复制而降低效率。</p>
<h4 id="长期存活对象"><a href="#长期存活对象" class="headerlink" title="长期存活对象"></a>长期存活对象</h4><p>虚拟机给了每个对象一个年龄（Age）计数器：</p>
<p>对象在Eden出生并经过第一次Minor GC后仍然存活，且被Survivor容纳被移动到Survivor空间的s0或者s1时，对象年龄设置为1。（Eden区-&gt;Survivor区后对象初始年龄变为1）</p>
<p>在Survivor区每熬过一次Minor GC，年龄增加1岁，当年龄增加到一定程度（默认15岁，可以通过参数<code>-XX:MaxTenuringThreshold</code>设置），就会被晋升到老年代。</p>
<p>Hotspot对老年代的年龄晋升阈值动态计算：</p>
<p>先遍历所有的对象按照年龄从小到大对占有的大小进行累积（即计算某年龄以下的所有空间），当累积的大小超过Survivor区的一半时，取这个年龄和MaxTenuringThreshold中的较小值作为新的晋升年龄阈值。</p>
<h4 id="主要进行GC的区域"><a href="#主要进行GC的区域" class="headerlink" title="主要进行GC的区域"></a>主要进行GC的区域</h4><p>GC准确分类主要有两大种</p>
<ul>
<li><p>部分收集（Partial GC）：</p>
<ul>
<li>新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集；</li>
<li>老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。注意Major在有的语境中也用于指代整堆收集</li>
<li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集</li>
</ul>
</li>
<li><p>整堆收集（Full GC）：整个Java堆和方法区</p>
</li>
</ul>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>为了确保在Minor GC之前老年代本身还有容纳新生代所有对象的剩余空间</p>
<h3 id="死亡对象的判断方法"><a href="#死亡对象的判断方法" class="headerlink" title="死亡对象的判断方法"></a>死亡对象的判断方法</h3><p>垃圾回收的第一步：判断哪些对象已经死亡（不能再被任何途径使用的对象）</p>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>给对象添加一个引用计数器</p>
<ul>
<li>每当有一个地方引用，计数器就+1</li>
<li>当引用失效，计数器-1</li>
<li>任何时候计数器为0的对象就是不可能再次被使用</li>
</ul>
<p>实现简单，效率高。但是主流虚拟机没有选择这个算法，原因是很难解决对象之间相互循环引用的问题。</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>基本思想是通过一系列的称为”GC Roots“的对象作为起点，从这些节点向下搜索，节点所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连证明此对象不可用，需要被回收。</p>
<p>如果对象之间有引用关系，但是GC Roots不可达，还是会成为需要回收的对象</p>
<p>可以作为GC Roots的对象：</p>
<ul>
<li>虚拟机栈（帧栈中的本地变量表）中引用的对象</li>
<li>本地方法栈（Native方法）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
</ul>
<p>判断对象可以被回收就一定会被回收吗？</p>
<p>真正判断一个对象死亡，要经过两次标记过程。可达性分析的不可达对象被第一次标记且进行一次筛选，筛选条件是此对象是否有必要执行<code>finalize</code>方法。当对象没有覆盖<code>finalize</code>方法或者已经被虚拟机调用过时，这两种情况视为没必要执行对象死亡。判断为需要执行死亡的对象会被放在一个队列中进行二次标记，除非这个对象和引用链上任何一个对象建立关联，否则就会被真的回收。</p>
<p><code>Object</code>的<code>finalize</code>方法加重了Java语言的负担，影响了Java语言的安全性和GC性能。在JDK9后续版本各个类的<code>finlize</code>方法被逐渐弃用移除。</p>
<p>引用计数法和可达性分析法判断是否可达，都和引用有关，引用分为：</p>
<ul>
<li>强引用</li>
</ul>
<p>大部分引用，如果一个对象有强引用，垃圾回收器就绝不会回收。当内存不足时宁愿抛出OutOfMemoryError错误也不会随意回收有强引用的对象</p>
<ul>
<li>软引用</li>
</ul>
<p>类似于可有可无，内存足够就不会回收，内存不足就会回收。软引用可以用来实现内存敏感的高速缓存。</p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列。</p>
<ul>
<li>弱引用</li>
</ul>
<p>弱引用与软引用的区别：只有弱引用的对象拥有更短暂的生命周期。当垃圾回收器发现弱引用对象，不管内存是否充足都会回收。</p>
<p>也可以和软引用一样和引用队列回收使用</p>
<ul>
<li>虚引用</li>
</ul>
<p>形同虚设，等价于没有引用，任何时候都可能会被垃圾回收。与弱引用软引用主要的区别：必须结合引用队列使用。当虚引用的对象被加入引用队列就可以在被回收前采取必要行动。</p>
<p>一般程序设计很少使用弱引用和虚引用，软引用使用比较多。因为软引用可以加速JVM对垃圾回收的回收速度，维护系统运行安全，防止内存溢出。</p>
<h4 id="判断废弃常量"><a href="#判断废弃常量" class="headerlink" title="判断废弃常量"></a>判断废弃常量</h4><p>假如字符串常量池中有一个字符串，如果当前没有任何String对象引用这个字符串常量就说明这个字符串就是废弃常量，内存回收的时候会被清理。</p>
<h4 id="判断无用类"><a href="#判断无用类" class="headerlink" title="判断无用类"></a>判断无用类</h4><p>同时满足三个条件可以被回收，不是必然回收：</p>
<ul>
<li>该类的所有实例都已经被回收，即Java堆中不存在该类任何实例</li>
<li>加载该类的<code>ClassLoader</code>已经被回收</li>
<li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>最基础的收集算法：先标记出所有<strong>不需要回收</strong>的对象，标记完成后统一回收所有没有标记的对象。</p>
<p>两个明显问题：</p>
<ol>
<li>效率问题</li>
<li>空间问题（产生大量不连续的碎片）</li>
</ol>
<p><img src="https://javaguide.cn/assets/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.c1fbd0fe.jpeg" alt="img"></p>
<h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><p>将内存分为大小相同的两块，每次使用其中一块，当这一块内存使用完后，将还存活的对象复制到另一块，然后清理使用的空间。这样每次的内存回收都对内存区间的一半进行</p>
<p><img src="https://javaguide.cn/assets/90984624.e8c186ae.png" alt="复制算法"></p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>根据老年代的特点提出的一种标记算法，过程仍然和””标记-清除”算法一样，但是不是直接对可回收对象回收，而是让所有存活对象向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><img src="https://javaguide.cn/assets/94057049.22c58294.png" alt="标记-整理算法 "></p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，根据每个年代的特点选择合适的垃圾收集算法。</p>
<p>新生代每次收集都会有大量对象死去，可以选择“标记-复制”算法，因为复制对象的成本很小。老年代对象存活的几率比较高，而且没有额外的空间对它进行分配担保，所以选择“标记-清除”或者“标记-整理”算法进行垃圾收集。</p>
<p>延申面试问题：为什么HotSpot要分新生代和老年代？可以根据这里分代收集算法的介绍回答</p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>垃圾收集器是内存回收的具体实现。垃圾收集器有多种，要根据应用场景选择适合自己的垃圾收集器</p>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>Serial（串行）收集器：最基本，历史最久，是个单线程收集器。意味着使用一条垃圾收集器线程去完成垃圾收集，并且进行收集工作时候必须暂停其他所有工作线程。新生代使用标记-复制算法，老年代使用标记-整理算法</p>
<p>好处是简单而高效（与其他收集器的单线程比较），对于运行在Client模式下的虚拟机来说是不错的选择</p>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>就是Serial收集器的多线程版本，除了多线程以外其他的与Serial收集器完全一样</p>
<p>是许多运行在Server模式下虚拟机的首要选择，除了Serial收集器以外只有它可以和CMS收集器（真正意义的并发收集器，见下）配合工作</p>
<ul>
<li><p>并行：多条垃圾收集器线程并行工作，此时用户线程仍然等待</p>
</li>
<li><p>并发：用户线程和垃圾收集器线程同时执行（可能并行，可能交替执行）</p>
</li>
</ul>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p>使用标记-复制算法的多线程收集器，看上去几乎和ParNew一样。</p>
<p>关注吞吐量，CMS等收集器关注用户线程的停顿时间。</p>
<p>新生代使用标记-复制，老年代使用标记-整理</p>
<h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>Serial收集器的老年代版本，两种用途：在JKD1.5以前的版本与Parallel Scavenge收集器搭配使用，另一种是作为CMS收集器的后备方案</p>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>Parallel Scavenge收集器的老年代版本。使用多线程和标记-整理算法。在注重吞吐量和CPU资源的场合可以优先考虑Parallel Scavenge收集器和Parallel Old收集器。</p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS（<strong>Concurrent Mark Sweep</strong>）：一种以获取最短回收停顿时间为目标的收集器。第一款真正并发收集器，第一次实现让垃圾收集器和用户线程（基本上）同时工作。标记-清除算法实现，运作过程稍微复杂一点。四个步骤：</p>
<ul>
<li>初始标记：暂停其他所有线程，记录下与root相连的对象，速度很快</li>
<li>并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象。在这个阶段结束，这个闭包结构并不能保证当前所有可达对象。因为用户线程可能会不断更新引用域，所以GC线程无法保证可达性分析的实时性。这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li>重新标记：为了修正并发期间因为用户程序运行而导致标记变动的那一部分对象的标记记录。这个阶段的停顿时间比初始标记稍微长，但是远远比并发标记时间短</li>
<li>并发清除：开启用户线程，同时GC线程开始对为标记的区域做清扫</li>
</ul>
<p><img src="https://javaguide.cn/assets/CMS%E6%94%B6%E9%9B%86%E5%99%A8.8a4d0487.png" alt="CMS 垃圾收集器 "></p>
<p>优点：并发收集，低停顿</p>
<p>缺点</p>
<ul>
<li>对CPU资源敏感</li>
<li>无法处理浮动垃圾</li>
<li>使用“标记-清除”算法会导致收集结束时有大量空间碎片产生</li>
</ul>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>（Garbage First）：一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。极高概率满足GC停顿时间要求的同时还具备高吞吐量性能特征。特点有以下：</p>
<ul>
<li>并行和并发：可以充分利用CPU，多核环境下的硬件优势，使用多个CPU来缩短停顿时间。而且可以通过并发的方式让java程序继续执行</li>
<li>分代收集：虽然不需要其他垃圾收集器配合就可以独立管理整个GC堆，但还是保留了分代的概念</li>
<li>空间整合：与CMS的标记-清除算法不同，虽然整体上是基于“标记-整理”算法实现，局部上是基于“标记-复制”算法实现</li>
<li>可预测的停顿：除了追求低停顿还能建立可预测的停顿时间模型，让使用者明确指定在一个长度为M毫秒的时间片段内</li>
</ul>
<p>运作分为以下步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ul>
<p>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，选择回收价值最大的Regin。这种使用Regin划分内存空间以及有优先级的区域回收方式保证了G1收集器在有限的时间内尽可能提高收集效率（将内存化整为零）。</p>
<h4 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h4><p>与CMS中的ParNew和G1类似，也采用了标记-复制算法，不过ZGC对算法做了重大改进，出现停顿其他线程的情况会更少。</p>
<h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h2><p>JVM可以理解的代码就是字节码，即<code>.class</code>文件，不面向任何特定处理器，只面向虚拟机。使用字节码的好处是<strong>既一定程度解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点</strong>。因此java语言无须重新编译就可以在多种不同操作系统的计算机上运行。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/bg/desktop%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88.png" alt="java虚拟机"></p>
<p><code>.class</code>文件是不同的语言在Java虚拟机之间的重要桥梁，也是支持Java跨平台的一个重要原因</p>
<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>Class文件通过<code>ClassFile</code>定义，类似于C语言的结构体，结构如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类可以有多个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="魔数（Magic-Number）"><a href="#魔数（Magic-Number）" class="headerlink" title="魔数（Magic Number）"></a>魔数（Magic Number）</h4><p>4字节，作用是确定这个文件是否是一个能被虚拟机接收的Class文件</p>
<h4 id="Class文件版本号（Minor-amp-Major-Version）"><a href="#Class文件版本号（Minor-amp-Major-Version）" class="headerlink" title="Class文件版本号（Minor&amp;Major Version）"></a>Class文件版本号（Minor&amp;Major Version）</h4><p>4字节</p>
<h4 id="常量池（Constant-Pool）"><a href="#常量池（Constant-Pool）" class="headerlink" title="常量池（Constant Pool）"></a>常量池（Constant Pool）</h4><p>数量是<code>constant_pool_count - 1</code></p>
<p>存放两大常量：</p>
<ul>
<li><p>字面量</p>
<p>类似Java语言层面的常量概念</p>
</li>
<li><p>符号引用</p>
<p>编译概念，包括：类和接口的全限定名，字段的名称和描述符，方法的名称和描述符</p>
</li>
</ul>
<p>常量池中每一项常量都是一个表</p>
<h4 id="访问标志（Access-Flag）"><a href="#访问标志（Access-Flag）" class="headerlink" title="访问标志（Access Flag）"></a>访问标志（Access Flag）</h4><p>识别一些类或者接口层次的访问信息</p>
<p>包括：</p>
<p>是类还是接口，是否为<code>public</code>或者<code>abstract</code>，类是否声明为<code>final</code>等</p>
<h4 id="当前类（This-Class），父类（Super-Class），接口（Interfaces）索引集合"><a href="#当前类（This-Class），父类（Super-Class），接口（Interfaces）索引集合" class="headerlink" title="当前类（This Class），父类（Super Class），接口（Interfaces）索引集合"></a>当前类（This Class），父类（Super Class），接口（Interfaces）索引集合</h4><p>继承关系由这三项集合确定，类索引确定类的全限定名，父类索引确定类的父类全限定名，接口索引集合描述实现哪些接口。</p>
<h4 id="字段表集合（Fields）"><a href="#字段表集合（Fields）" class="headerlink" title="字段表集合（Fields）"></a>字段表集合（Fields）</h4><p>描述接口或者类中声明的变量，包括类级变量和实例变量，不包括内部声明的局部变量</p>
<h4 id="方法表集合（Methods）"><a href="#方法表集合（Methods）" class="headerlink" title="方法表集合（Methods）"></a>方法表集合（Methods）</h4><p>方法数量和方法表</p>
<h4 id="属性表集合（Attributes）"><a href="#属性表集合（Attributes）" class="headerlink" title="属性表集合（Attributes）"></a>属性表集合（Attributes）</h4><p>描述某些场景专有的信息</p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>七个阶段：</p>
<p>加载（Loading），验证（Verification），准备（Preparation），解析（Resolution），初始化（Initialization），使用（Using），卸载（Unloading）</p>
<p>（前三个阶段可统称连接（Linking））</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/lifecycle-of-a-class.png" alt="一个类的完整生命周期"></p>
<h3 id="类加载过程-1"><a href="#类加载过程-1" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>虚拟机加载Class文件的过程，主要是三步：加载-&gt;连接（验证-&gt;准备-&gt;解析）-&gt;初始化</p>
<h4 id="加载：（由类加载器完成）"><a href="#加载：（由类加载器完成）" class="headerlink" title="加载：（由类加载器完成）"></a>加载：（由类加载器完成）</h4><ol>
<li>通过全类名获取定义此类的二进制字节流</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表该类的<code>Class</code>对象，作为方法区这些数据的访问入口</li>
</ol>
<p>加载具体的类，具体由哪个类加载器加载由<strong>双亲委派模型</strong>决定。</p>
<p>每个Java类都有一个引用指向加载它的<code>ClassLoader</code>，除了数组类是通过JVM在需要的时候自动创建的，数组类在通过<code>getClassLoader()</code>方法获取<code>ClassLoader</code>和该数组的元素类型<code>ClassLoader</code>是一致的</p>
<p>非数组类在加载阶段是可控性最强的阶段，可以去完成自定义类加载器去控制字节流的获取方式（重写一个类加载器的<code>LoadClass()</code>方法）</p>
<p>加载阶段和连接阶段的部分动作是交叉进行的，类加载没结束可能连接阶段已经开始。</p>
<h4 id="验证："><a href="#验证：" class="headerlink" title="验证："></a>验证：</h4><p>连接阶段的第一步，目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的约束要求，确保这些信息作为代码运行后不会危害虚拟机自身安全。</p>
<p>如果全部代码已经被反复使用和验证过，在生产环境的实施阶段可以考虑使用<code>-Xverify:none</code>参数关闭大部分类验证措施，缩短虚拟机类加载时间。</p>
<p>四个检验阶段：</p>
<ol>
<li>文件格式验证（Class文件格式检查）</li>
<li>元数据验证（字节码语义检查）</li>
<li>字节码验证（程序语义检查）</li>
<li>符号引用验证（类的正确性检查）</li>
</ol>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/class-loading-process-verification.png" alt="验证阶段示意图"></p>
<h4 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h4><p>正式为类变量分配内存并设置类变量初始值，内存都将在方法区分配</p>
<p>注意</p>
<ol>
<li>此时进行内存分配的仅包括类变量，即静态（<code>static</code>）变量，不包括实例变量，实例变量跟随对象实例化一起分配在java内存</li>
<li>概念上，类变量所有的内存都在方法区分配。JDK 7之后HotSpot把原本在永久代的字符串常量池，静态变量等移动到了堆中，类变量也随着一起到了Java堆</li>
<li>这里的初始值通常是默认零值，比如定义<code>public static int value = 111</code>，那么在这里，初始化value变量为0而不是111（初始化阶段才赋值），但是如果加上了final关键字，这里就会被赋值为111</li>
</ol>
<h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>虚拟机将常量池内符号引用替换为直接引用。解析动作主要针对类或者接口，字段，接口方法，方法类型，方法句柄和调用限定符7类符号</p>
<ul>
<li>符号引用：一组符号描述引用的目标，符号可以是任何形式，只要可以无歧义定位到目标，引用的也不一定是加载到虚拟机内存中的内容。</li>
<li>直接引用：可以直接指向目标的指针，相对偏移量或者直接定位到目标的句柄，和虚拟机内存布局直接相关，有了直接引用，引用的目标则一定在虚拟机内存中存在。</li>
</ul>
<h4 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h4><p>执行初始化方法<code>&lt;clinit&gt;()</code>过程，这时候JVM才真正执行类定义的Java程序代码。<code>&lt;clinit&gt;()</code>是编译后自动生成的。<code>&lt;clinit&gt;()</code>带锁线程安全，在多线程环境下类初始化会引起多个线程阻塞，虚拟机要保证多线程环境下的安全性。</p>
<p>虚拟机严格规范有且只有以下五种情况，必须对类初始化（只有主动使用类才会初始化）</p>
<ol>
<li>遇到<code>new</code>，<code>getstatic</code>（访问类静态变量），<code>putstatic</code>（给类静态变量赋值）或者<code>invokestatic</code>（调用类静态方法）这四条直接码指令时，对应<code>new</code>一个类，读取静态字段或者调用类静态方法时。</li>
<li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用时比如<code>Class.forname(&quot;...&quot;)</code>，<code>newInstance()</code>等等，如果类没初始化需要触发其初始化。</li>
<li>初始化一个类，其父类还没初始化，先触发父类初始化</li>
<li>虚拟机启动，用户需要定义一个执行的主类（包含<code>main</code>），虚拟机会先初始化这个类</li>
<li><code>MethodHandle</code>和<code>VarHandle</code>可以看作轻量级的反射调用机制，如果想要使用这两个调用，必须先使用<code>findStaticVarHandle</code>来初始化要调用的类</li>
<li>一个接口定义了JDK8新加入的默认方法，如果这个接口的实现类发生初始化，那接口要在其之前初始化</li>
</ol>
<h3 id="类卸载"><a href="#类卸载" class="headerlink" title="类卸载"></a>类卸载</h3><p>即类的Class对象被GC</p>
<p>满足三个要求：</p>
<ol>
<li>该类的所有实例对象都已经被GC，堆不存在该类的实例对象</li>
<li>该类没有在其他任何地方被引用</li>
<li>该类的类加载器实例已经被GC</li>
</ol>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>类加载过程：加载-&gt;连接-&gt;初始化</p>
<p>连接分为：验证-&gt;准备-&gt;解析</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/class-loading-procedure.png" alt="类加载过程"></p>
<p>类加载主要完成3件事</p>
<ol>
<li>通过全类名获得定义类的二进制字节流</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成一个代表该类的<code>Class</code>对象，作为方法区这些数据的访问入口</li>
</ol>
<p>类加载其是一个负责加载类的对象<code>ClassLoader</code>是一个抽象类。给定类二进制名称，类加载器尝试定位或生成构成类定义的数据，典型策略就是将名称转换为文件名，然后从文件系统读取该类名称的“类文件”</p>
<ul>
<li>类加载器是一个负责加载类的对象，用于实现类加载过程中的加载一步</li>
<li>每个Java类都有一个引用指向加载它的<code>ClassLoader</code></li>
<li>数组类不是通过<code>ClassLoader</code>创建，由JVM直接生成</li>
</ul>
<h3 id="类加载器加载规则"><a href="#类加载器加载规则" class="headerlink" title="类加载器加载规则"></a>类加载器加载规则</h3><p>根据需要动态加载，大部分类在具体用到才去加载。已加载的类放在<code>ClassLoader</code>，类加载时候先判断是否被加载过，已加载会直接返回，否则才尝试加载。</p>
<h3 id="常用类加载器"><a href="#常用类加载器" class="headerlink" title="常用类加载器"></a>常用类加载器</h3><ol>
<li><code>BootstrapClassLoader</code>(启动类加载器)：最顶层的加载类，由C++实现，通常表示为null且没有父级，主要用来加载JKD内部的核心类库以及被<code>-Xbootclasspath</code>参数指定的路径下的所有类</li>
<li><code>ExtensionClassLoader</code>(扩展类加载器)：主要负责加载<code>%JRE_HOME%/lib/ext</code>目录下的jar包和类以及被<code>java.ext.dirs</code>系统变量指定的路径下的所有类</li>
<li><code>AppClassLoader</code>(应用程序加载类)：面向用户的加载器，负责加载当前应用classpath下的所有jar包和类</li>
</ol>
<p>除<code>BootstrapClassLoader</code>是JVM自身一部分以外，其他的类加载器都是在JVM外部实现，且都继承自<code>ClassLoader</code>抽象类。好处是用户可以自定义类加载器</p>
<p>每个类加载器都通过<code>getParent()</code>获取父类加载器，如果是null的话表示通过<code>BootstrapClassLoader</code>加载</p>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>继承<code>ClassLoader</code>抽象类</p>
<p>两个关键方法：</p>
<ul>
<li><code>protrcted Class loadClass(String name, boolean resolve)</code>：加载指定二进制名称的类，实现双亲委派机制。<code>name</code>是类的二进制名称，<code>resove</code>如果是true，加载时调用<code>resolveClass(Class&lt;?&gt; c)</code>方法解析该类。</li>
<li><code>protected Class findClass(String name)</code>：根据类的二进制名称来查找类，默认实现是空方法</li>
</ul>
<p>如果要打破双亲委派模型就重需要重写<code>loadClass()</code>方法</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p><code>ClassLoader</code>使用委托模型来搜索类和资源，每个<code>ClassLoader</code>的实例都有一个相关父类加载器。需要查找类或者资源时，<code>ClassLoader</code>实例会试图亲自查找类或者资源之前，将搜索类或者资源的任务委托给父类加载器。</p>
<ul>
<li><code>ClassLoader</code>使用委托模型搜索类和资源</li>
<li>双亲委派模型要求除了顶层的启动类加载器以外的类加载器都要有自己的父类加载器</li>
<li><code>ClassLoader</code>实例在亲自查找类或者资源之前，将搜索类或资源的任务委托给父类加载器</li>
</ul>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/class-loader-parents-delegation-model.png" alt="类加载器层次关系图"></p>
<p>类加载器之间的父子关系不是继承来实现的，是使用组合关系来服用父加载器的代码：定义一个final的成员变量，并通过构造器赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 组合</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">ClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(checkCreateClassLoader(), parent);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>面向对象编程中的设计原则：组合优于继承，多用组合少用继承。</p>
<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p>见代码，<code>java.lang.ClassLoader</code>的<code>loadClass()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//首先，检查该类是否已经加载过</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果 c 为 null，则说明该类没有被加载过</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器不为空，则通过父类的loadClass来加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器为空，则调用启动类加载器来加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">//非空父类的类加载器无法找到相应的类，则抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//当父类加载器无法加载时，则调用findClass方法来加载该类</span></span><br><span class="line">                <span class="comment">//用户可通过覆写该方法，来自定义类加载器</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//用于统计类加载器相关的信息</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            <span class="comment">//对类进行link操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程可以概括为</p>
<ol>
<li><strong>类加载时先判断当前类是否被加载过，已经加载过会直接返回，否则尝试加载（每个父类加载器都会走一遍）</strong></li>
<li><strong>类加载器开始类加载，首先将请求委派给父类加载器，这样所有请求最终都会传到顶层的类启动加载器<code>BooststrapClassLoader</code>中</strong></li>
<li><strong>当父类加载器返回无法完成这个请求（搜索范围内没有找到所需的类），子加载器才会尝试自己去加载（调用自己的<code>findClass()</code>方法）</strong></li>
</ol>
<p>判断Java类相同的规则：</p>
<p>JVM不仅看两个类全名是否相同，还要看加载此类的类加载器是否一样。所以两个类来源于同一个<code>Class</code>文件，被同一虚拟机加载，只要加载的类加载器不同这两个类就必定不同</p>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>保证Java程序稳定运行，避免类重复加载，也保证Java的核心API不被篡改</p>
<p>如果没有双亲委派模型，而是每个类加载器加载自己会出现一些问题，比如编写了一个称为<code>java.lang.Object</code>类，在程序运行时，系统会出现两个Object类。双亲委派模型可以保证加载的是JRE里面的<code>Object</code>为不是自己写的<code>Object</code>，因为通过双亲委派模型，类加载会请求到<code>BoostrapClassLoader</code>，<code>BoostrapClassLoader</code>发现已经加载过<code>Object</code>就会直接返回。</p>
<h4 id="打破模型的方法"><a href="#打破模型的方法" class="headerlink" title="打破模型的方法"></a>打破模型的方法</h4><p>不想打破双亲委派模型，自定义类加载器（需要继承<code>ClassLoader</code>）时重写<code>findClass()</code>方法即可。想打破双亲委派模型要重写<code>loadClass()</code>方法，因为将请求委派给父类加载器通过调用<code>loadClass()</code>方法来加载类。比如Tomecat服务器为了保证优先加载Web应用目录下的类，然后加载其他目录下的类，就自定义了类加载器<code>WebAppClassLoader</code>来打破双亲委托机制。因此也是Tomcat下Web应用之间实现隔离的具体原理。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/15/JVM/" data-id="clix3qjsl0000qwuegtrwaorw" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/06/15/Leecode/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2023/06/15/Java%E7%9F%A5%E8%AF%86%E7%82%B9/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/06/15/sam%20related%20note/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/06/15/Sam%20on%20tooth/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/06/15/nnUNetv2%E7%AC%94%E8%AE%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/06/15/MedNeXt%20Transformer-driven%20Scaling%20of%20ConvNets%20for%20Medical%20Image%20Segmentation/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/06/15/%E5%BC%82%E4%BD%8D%E8%90%8C%E5%87%BA%E4%BB%BB%E5%8A%A1/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>